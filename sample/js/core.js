/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		2: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + ({"0":"dateTime","1":"tour"}[chunkId]||chunkId) + ".chunk-" + "0d4f3f811985247c9246" + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 155);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var core = __webpack_require__(46);
var hide = __webpack_require__(13);
var redefine = __webpack_require__(19);
var ctx = __webpack_require__(15);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(75)('wks');
var uid = __webpack_require__(26);
var Symbol = __webpack_require__(1).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(2);
var IE8_DOM_DEFINE = __webpack_require__(105);
var toPrimitive = __webpack_require__(47);
var dP = Object.defineProperty;

exports.f = __webpack_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(28);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(98)('wks');
var uid = __webpack_require__(67);
var Symbol = __webpack_require__(8).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(5)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 11 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(25);
module.exports = __webpack_require__(10) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(329);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(331);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(27);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(72);
var defined = __webpack_require__(29);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(10)) {
  var LIBRARY = __webpack_require__(35);
  var global = __webpack_require__(1);
  var fails = __webpack_require__(5);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(57);
  var $buffer = __webpack_require__(71);
  var ctx = __webpack_require__(15);
  var anInstance = __webpack_require__(37);
  var propertyDesc = __webpack_require__(25);
  var hide = __webpack_require__(13);
  var redefineAll = __webpack_require__(36);
  var toInteger = __webpack_require__(28);
  var toLength = __webpack_require__(7);
  var toIndex = __webpack_require__(106);
  var toAbsoluteIndex = __webpack_require__(39);
  var toPrimitive = __webpack_require__(47);
  var has = __webpack_require__(11);
  var classof = __webpack_require__(79);
  var isObject = __webpack_require__(3);
  var toObject = __webpack_require__(30);
  var isArrayIter = __webpack_require__(80);
  var create = __webpack_require__(49);
  var getPrototypeOf = __webpack_require__(50);
  var gOPN = __webpack_require__(48).f;
  var getIterFn = __webpack_require__(81);
  var uid = __webpack_require__(26);
  var wks = __webpack_require__(4);
  var createArrayMethod = __webpack_require__(51);
  var createArrayIncludes = __webpack_require__(73);
  var speciesConstructor = __webpack_require__(78);
  var ArrayIterators = __webpack_require__(82);
  var Iterators = __webpack_require__(41);
  var $iterDetect = __webpack_require__(59);
  var setSpecies = __webpack_require__(58);
  var arrayFill = __webpack_require__(77);
  var arrayCopyWithin = __webpack_require__(112);
  var $DP = __webpack_require__(6);
  var $GOPD = __webpack_require__(20);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(54)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var hide = __webpack_require__(13);
var has = __webpack_require__(11);
var SRC = __webpack_require__(26)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(46).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(52);
var createDesc = __webpack_require__(25);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(47);
var has = __webpack_require__(11);
var IE8_DOM_DEFINE = __webpack_require__(105);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(10) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var core = __webpack_require__(12);
var ctx = __webpack_require__(64);
var hide = __webpack_require__(31);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var IE8_DOM_DEFINE = __webpack_require__(130);
var toPrimitive = __webpack_require__(93);
var dP = Object.defineProperty;

exports.f = __webpack_require__(18) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(24);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(29);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(22);
var createDesc = __webpack_require__(66);
module.exports = __webpack_require__(18) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

/**
  * Check Utility
  * Author: jmoore
  *
  * Some tools used for consistency in how we check the environment our JavaScript runs in.
  * This could be either browser functionality or safety checks, such as that an object is defined.
  *
  * exists ( checkFor: String or Array of Strings [, parent: Object] )
  *   Allows a deep check for an object.  ie.  check.exists( ['mdManager', 'gigya.nameSpace.someNewFeature.someNewMethod'], window )
  *   returns: Boolean
  *
  * supports ( featureName: String )
  *   Checks for a browser feature such as localStorage, sessionStorage, or history
  *   returns: Boolean, or -1 if featureName is unrecognized
  *
  * new ( debug Object )
  *   This allows checks to output relevant debug messages
  *   returns: a new instance of the check module with the debug object that was passed in attached to it
  * -------------------------------------------------------------
  */

SNI.Application.addService('check', function (application) {

  var _supports = {}; //private cache of feature support
  var check = {

    exists: function exists(obj, parent) {
      var logId = 'check.exists()';
      obj = typeof obj === 'string' ? [obj] : obj;

      if (obj.constructor === Array && obj.length) {
        for (var i = 0; i < obj.length; i++) {
          var path = obj[i].split('.'),
              namespace = parent || window;

          for (var j = 0; j < path.length; j++) {
            if (typeof namespace[path[j]] === 'undefined') {
              if (check.debug) {
                check.debug.warn(logId, '`' + path.slice(0, j + 1).join('.') + '` does not exist.');
              }
              return false;
            } else {
              namespace = namespace[path[j]];
            }
          }
        }
      } else {
        if (check.debug) {
          check.debug.error(logId, 'Must be passed a string or an array of strings.');
        }
        return false;
      }

      return true;
    },

    jqueryPlugin: function jqueryPlugin(name) {
      var exists = typeof $.fn[name] !== 'undefined';
      if (!exists && check.debug) {
        check.debug.error('jQuery plugin ' + name + ' is not registered! maybe another copy of jQuery overwriting ours?');
      }
      return exists;
    },

    isProd: function isProd() {
      var isProd = !!window.location.hostname.match(/(www\.hgtv)|(www\.diynetwork)|(www\.greatamericancountry)|(www\.foodnetwork)|(www\.travelchannel)|(www\.cookingchanneltv)/g);
      check.debug.warn('isProd', isProd);
      return isProd;
    },

    isAuthor: function isAuthor() {
      return (/^author/.test(window.location.hostname)
      );
    },

    isFriendlyHost: function isFriendlyHost() {
      var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.hostname;

      return !/^(author|dispatcher|publish)/.test(host) && host !== 'localhost';
    },


    isLocalhost: function isLocalhost() {
      return window.location.hostname === 'localhost';
    },

    supports: function supports(name) {
      var result = -1;
      var storage = function storage(name) {
        //method borrowed from Modernizr
        var str = 'sniSuppTest';
        try {
          window[name].setItem(str, str);
          window[name].removeItem(str);
          return true;
        } catch (e) {
          return false;
        }
      };
      if (typeof _supports[name] !== 'undefined') {
        result = _supports[name];
      } else {
        if (name === 'localStorage' || name === 'sessionStorage') {
          result = storage(name);
        }
        if (name === 'history') {
          result = check.exists('history.pushState');
        }
        _supports[name] = result;
        if (check.debug) {
          check.debug.warn('check.supports()', name, 'is', result === true ? 'supported' : result === -1 ? 'unrecognized test' : 'unsupported');
        }
      }
      return result;
    },

    'new': function _new(obj) {
      return $.extend(true, check, { debug: obj });
    }
  };

  return check;
});

/***/ }),
/* 34 */
/***/ (function(module, exports) {

SNI.Application.addService('device-type', function (application) {
  var debug = application.getService('logger').create('service.device-type');

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var isMobile = !!application.getGlobal('cqMobile');
  var isTablet = /ipad|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
  var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !application.getGlobal('MSStream');

  // Let's only use these guys when it's absolutely unavoidable! This is a code smell!
  var isChrome = /Chrome/.test(navigator.userAgent);
  var isSafari = /Safari/.test(navigator.userAgent);
  var isIE = /Trident\//.test(navigator.userAgent);

  debug.log('isMobile: ' + isMobile + ', isTablet: ' + isTablet);

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    isIE: isIE,
    isChrome: isChrome,
    isSafari: isSafari,
    isTablet: isTablet,
    isMobile: isMobile,
    isIOS: isIOS
  };
});

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(19);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(28);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(11);
var TAG = __webpack_require__(4)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(107);
var enumBugKeys = __webpack_require__(76);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(4)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(13)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(274);
var defined = __webpack_require__(95);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(3);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(107);
var hiddenKeys = __webpack_require__(76).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(2);
var dPs = __webpack_require__(159);
var enumBugKeys = __webpack_require__(76);
var IE_PROTO = __webpack_require__(74)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(70)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(108).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(11);
var toObject = __webpack_require__(30);
var IE_PROTO = __webpack_require__(74)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(15);
var IObject = __webpack_require__(72);
var toObject = __webpack_require__(30);
var toLength = __webpack_require__(7);
var asc = __webpack_require__(160);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(26)('meta');
var isObject = __webpack_require__(3);
var has = __webpack_require__(11);
var setDesc = __webpack_require__(6).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(5)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var hide = __webpack_require__(13);
var uid = __webpack_require__(26);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(1);
var dP = __webpack_require__(6);
var DESCRIPTORS = __webpack_require__(10);
var SPECIES = __webpack_require__(4)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(4)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(15);
var call = __webpack_require__(114);
var isArrayIter = __webpack_require__(80);
var anObject = __webpack_require__(2);
var toLength = __webpack_require__(7);
var getIterFn = __webpack_require__(81);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(1);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(19);
var redefineAll = __webpack_require__(36);
var meta = __webpack_require__(53);
var forOf = __webpack_require__(60);
var anInstance = __webpack_require__(37);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(5);
var $iterDetect = __webpack_require__(59);
var setToStringTag = __webpack_require__(40);
var inheritIfRequired = __webpack_require__(172);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 62 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(13);
var redefine = __webpack_require__(19);
var fails = __webpack_require__(5);
var defined = __webpack_require__(29);
var wks = __webpack_require__(4);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(65);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 67 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(22).f;
var has = __webpack_require__(32);
var TAG = __webpack_require__(9)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var document = __webpack_require__(1).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(1);
var DESCRIPTORS = __webpack_require__(10);
var LIBRARY = __webpack_require__(35);
var $typed = __webpack_require__(57);
var hide = __webpack_require__(13);
var redefineAll = __webpack_require__(36);
var fails = __webpack_require__(5);
var anInstance = __webpack_require__(37);
var toInteger = __webpack_require__(28);
var toLength = __webpack_require__(7);
var toIndex = __webpack_require__(106);
var gOPN = __webpack_require__(48).f;
var dP = __webpack_require__(6).f;
var arrayFill = __webpack_require__(77);
var setToStringTag = __webpack_require__(40);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(38);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(16);
var toLength = __webpack_require__(7);
var toAbsoluteIndex = __webpack_require__(39);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(75)('keys');
var uid = __webpack_require__(26);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(30);
var toAbsoluteIndex = __webpack_require__(39);
var toLength = __webpack_require__(7);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(2);
var aFunction = __webpack_require__(27);
var SPECIES = __webpack_require__(4)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(38);
var TAG = __webpack_require__(4)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(41);
var ITERATOR = __webpack_require__(4)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(79);
var ITERATOR = __webpack_require__(4)('iterator');
var Iterators = __webpack_require__(41);
module.exports = __webpack_require__(46).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(43);
var step = __webpack_require__(110);
var Iterators = __webpack_require__(41);
var toIObject = __webpack_require__(16);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(111)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(2);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(15)(Function.call, __webpack_require__(20).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(15);
var invoke = __webpack_require__(117);
var html = __webpack_require__(108);
var cel = __webpack_require__(70);
var global = __webpack_require__(1);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(38)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(122);
var defined = __webpack_require__(29);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(4)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(6);
var createDesc = __webpack_require__(25);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 88 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 89 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(24);
var document = __webpack_require__(8).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(24);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(132);
var enumBugKeys = __webpack_require__(99);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 95 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 96 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(98)('keys');
var uid = __webpack_require__(67);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 99 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(65);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(9);


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var core = __webpack_require__(12);
var LIBRARY = __webpack_require__(68);
var wksExt = __webpack_require__(101);
var defineProperty = __webpack_require__(22).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

SNI.Application.addService('template', function (application) {

  var _loadingHTML = $('[data-ui-loader-clone]:first').html() || '';
  var shareBarHTML = $('[data-sharebar-clone]:first').html() || '';
  var _modalClose = '<a data-dismiss="modal" class="o-Modal__a-Button--Close m-ButtonWrap" data-type="modal-close"><span>Cancel</span></a>';

  return {

    modal: function modal(obj) {
      return '<div class="o-Modal__m-Dialog" id="' + obj.id + '" data-modal-dialog>\n        <div class="o-Modal__m-Content">\n          ' + _modalClose + '\n\n          <div class="o-Modal__m-Header" data-modal-header>\n            <div class="o-Modal__a-Headline" data-modal-headline>' + obj.heading + '</div>\n            ' + (obj.subHeading ? '<div class="o-Modal__a-Description">' + obj.subHeading + '</div>' : '') + '\n          </div>\n\n          <form>\n            <div class="o-Modal__m-Body" data-modal-body>' + obj.body + '</div>\n            <div class="o-Modal__m-Footer" data-modal-footer ' + (!obj.cancelText && !obj.actionText ? 'style="display: none;"' : '') + '>\n              <a href="#" class="o-Modal__a-Button--Primary" data-button-primary>' + obj.actionText + '</a>\n              ' + (obj.cancelText ? '\n                <span>or</span>\n                <a href="#" data-dismiss="' + obj.id + '" class="o-Modal__a-Button--Secondary" data-button-secondary>' + obj.cancelText + '</a>' : '') + '\n            </div>\n          </form>\n        </div>\n      </div>';
    },

    modalClose: function modalClose() {
      return _modalClose;
    },

    modalWrap: function modalWrap(id) {
      return '<div id="' + id + '" class="o-Modal"></div>';
    },

    modalBackdrop: function modalBackdrop(animate) {
      var backdropModifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (backdropModifier === '') {
        return '<div class="o-Modal__m-Backdrop ' + animate + '" data-modal-backdrop />';
      }
      return '<div class="o-Modal__m-Backdrop o-Modal__m-Backdrop--' + backdropModifier + ' ' + animate + '" data-modal-backdrop />';
    },

    socialShare: function socialShare(id) {
      return '<div id="' + id + '" class="o-SocialShare" data-type="share-element">\n                <button type="button" data-type="toggleShare" data-type="toggleShare">Share</button>\n                ' + shareBarHTML + '\n                <div class="m-GigyaShareWrap"></div>\n              </div>';
    },

    socialPinterest: function socialPinterest(data) {
      var href = 'https://www.pinterest.com/pin/create/button/?url=' + data.url + '&media=' + data.media + '&description=' + data.description;
      var img = data.img,
          useNewLogo = data.useNewLogo;


      var newLogo = '<svg class="a-Icon a-Icon--pinterest o-PhotoGalleryPromo__a-Icon o-PhotoGalleryPromo__a-Icon--pinterest rsNoDrag" role="img" data-type="pin-btn">\n                      <use xlink:href="#icon-pinterest"></use>\n                    </svg>';
      var oldLogo = '<img src="' + img + '" class="rsNoDrag" data-type="pin-btn"/>';
      var dataPinRound = data.pinRound ? 'data-pin-round="true"' : '';

      var setPinPosition = function setPinPosition() {
        if (!data.position || data.position.split(' ').length !== 2) data.position = 'top right';

        var pinPosition = ''; // For 'top right' --> "top: 1rem; right: 1rem; bottom: initial; left: initial;"

        ['top', 'bottom', 'left', 'right'].forEach(function (val) {
          data.position.toLowerCase().indexOf(val) !== -1 ? pinPosition += val + ':1rem;' : pinPosition += val + ':initial;';
        });

        return pinPosition;
      };

      return '<div class="a-Pinit rsNoDrag" data-type="pin-element" data-pinit-button style="' + setPinPosition() + '">\n                <a class="rsNoDrag" data-pin-do="buttonPin" data-pin-custom="true" href="' + href + '" data-pin-log="button_pinit"  ' + dataPinRound + '>\n                  ' + (useNewLogo ? newLogo : oldLogo) + '\n                </a>\n              </div>';
    },

    slideCount: function slideCount() {
      return '<div class="rsSlideCount"><span class="rsCurr"></span> / <span class="rsLength"></span></div>';
    },

    overlayBigbox: function overlayBigbox() {
      return '<div id="overlay_bigbox"></div>';
    },

    adText: function adText() {
      return '<p class="ad-text">Advertisement</p>';
    },

    adWrapper: function adWrapper() {
      return '<div class="ad-wrapper"><div class="bigbox-ad"></div></div>';
    },

    adWrapperLite: function adWrapperLite() {
      return '<div class="bigbox-ad"></div>';
    },

    desktopRiverAd: function desktopRiverAd(id, topMargin) {
      return '<div id="dfp_bigbox_' + id + '" class="rr-ad bigbox-ad module text-center" style="margin-top: ' + topMargin + 'px"></div>';
    },

    riverAd: function riverAd(id) {
      return '<div id="mobile_rr_bigbox_' + id + '" class="rr-ad bigbox-ad module text-center"></div>';
    },

    interstitialWrapper: function interstitialWrapper() {
      return '<div id="photo_interstitial_wrapper"></div>';
    },

    interstitialWrapperMobile: function interstitialWrapperMobile() {
      return '<div id="photo_interstitial_wrapper_mobile" class="interstitial"></div>';
    },

    interstitialMobileCloseBtn: function interstitialMobileCloseBtn() {
      return '<div id="photo_interstitial_mobile_close" data-type="close-mobile-interstitial"><i class="icon icon-times"></i></div>';
    },

    nextUpLabel: function nextUpLabel() {
      return '<span class="label label-caution next-label">Next Up</span>';
    },

    targetArea: function targetArea(target) {
      return '<div class="area" data-sni-area=' + target + '></div>';
    },

    productIndicator: function productIndicator(sel) {
      return '<span class="' + sel + ' icon icon-angle-up"></span>';
    },

    collapsibleFooter: function collapsibleFooter(site) {
      return '<div class="back-to-top-desktop smooth-hide">\n        <a href="#" class="collapsible-footer">MORE FROM ' + site + '</a>\n        <a href="#" class="icon icon-angle-up back-to-top-btn">TOP</a>\n      </div>';
    },

    loadingHTML: function loadingHTML() {
      var variant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return variant ? _loadingHTML.replace(/(class\=)(\"|\')/, '$1$2' + variant + ' ') : _loadingHTML;
    },

    shopButton: function shopButton(productId) {
      return '<div class="a-ShopButton rsNoDrag">\n        <button type="button" class="btn btn-primary" data-type="open-shop-overlay-btn" data-product-id="' + productId + '">Shop This Look</button>\n      </div>';
    },

    preloaderHTML: function preloaderHTML() {
      return '<div class="rsPreloader">' + _loadingHTML + '</div>';
    },

    clonedCredit: function clonedCredit() {
      return '<div class="cloned-credit" data-type="launch-credit"></div>';
    },

    launchMeFiller: function launchMeFiller(numSlides) {
      return '<span class="a-CtaTextSecondary">' + numSlides + ' Photos</span>';
    },

    nextGalleryModal: function nextGalleryModal(data) {
      return '\n        <div class="m-NextAsset" data-type="open-next-gallery">\n          <div class="m-NextAsset__a-SubHeadline">' + data.subHeadline + '</div>\n          <h4 class="m-NextAsset__a-Headline">\n            <a href="' + data.link + '" data-next-gallery-link>\n              <span class="m-NextAsset__a-HeadlineText">\n                ' + data.headline + '\n              </span>\n            </a>\n          </h4>\n          ' + (data.voting ? '\n          <div class="m-NextAsset__a-Cta">\n            <a href="#" data-vote-ready-btn>\n              I\'m Ready to Vote.\n            </a>\n          </div>\n          ' : '') + '\n        </div>';
    },

    voteEndframe: function voteEndframe(title, message) {
      return '<div class="voteEndFrame"><div class="message"><p>Now That You\'ve Seen</p><h2>' + title + '</h2><button class="btn btn-primary nextCat">' + message + '</button></div></div>';
    },

    voteResultModalBody: function voteResultModalBody(data) {
      return '\n      <div class="' + (data.mobile ? 'l-Columns l-Columns--1up' : 'l-List') + '">\n        <div class="o-Capsule__m-MediaBlock m-MediaBlock">\n          <div class="m-MediaBlock__m-MediaWrap">\n            <img alt="' + data.title + '" src="' + data.image + '" class="m-MediaBlock__a-Image" />\n          </div>\n          <div class="m-MediaBlock__m-TextWrap">\n            <h6 class="m-MediaBlock__a-Headline">You Chose</h6>\n            <p class="m-MediaBlock__a-Description">' + data.title + '</p>\n            <h6>Share with Friends</h6>\n            <div vote-share-container="true"></div>\n          </div>\n        </div>\n      </div>\n      ';
    },

    launchMeContent: function launchMeContent() {
      return '<div class="o-PhotoGalleryPromo__m-VisualCta" data-type="close-gallery-cta"><div class="m-VisualCtaOuterWrap"><div class="m-VisualCtaTextWrap"><span class="a-CtaTextPrimary">Open Gallery</span></div></div></div>';
    },

    shopItemDesktop: function shopItemDesktop(item) {
      var image_url = item.image_url,
          sale_price = item.sale_price,
          formatted_price = item.formatted_price,
          formatted_sale_price = item.formatted_sale_price,
          product_url = item.product_url,
          name = item.name,
          has_free_shipping = item.has_free_shipping;

      var price = sale_price ? formatted_sale_price : formatted_price;
      return '<div class="m-ProductsList__m-ProductSmall m-ProductSmall" data-product-title="' + name + '">\n                <a class="m-ProductSmall__m-Link" href="' + product_url + '?refid=HGTV12&amp;ss_hgtv_product=1" target="_blank" title="' + name + '" data-type="product-link">\n                    <div class="m-ProductSmall__m-MediaWrap">\n                        <div class="m-ProductSmall__m-ImageWrap"><img data-sizes="auto" src="' + image_url + '"  alt="' + name + '" sizes="70px"></div>\n                    </div>\n                    <div class="m-ProductSmall__m-TextWrap">\n                        <h4 class="m-ProductSmall__a-Headline"><span class="m-ProductSmall__a-HeadlineText">' + name + '</span></h4>\n                        <div class="m-ProductSmall__a-Price">' + price + '</div>\n                        <div class="m-ProductSmall__a-ShippingInfo">' + (has_free_shipping ? 'Free Delivery' : '') + '</div>\n                    </div>\n                </a>\n            </div>';
    },

    shopOverlay: function shopOverlay(isMobile, productId) {
      var closeSelector = 'close-shop-overlay-btn',
          iframeSource = '//wayfair.com/v/inspiration_gallery/hgtv_widget?hgtvPhotoID=' + productId,
          productDimenstions = isMobile ? 'width="300" height="400"' : '',
          productOffsetStart = isMobile ? '' : '<div class="products-offset">',
          productOffsetEnd = isMobile ? '' : '</div>',
          desktopProductsClose = isMobile ? '' : '<button class="btn btn-stroke btn-inverse is-ShopThisLook" data-type="' + closeSelector + '" data-shop-this-look-close>Back to Photo</button>',
          mobileProductsClose = isMobile ? '<a class="o-Modal__a-Button--Close m-ButtonWrap is-ShopThisLook" data-type="' + closeSelector + '" data-shop-this-look-close><span>Cancel</span></a>' : '',
          smallText = isMobile ? '' : '<small>powered by:</small>',
          wayfairHref = '//wayfair.com/?refid=HGTV12';

      return '<div class="shop-overlay overlay modal">\n        <div class="products-header">\n          ' + productOffsetStart + '\n            ' + desktopProductsClose + '\n            <h3 class="products-overlay-heading">Shop This Look</h3>\n            <div class="brand">' + smallText + '<a target="_blank" href="' + wayfairHref + '">Wayfair.com</a></div>\n            ' + mobileProductsClose + '\n          ' + productOffsetEnd + '\n        </div>\n        <div class="products">\n          <div class="products-offset">\n            <iframe src="' + iframeSource + '" ' + productDimenstions + ' allowfullscreen="" frameborder="0" allowtransparency="true"></iframe>\n          </div>\n        </div>\n      </div>';
    },

    shopOverlayMobile: function shopOverlayMobile() {
      return '\n        <div class="shop-overlay overlay o-Modal">\n          <div class="products-header">\n            <h3 class="products-overlay-heading">Shop This Look</h3>\n            <div class="brand"><a target="_blank" href="https://www.wayfair.com">Wayfair.com</a></div>\n            <a class="o-Modal__a-Button--Close m-ButtonWrap"><span>Cancel</span></a>\n          </div>\n          <div class="products">\n            <div class="products-offset">\n              <iframe src="" width="300" height="400" allowfullscreen="" frameborder="0" allowtransparency="true"></iframe>\n            </div>\n          </div>\n        </div>';
    },

    shopOverlayDesktop: function shopOverlayDesktop() {
      return '\n        <div class="shop-overlay overlay o-Modal">\n          <div class="products-header">\n            <div class="products-offset">\n              <button class="btn btn-stroke btn-inverse">Back to Photo</button>\n              <h3 class="products-overlay-heading">Shop This Look</h3>\n              <div class="brand"><small>powered by:</small> <a target="_blank" href="//wayfair.com/?refid=HGTV12">Wayfair.com</a></div>\n            </div>\n          </div>\n          <div class="products">\n            <div class="products-offset">\n              <iframe src="" allowfullscreen="" frameborder="0" allowtransparency="true"></iframe>\n            </div>\n          </div>\n        </div>\n      ';
    },

    hotspotToggle: function hotspotToggle(data) {

      var setHotspotTogglePosition = function setHotspotTogglePosition() {
        if (!data.position || data.position.split(' ').length !== 2) data.position = 'top right';
        var hotspotTogglePosition = ''; // "top: 1rem; right: 1rem; bottom: initial; left: initial;"

        ['top', 'bottom', 'left', 'right'].forEach(function (val) {
          data.position.toLowerCase().indexOf(val) !== -1 ? hotspotTogglePosition += val + ':1rem;' : hotspotTogglePosition += val + ':initial;';
        });

        return hotspotTogglePosition;
      };

      return '<div class="galleryHotspotToggle btn" style="' + setHotspotTogglePosition() + '" data-type="toggle-hotspot"><a href="#">Hide</a><span class="icon icon-circle"> </span></div>';
    },

    hotspotProduct: function hotspotProduct() {
      return '<div class="hotspotProductBackdrop" data-type="close-product-modal"></div>\n              <div class="hotspotProduct" data-type="view-product-modal">\n                <div class="hotspotProductContent">\n                  <div class="hotspotProductOverlayClose">\n                    <a href="#" class="icon icon-times"><span>Close</span></a>\n                  </div>\n                  <div class="hotspotProductImage"><img src=""/></div>\n                  <h2 class="hotspotProductTitle"></h2>\n                  <div class="hotspotProductSponsor"></div>\n                  <div class="hotspotProductDescription"></div>\n                  <div class="hotspotProductMore"><button class="btn btn-primary">More Info</button></div>\n                  <div class="hotspotProductAll"><a href="#">See all products in this gallery</a></div>\n                </div>\n              </div>';
    },

    hotspotProductsAll: function hotspotProductsAll() {
      return '<div class="hotspotProductsAllBackdrop" data-type="close-product-modal-all"></div>\n              <div class="hotspotProductsAll" data-type="view-product-modal-all">\n                <div class="hotspotProductsAllContent">\n                  <div class="hotspotProductsAllTopBar">\n                    <div class="hotspotProductsAllBack"><button class="btn btn-stroke btn-inverse">Back to Photo</button></div>\n                    <div class="hotspotProductOverlayClose">\n                      <a href="#" class="icon icon-times"><span>Close</span></a>\n                    </div>\n                    <h2 class="hotspotProductsAllTitle">Products In This Gallery</h2>\n                  </div>\n                  <div class="hotspotProductsAllProducts">\n                    <div class="block-list-inline block-list-md-col4 block-list-xs-col1 list-pad-space-double list-pad-btm-space-double">\n                      <ul>\n                        <li class="block">\n                          <div class="hotspotProductsAllProduct">\n                            <div class="hotspotProductImage"><img src=""/></div>\n                            <div class="hotspotProductTitleDescription">\n                              <h3 class="hotspotProductTitle"><a href="#">Title</a></h3>\n                              <div class="hotspotProductDescription">Description</div>\n                            </div>\n                          </div>\n                        </li>\n                      </ul>\n                    </div>\n                  </div>\n                </div>\n              </div>';
    },

    tourOverlay: function tourOverlay(data) {
      return '\n        <div class="virtual-tour-wrapper">\n          <div id="virtual-tour-embed-container"></div>\n            <div id="virtual-tour-cta"><p>' + data.roomName + '</p></div>\n          </div>\n          <div class="tour-ad-wrapper">\n            <div class="bigbox-ad"><div id="dfp_overlay_bigbox"></div>\n          </div>\n        </div>';
    },

    productHotSpot: function productHotSpot(data) {
      function checkProductImg() {
        var productImgString;
        if (data.product.sponsor_url && data.product.product_img) {
          productImgString = '<a href="' + data.product.sponsor_url + '" target="_blank">' + '<img src="' + data.product.product_img + '.rend.hgtvcom.266.200.jpeg"/>' + '</a>';
        } else if (data.product.product_img) {
          productImgString = '<img src="' + data.product.product_img + '.rend.hgtvcom.266.200.jpeg"/>';
        } else {
          productImgString = '';
        }

        return productImgString;
      }

      function checkTitle() {
        var titleString;
        if (data.product.title) {
          titleString = '<h4 id="product-title">' + data.product.title.replace(/&amp;quot;/ig, '"') + '</h4>';
        } else {
          titleString = '';
        }
        return titleString;
      }

      function checkLogoImg() {
        var logoString;
        if (data.product.sponsor_url && data.product.logo_img) {
          logoString = '<a href="' + data.product.sponsor_url + '" target="_blank">' + '<img src="' + data.product.logo_img + '"/>' + '</a>';
        } else if (data.product.logo_img) {
          logoString = '<img src="' + data.product.logo_img + '"/>';
        } else {
          logoString = '';
        }
        return logoString;
      }

      function checkDesc() {
        var descString;
        if (data.product.descr) {
          if (checkProductImg() === '' || checkLogoImg() === '') {
            descString = '<h5 id="product-desc" class="no-img">' + data.product.descr.replace(/&amp;quot;/ig, '"') + '</h5>';
          } else {
            descString = '<h5 id="product-desc">' + data.product.descr.replace(/&amp;quot;/ig, '\"') + '</h5>';
          }
        } else {
          descString = '';
        }
        return descString;
      }

      function checkSponsor() {
        var sponsorString;
        if (data.product.sponsor_url) {
          if (checkProductImg() === '') {
            sponsorString = '<a href="' + data.product.sponsor_url + '" target="_blank">' + '<button type="button" class="btn btn-primary no-img more-info">More Info</button>' + '</a>';
          } else {
            sponsorString = '<a href="' + data.product.sponsor_url + '" target="_blank">' + '<button type="button" class="btn btn-primary more-info">More Info</button>' + '</a>';
          }
        } else {
          sponsorString = '';
        }
        return sponsorString;
      }

      return '\n        <div class="product block-text-right">\n          <div class="product-left media">\n            <button type="button" class="btn btn-stroke btn-inverse" id="exit-product-overlay" onclick="SNI.ProductOverlay.overlayRestore()">\n              Back to Tour\n            </button>\n            ' + checkProductImg() + '\n          </div>\n          <div class="product-right text">\n            <h5 id="product-count">Product ' + data.currentProduct + '  of ' + data.totalProducts + '</h5>\n            ' + (checkTitle() + checkLogoImg() + checkDesc() + checkSponsor()) + '\n          </div>\n          <a id="previous-product" onclick="SNI.ProductOverlay.showOverlay(' + data.previous + ', \'' + data.componentUrl + '\')">\n            <span class="icon icon-chevron-left"></span>\n          </a>\n          <a id="next-product" onclick="SNI.ProductOverlay.showOverlay(' + data.next + ', \'' + data.componentUrl + '\')">\n            <span class="icon icon-chevron-right"></span>\n          </a>\n        </div>';
    },

    internationalModalBody: function internationalModalBody(data) {
      var modalBodyHtml = '';
      // There are three parts to the International Modal that aren't already a part of the standard modal:
      //  1. The CTA: e.g. "Go to foodnetwork.co.uk". This is a link that directs the user to their native website.
      //  2. The Dismissal CTA: e.g. "Continue to foodnetwork.com". This link just dismisses the modal, letting the user carry on as they were.
      //  3. The Logo and Banner Image: these are images that appear to help identify the brand. This may vary depending on region,
      //       though with the original creation of this International Modal, FN is the only brand with the modal, and the same logo is used for all regions.
      //        banner images can vary by region, with some regions using the same image.

      modalBodyHtml = '<a class="o-InternationalDialog__a-Button" href=" ' + data.nativeCtaUrl + '"> ' + data.nativeCtaTitle + '</a>\n        <a class="o-InternationalDialog__a-Button--Text" data-dismiss="' + data.dismissModalAttr + '"> ' + data.usCtaLabel + '</a>';

      // We make the logo optional. Arguably, all of the parts of the International Modal would preferably be optional.
      //  But it wasn't certain when writing this whether certain regions would have a logo,
      //  so it was made optional even if none of the regions are without a logo now.
      if (data.logoUrl) {
        modalBodyHtml = modalBodyHtml + ('<img class="o-InternationalDialog__a-Logo" src="//food.fnr.sndimg.com/' + data.logoUrl + '"/>');
      }

      if (data.bannerImageUrl) {
        modalBodyHtml = modalBodyHtml + ('<img class="o-InternationalDialog__a-BannerImage" src="//food.fnr.sndimg.com/' + data.bannerImageUrl + '"/>');
      }

      return modalBodyHtml;
    },

    subHeadline: function subHeadline(data) {
      return '<h6 class="' + data.parentClass + '__a-SubHeadline a-SubHeadline">' + data.text + '</h6>';
    },

    button: function button(data) {
      return '<a href="' + data.url + '" class="' + data.parentClass + '__a-Button a-Button">' + data.text + '</a>';
    }

  };
});

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(10) && !__webpack_require__(5)(function () {
  return Object.defineProperty(__webpack_require__(70)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(28);
var toLength = __webpack_require__(7);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(11);
var toIObject = __webpack_require__(16);
var arrayIndexOf = __webpack_require__(73)(false);
var IE_PROTO = __webpack_require__(74)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(1).document;
module.exports = document && document.documentElement;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(38);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(35);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(19);
var hide = __webpack_require__(13);
var has = __webpack_require__(11);
var Iterators = __webpack_require__(41);
var $iterCreate = __webpack_require__(162);
var setToStringTag = __webpack_require__(40);
var getPrototypeOf = __webpack_require__(50);
var ITERATOR = __webpack_require__(4)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(30);
var toAbsoluteIndex = __webpack_require__(39);
var toLength = __webpack_require__(7);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(6).f;
var create = __webpack_require__(49);
var redefineAll = __webpack_require__(36);
var ctx = __webpack_require__(15);
var anInstance = __webpack_require__(37);
var forOf = __webpack_require__(60);
var $iterDefine = __webpack_require__(111);
var step = __webpack_require__(110);
var setSpecies = __webpack_require__(58);
var DESCRIPTORS = __webpack_require__(10);
var fastKey = __webpack_require__(53).fastKey;
var validate = __webpack_require__(44);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(2);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(42);
var gOPS = __webpack_require__(62);
var pIE = __webpack_require__(52);
var toObject = __webpack_require__(30);
var IObject = __webpack_require__(72);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(5)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(36);
var getWeak = __webpack_require__(53).getWeak;
var anObject = __webpack_require__(2);
var isObject = __webpack_require__(3);
var anInstance = __webpack_require__(37);
var forOf = __webpack_require__(60);
var createArrayMethod = __webpack_require__(51);
var $has = __webpack_require__(11);
var validate = __webpack_require__(44);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 117 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(48);
var gOPS = __webpack_require__(62);
var anObject = __webpack_require__(2);
var Reflect = __webpack_require__(1).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(27);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(4);


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(28);
var defined = __webpack_require__(29);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(3);
var cof = __webpack_require__(38);
var MATCH = __webpack_require__(4)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(3);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 124 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(42);
var toIObject = __webpack_require__(16);
var isEnum = __webpack_require__(52).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(7);
var repeat = __webpack_require__(121);
var defined = __webpack_require__(29);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 127 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

/**
 * Owl carousel
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 */
;(function($, window, document, undefined) {

  var drag, state, e;

  /**
   * Template for status information about drag and touch events.
   * @private
   */
  drag = {
    start: 0,
    startX: 0,
    startY: 0,
    current: 0,
    currentX: 0,
    currentY: 0,
    offsetX: 0,
    offsetY: 0,
    distance: null,
    startTime: 0,
    endTime: 0,
    updatedX: 0,
    targetEl: null
  };

  /**
   * Template for some status informations.
   * @private
   */
  state = {
    isTouch: false,
    isScrolling: false,
    isSwiping: false,
    direction: false,
    inMotion: false
  };

  /**
   * Event functions references.
   * @private
   */
  e = {
    _onDragStart: null,
    _onDragMove: null,
    _onDragEnd: null,
    _transitionEnd: null,
    _resizer: null,
    _responsiveCall: null,
    _goToLoop: null,
    _checkVisibile: null
  };

  /**
   * Creates a carousel.
   * @class The Owl Carousel.
   * @public
   * @param {HTMLElement|jQuery} element - The element to create the carousel for.
   * @param {Object} [options] - The options
   */
  function Owl(element, options) {

    /**
     * Current settings for the carousel.
     * @public
     */
    this.settings = null;

    /**
     * Current options set by the caller including defaults.
     * @public
     */
    this.options = $.extend({}, Owl.Defaults, options);

    /**
     * Plugin element.
     * @public
     */
    this.$element = $(element);

    /**
     * Caches informations about drag and touch events.
     */
    this.drag = $.extend({}, drag);

    /**
     * Caches some status informations.
     * @protected
     */
    this.state = $.extend({}, state);

    /**
     * @protected
     * @todo Must be documented
     */
    this.e = $.extend({}, e);

    /**
     * References to the running plugins of this carousel.
     * @protected
     */
    this._plugins = {};

    /**
     * Currently suppressed events to prevent them from beeing retriggered.
     * @protected
     */
    this._supress = {};

    /**
     * Absolute current position.
     * @protected
     */
    this._current = null;

    /**
     * Animation speed in milliseconds.
     * @protected
     */
    this._speed = null;

    /**
     * Coordinates of all items in pixel.
     * @todo The name of this member is missleading.
     * @protected
     */
    this._coordinates = [];

    /**
     * Current breakpoint.
     * @todo Real media queries would be nice.
     * @protected
     */
    this._breakpoint = null;

    /**
     * Current width of the plugin element.
     */
    this._width = null;

    /**
     * All real items.
     * @protected
     */
    this._items = [];

    /**
     * All cloned items.
     * @protected
     */
    this._clones = [];

    /**
     * Merge values of all items.
     * @todo Maybe this could be part of a plugin.
     * @protected
     */
    this._mergers = [];

    /**
     * Invalidated parts within the update process.
     * @protected
     */
    this._invalidated = {};

    /**
     * Ordered list of workers for the update process.
     * @protected
     */
    this._pipe = [];

    $.each(Owl.Plugins, $.proxy(function(key, plugin) {
      this._plugins[key[0].toLowerCase() + key.slice(1)]
        = new plugin(this);
    }, this));

    $.each(Owl.Pipe, $.proxy(function(priority, worker) {
      this._pipe.push({
        'filter': worker.filter,
        'run': $.proxy(worker.run, this)
      });
    }, this));

    this.setup();
    this.initialize();
  }

  /**
   * Default options for the carousel.
   * @public
   */
  Owl.Defaults = {
    items: 3,
    loop: false,
    center: false,

    mouseDrag: true,
    touchDrag: true,
    pullDrag: true,
    freeDrag: false,

    margin: 0,
    stagePadding: 0,

    merge: false,
    mergeFit: true,
    autoWidth: false,

    startPosition: 0,
    rtl: false,

    smartSpeed: 250,
    fluidSpeed: false,
    dragEndSpeed: false,

    responsive: {},
    responsiveRefreshRate: 200,
    responsiveBaseElement: window,
    responsiveClass: false,

    fallbackEasing: 'swing',

    info: false,

    nestedItemSelector: false,
    itemElement: 'div',
    stageElement: 'div',

    // Classes and Names
    themeClass: 'owl-theme',
    baseClass: 'owl-carousel',
    itemClass: 'owl-item',
    centerClass: 'center',
    activeClass: 'active'
  };

  /**
   * Enumeration for width.
   * @public
   * @readonly
   * @enum {String}
   */
  Owl.Width = {
    Default: 'default',
    Inner: 'inner',
    Outer: 'outer'
  };

  /**
   * Contains all registered plugins.
   * @public
   */
  Owl.Plugins = {};

  /**
   * Update pipe.
   */
  Owl.Pipe = [ {
    filter: [ 'width', 'items', 'settings' ],
    run: function(cache) {
      cache.current = this._items && this._items[this.relative(this._current)];
    }
  }, {
    filter: [ 'items', 'settings' ],
    run: function() {
      var cached = this._clones,
        clones = this.$stage.children('.cloned');

      if (clones.length !== cached.length || (!this.settings.loop && cached.length > 0)) {
        this.$stage.children('.cloned').remove();
        this._clones = [];
      }
    }
  }, {
    filter: [ 'items', 'settings' ],
    run: function() {
      var i, n,
        clones = this._clones,
        items = this._items,
        delta = this.settings.loop ? clones.length - Math.max(this.settings.items * 2, 4) : 0;

      for (i = 0, n = Math.abs(delta / 2); i < n; i++) {
        if (delta > 0) {
          this.$stage.children().eq(items.length + clones.length - 1).remove();
          clones.pop();
          this.$stage.children().eq(0).remove();
          clones.pop();
        } else {
          clones.push(clones.length / 2);
          this.$stage.append(items[clones[clones.length - 1]].clone().addClass('cloned'));
          clones.push(items.length - 1 - (clones.length - 1) / 2);
          this.$stage.prepend(items[clones[clones.length - 1]].clone().addClass('cloned'));
        }
      }
    }
  }, {
    filter: [ 'width', 'items', 'settings' ],
    run: function() {
      var rtl = (this.settings.rtl ? 1 : -1),
        width = (this.width() / this.settings.items).toFixed(3),
        coordinate = 0, merge, i, n;

      this._coordinates = [];
      for (i = 0, n = this._clones.length + this._items.length; i < n; i++) {
        merge = this._mergers[this.relative(i)];
        merge = (this.settings.mergeFit && Math.min(merge, this.settings.items)) || merge;
        coordinate += (this.settings.autoWidth ? this._items[this.relative(i)].width() + this.settings.margin : width * merge) * rtl;

        this._coordinates.push(coordinate);
      }
    }
  }, {
    filter: [ 'width', 'items', 'settings' ],
    run: function() {
      var i, n, width = (this.width() / this.settings.items).toFixed(3), css = {
        'width': Math.abs(this._coordinates[this._coordinates.length - 1]) + this.settings.stagePadding * 2,
        'padding-left': this.settings.stagePadding || '',
        'padding-right': this.settings.stagePadding || ''
      };

      this.$stage.css(css);

      css = { 'width': this.settings.autoWidth ? 'auto' : width - this.settings.margin };
      css[this.settings.rtl ? 'margin-left' : 'margin-right'] = this.settings.margin;

      if (!this.settings.autoWidth && $.grep(this._mergers, function(v) { return v > 1 }).length > 0) {
        for (i = 0, n = this._coordinates.length; i < n; i++) {
          css.width = Math.abs(this._coordinates[i]) - Math.abs(this._coordinates[i - 1] || 0) - this.settings.margin;
          this.$stage.children().eq(i).css(css);
        }
      } else {
        this.$stage.children().css(css);
      }
    }
  }, {
    filter: [ 'width', 'items', 'settings' ],
    run: function(cache) {
      cache.current && this.reset(this.$stage.children().index(cache.current));
    }
  }, {
    filter: [ 'position' ],
    run: function() {
      this.animate(this.coordinates(this._current));
    }
  }, {
    filter: [ 'width', 'position', 'items', 'settings' ],
    run: function() {
      var rtl = this.settings.rtl ? 1 : -1,
        padding = this.settings.stagePadding * 2,
        begin = this.coordinates(this.current()) + padding,
        end = begin + this.width() * rtl,
        inner, outer, matches = [], i, n;

      for (i = 0, n = this._coordinates.length; i < n; i++) {
        inner = this._coordinates[i - 1] || 0;
        outer = Math.abs(this._coordinates[i]) + padding * rtl;

        if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
          || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
          matches.push(i);
        }
      }

      this.$stage.children('.' + this.settings.activeClass).removeClass(this.settings.activeClass);
      this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass(this.settings.activeClass);

      if (this.settings.center) {
        this.$stage.children('.' + this.settings.centerClass).removeClass(this.settings.centerClass);
        this.$stage.children().eq(this.current()).addClass(this.settings.centerClass);
      }
    }
  } ];

  /**
   * Initializes the carousel.
   * @protected
   */
  Owl.prototype.initialize = function() {
    this.trigger('initialize');

    this.$element
      .addClass(this.settings.baseClass)
      .addClass(this.settings.themeClass)
      .toggleClass('owl-rtl', this.settings.rtl);

    // check support
    this.browserSupport();

    if (this.settings.autoWidth && this.state.imagesLoaded !== true) {
      var imgs, nestedSelector, width;
      imgs = this.$element.find('img');
      nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
      width = this.$element.children(nestedSelector).width();

      if (imgs.length && width <= 0) {
        this.preloadAutoWidthImages(imgs);
        return false;
      }
    }

    this.$element.addClass('owl-loading');

    // create stage
    this.$stage = $('<' + this.settings.stageElement + ' class="owl-stage"/>')
      .wrap('<div class="owl-stage-outer">');

    // append stage
    this.$element.append(this.$stage.parent());

    // append content
    this.replace(this.$element.children().not(this.$stage.parent()));

    // set view width
    this._width = this.$element.width();

    // update view
    this.refresh();

    this.$element.removeClass('owl-loading').addClass('owl-loaded');

    // attach generic events
    this.eventsCall();

    // attach generic events
    this.internalEvents();

    // attach custom control events
    this.addTriggerableEvents();

    this.trigger('initialized');
  };

  /**
   * Setups the current settings.
   * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
   * @todo Support for media queries by using `matchMedia` would be nice.
   * @public
   */
  Owl.prototype.setup = function() {
    var viewport = this.viewport(),
      overwrites = this.options.responsive,
      match = -1,
      settings = null;

    if (!overwrites) {
      settings = $.extend({}, this.options);
    } else {
      $.each(overwrites, function(breakpoint) {
        if (breakpoint <= viewport && breakpoint > match) {
          match = Number(breakpoint);
        }
      });

      settings = $.extend({}, this.options, overwrites[match]);
      delete settings.responsive;

      // responsive class
      if (settings.responsiveClass) {
        this.$element.attr('class', function(i, c) {
          return c.replace(/\b owl-responsive-\S+/g, '');
        }).addClass('owl-responsive-' + match);
      }
    }

    if (this.settings === null || this._breakpoint !== match) {
      this.trigger('change', { property: { name: 'settings', value: settings } });
      this._breakpoint = match;
      this.settings = settings;
      this.invalidate('settings');
      this.trigger('changed', { property: { name: 'settings', value: this.settings } });
    }
  };

  /**
   * Updates option logic if necessery.
   * @protected
   */
  Owl.prototype.optionsLogic = function() {
    // Toggle Center class
    this.$element.toggleClass('owl-center', this.settings.center);

    // if items number is less than in body
    if (this.settings.loop && this._items.length < this.settings.items) {
      this.settings.loop = false;
    }

    if (this.settings.autoWidth) {
      this.settings.stagePadding = false;
      this.settings.merge = false;
    }
  };

  /**
   * Prepares an item before add.
   * @todo Rename event parameter `content` to `item`.
   * @protected
   * @returns {jQuery|HTMLElement} - The item container.
   */
  Owl.prototype.prepare = function(item) {
    var event = this.trigger('prepare', { content: item });

    if (!event.data) {
      event.data = $('<' + this.settings.itemElement + '/>')
        .addClass(this.settings.itemClass).append(item)
    }

    this.trigger('prepared', { content: event.data });

    return event.data;
  };

  /**
   * Updates the view.
   * @public
   */
  Owl.prototype.update = function() {
    var i = 0,
      n = this._pipe.length,
      filter = $.proxy(function(p) { return this[p] }, this._invalidated),
      cache = {};

    while (i < n) {
      if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
        this._pipe[i].run(cache);
      }
      i++;
    }

    this._invalidated = {};
  };

  /**
   * Gets the width of the view.
   * @public
   * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
   * @returns {Number} - The width of the view in pixel.
   */
  Owl.prototype.width = function(dimension) {
    dimension = dimension || Owl.Width.Default;
    switch (dimension) {
      case Owl.Width.Inner:
      case Owl.Width.Outer:
        return this._width;
      default:
        return this._width - this.settings.stagePadding * 2 + this.settings.margin;
    }
  };

  /**
   * Refreshes the carousel primarily for adaptive purposes.
   * @public
   */
  Owl.prototype.refresh = function() {
    if (this._items.length === 0) {
      return false;
    }

    var start = new Date().getTime();

    this.trigger('refresh');

    this.setup();

    this.optionsLogic();

    // hide and show methods helps here to set a proper widths,
    // this prevents scrollbar to be calculated in stage width
    this.$stage.addClass('owl-refresh');

    this.update();

    this.$stage.removeClass('owl-refresh');

    this.state.orientation = window.orientation;

    this.watchVisibility();

    this.trigger('refreshed');
  };

  /**
   * Save internal event references and add event based functions.
   * @protected
   */
  Owl.prototype.eventsCall = function() {
    // Save events references
    this.e._onDragStart = $.proxy(function(e) {
      this.onDragStart(e);
    }, this);
    this.e._onDragMove = $.proxy(function(e) {
      this.onDragMove(e);
    }, this);
    this.e._onDragEnd = $.proxy(function(e) {
      this.onDragEnd(e);
    }, this);
    this.e._onResize = $.proxy(function(e) {
      this.onResize(e);
    }, this);
    this.e._transitionEnd = $.proxy(function(e) {
      this.transitionEnd(e);
    }, this);
    this.e._preventClick = $.proxy(function(e) {
      this.preventClick(e);
    }, this);
  };

  /**
   * Checks window `resize` event.
   * @protected
   */
  Owl.prototype.onThrottledResize = function() {
    window.clearTimeout(this.resizeTimer);
    this.resizeTimer = window.setTimeout(this.e._onResize, this.settings.responsiveRefreshRate);
  };

  /**
   * Checks window `resize` event.
   * @protected
   */
  Owl.prototype.onResize = function() {
    if (!this._items.length) {
      return false;
    }

    if (this._width === this.$element.width()) {
      return false;
    }

    if (this.trigger('resize').isDefaultPrevented()) {
      return false;
    }

    this._width = this.$element.width();

    this.invalidate('width');

    this.refresh();

    this.trigger('resized');
  };

  /**
   * Checks for touch/mouse drag event type and add run event handlers.
   * @protected
   */
  Owl.prototype.eventsRouter = function(event) {
    var type = event.type;

    if (type === "mousedown" || type === "touchstart") {
      this.onDragStart(event);
    } else if (type === "mousemove" || type === "touchmove") {
      this.onDragMove(event);
    } else if (type === "mouseup" || type === "touchend") {
      this.onDragEnd(event);
    } else if (type === "touchcancel") {
      this.onDragEnd(event);
    }
  };

  /**
   * Checks for touch/mouse drag options and add necessery event handlers.
   * @protected
   */
  Owl.prototype.internalEvents = function() {
    var isTouch = isTouchSupport(),
      isTouchIE = isTouchSupportIE();

    if (this.settings.mouseDrag){
      this.$stage.on('mousedown', $.proxy(function(event) { this.eventsRouter(event) }, this));
      this.$stage.on('dragstart', function() { return false });
      this.$stage.get(0).onselectstart = function() { return false };
    } else {
      this.$element.addClass('owl-text-select-on');
    }

    if (this.settings.touchDrag && !isTouchIE){
      this.$stage.on('touchstart touchcancel', $.proxy(function(event) { this.eventsRouter(event) }, this));
    }

    // catch transitionEnd event
    if (this.transitionEndVendor) {
      this.on(this.$stage.get(0), this.transitionEndVendor, this.e._transitionEnd, false);
    }

    // responsive
    if (this.settings.responsive !== false) {
      this.on(window, 'resize', $.proxy(this.onThrottledResize, this));
    }
  };

  /**
   * Handles touchstart/mousedown event.
   * @protected
   * @param {Event} event - The event arguments.
   */
  Owl.prototype.onDragStart = function(event) {
    var ev, isTouchEvent, pageX, pageY, animatedPos;

    ev = event.originalEvent || event || window.event;

    // prevent right click
    if (ev.which === 3 || this.state.isTouch) {
      return false;
    }

    if (ev.type === 'mousedown') {
      this.$stage.addClass('owl-grab');
    }

    this.trigger('drag');
    this.drag.startTime = new Date().getTime();
    this.speed(0);
    this.state.isTouch = true;
    this.state.isScrolling = false;
    this.state.isSwiping = false;
    this.drag.distance = 0;

    pageX = getTouches(ev).x;
    pageY = getTouches(ev).y;

    // get stage position left
    this.drag.offsetX = this.$stage.position().left;
    this.drag.offsetY = this.$stage.position().top;

    if (this.settings.rtl) {
      this.drag.offsetX = this.$stage.position().left + this.$stage.width() - this.width()
        + this.settings.margin;
    }

    // catch position // ie to fix
    if (this.state.inMotion && this.support3d) {
      animatedPos = this.getTransformProperty();
      this.drag.offsetX = animatedPos;
      this.animate(animatedPos);
      this.state.inMotion = true;
    } else if (this.state.inMotion && !this.support3d) {
      this.state.inMotion = false;
      return false;
    }

    this.drag.startX = pageX - this.drag.offsetX;
    this.drag.startY = pageY - this.drag.offsetY;

    this.drag.start = pageX - this.drag.startX;
    this.drag.targetEl = ev.target || ev.srcElement;
    this.drag.updatedX = this.drag.start;

    // to do/check
    // prevent links and images dragging;
    if (this.drag.targetEl.tagName === "IMG" || this.drag.targetEl.tagName === "A") {
      this.drag.targetEl.draggable = false;
    }

    $(document).on('mousemove.owl.dragEvents mouseup.owl.dragEvents touchmove.owl.dragEvents touchend.owl.dragEvents', $.proxy(function(event) {this.eventsRouter(event)},this));
  };

  /**
   * Handles the touchmove/mousemove events.
   * @todo Simplify
   * @protected
   * @param {Event} event - The event arguments.
   */
  Owl.prototype.onDragMove = function(event) {
    var ev, isTouchEvent, pageX, pageY, minValue, maxValue, pull;

    if (!this.state.isTouch) {
      return;
    }

    if (this.state.isScrolling) {
      return;
    }

    ev = event.originalEvent || event || window.event;

    pageX = getTouches(ev).x;
    pageY = getTouches(ev).y;

    // Drag Direction
    this.drag.currentX = pageX - this.drag.startX;
    this.drag.currentY = pageY - this.drag.startY;
    this.drag.distance = this.drag.currentX - this.drag.offsetX;

    // Check move direction
    if (this.drag.distance < 0) {
      this.state.direction = this.settings.rtl ? 'right' : 'left';
    } else if (this.drag.distance > 0) {
      this.state.direction = this.settings.rtl ? 'left' : 'right';
    }
    // Loop
    if (this.settings.loop) {
      if (this.op(this.drag.currentX, '>', this.coordinates(this.minimum())) && this.state.direction === 'right') {
        this.drag.currentX -= (this.settings.center && this.coordinates(0)) - this.coordinates(this._items.length);
      } else if (this.op(this.drag.currentX, '<', this.coordinates(this.maximum())) && this.state.direction === 'left') {
        this.drag.currentX += (this.settings.center && this.coordinates(0)) - this.coordinates(this._items.length);
      }
    } else {
      // pull
      minValue = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
      maxValue = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
      pull = this.settings.pullDrag ? this.drag.distance / 5 : 0;
      this.drag.currentX = Math.max(Math.min(this.drag.currentX, minValue + pull), maxValue + pull);
    }

    // Lock browser if swiping horizontal

    if ((this.drag.distance > 8 || this.drag.distance < -8)) {
      if (ev.preventDefault !== undefined) {
        ev.preventDefault();
      } else {
        ev.returnValue = false;
      }
      this.state.isSwiping = true;
    }

    this.drag.updatedX = this.drag.currentX;

    // Lock Owl if scrolling
    if ((this.drag.currentY > 16 || this.drag.currentY < -16) && this.state.isSwiping === false) {
      this.state.isScrolling = true;
      this.drag.updatedX = this.drag.start;
    }

    this.animate(this.drag.updatedX);
  };

  /**
   * Handles the touchend/mouseup events.
   * @protected
   */
  Owl.prototype.onDragEnd = function(event) {
    var compareTimes, distanceAbs, closest;

    if (!this.state.isTouch) {
      return;
    }

    if (event.type === 'mouseup') {
      this.$stage.removeClass('owl-grab');
    }

    this.trigger('dragged');

    // prevent links and images dragging;
    this.drag.targetEl.removeAttribute("draggable");

    // remove drag event listeners

    this.state.isTouch = false;
    this.state.isScrolling = false;
    this.state.isSwiping = false;

    // to check
    if (this.drag.distance === 0 && this.state.inMotion !== true) {
      this.state.inMotion = false;
      return false;
    }

    // prevent clicks while scrolling

    this.drag.endTime = new Date().getTime();
    compareTimes = this.drag.endTime - this.drag.startTime;
    distanceAbs = Math.abs(this.drag.distance);

    // to test
    if (distanceAbs > 3 || compareTimes > 300) {
      this.removeClick(this.drag.targetEl);
    }

    closest = this.closest(this.drag.updatedX);

    this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
    this.current(closest);
    this.invalidate('position');
    this.update();

    // if pullDrag is off then fire transitionEnd event manually when stick
    // to border
    if (!this.settings.pullDrag && this.drag.updatedX === this.coordinates(closest)) {
      this.transitionEnd();
    }

    this.drag.distance = 0;

    $(document).off('.owl.dragEvents');
  };

  /**
   * Attaches `preventClick` to disable link while swipping.
   * @protected
   * @param {HTMLElement} [target] - The target of the `click` event.
   */
  Owl.prototype.removeClick = function(target) {
    this.drag.targetEl = target;
    $(target).on('click.preventClick', this.e._preventClick);
    // to make sure click is removed:
    window.setTimeout(function() {
      $(target).off('click.preventClick');
    }, 300);
  };

  /**
   * Suppresses click event.
   * @protected
   * @param {Event} ev - The event arguments.
   */
  Owl.prototype.preventClick = function(ev) {
    if (ev.preventDefault) {
      ev.preventDefault();
    } else {
      ev.returnValue = false;
    }
    if (ev.stopPropagation) {
      ev.stopPropagation();
    }
    $(ev.target).off('click.preventClick');
  };

  /**
   * Catches stage position while animate (only CSS3).
   * @protected
   * @returns
   */
  Owl.prototype.getTransformProperty = function() {
    var transform, matrix3d;

    transform = window.getComputedStyle(this.$stage.get(0), null).getPropertyValue(this.vendorName + 'transform');
    // var transform = this.$stage.css(this.vendorName + 'transform')
    transform = transform.replace(/matrix(3d)?\(|\)/g, '').split(',');
    matrix3d = transform.length === 16;

    return matrix3d !== true ? transform[4] : transform[12];
  };

  /**
   * Gets absolute position of the closest item for a coordinate.
   * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
   * @protected
   * @param {Number} coordinate - The coordinate in pixel.
   * @return {Number} - The absolute position of the closest item.
   */
  Owl.prototype.closest = function(coordinate) {
    var position = -1, pull = 30, width = this.width(), coordinates = this.coordinates();

    if (!this.settings.freeDrag) {
      // check closest item
      $.each(coordinates, $.proxy(function(index, value) {
        if (coordinate > value - pull && coordinate < value + pull) {
          position = index;
        } else if (this.op(coordinate, '<', value)
          && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {
          position = this.state.direction === 'left' ? index + 1 : index;
        }
        return position === -1;
      }, this));
    }

    if (!this.settings.loop) {
      // non loop boundries
      if (this.op(coordinate, '>', coordinates[this.minimum()])) {
        position = coordinate = this.minimum();
      } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
        position = coordinate = this.maximum();
      }
    }

    return position;
  };

  /**
   * Animates the stage.
   * @public
   * @param {Number} coordinate - The coordinate in pixels.
   */
  Owl.prototype.animate = function(coordinate) {
    this.trigger('translate');
    this.state.inMotion = this.speed() > 0;

    if (this.support3d) {
      this.$stage.css({
        transform: 'translate3d(' + coordinate + 'px' + ',0px, 0px)',
        transition: (this.speed() / 1000) + 's'
      });
    } else if (this.state.isTouch) {
      this.$stage.css({
        left: coordinate + 'px'
      });
    } else {
      this.$stage.animate({
        left: coordinate
      }, this.speed() / 1000, this.settings.fallbackEasing, $.proxy(function() {
        if (this.state.inMotion) {
          this.transitionEnd();
        }
      }, this));
    }
  };

  /**
   * Sets the absolute position of the current item.
   * @public
   * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
   * @returns {Number} - The absolute position of the current item.
   */
  Owl.prototype.current = function(position) {
    if (position === undefined) {
      return this._current;
    }

    if (this._items.length === 0) {
      return undefined;
    }

    position = this.normalize(position);

    if (this._current !== position) {
      var event = this.trigger('change', { property: { name: 'position', value: position } });

      if (event.data !== undefined) {
        position = this.normalize(event.data);
      }

      this._current = position;

      this.invalidate('position');

      this.trigger('changed', { property: { name: 'position', value: this._current } });
    }

    return this._current;
  };

  /**
   * Invalidates the given part of the update routine.
   * @param {String} part - The part to invalidate.
   */
  Owl.prototype.invalidate = function(part) {
    this._invalidated[part] = true;
  }

  /**
   * Resets the absolute position of the current item.
   * @public
   * @param {Number} position - The absolute position of the new item.
   */
  Owl.prototype.reset = function(position) {
    position = this.normalize(position);

    if (position === undefined) {
      return;
    }

    this._speed = 0;
    this._current = position;

    this.suppress([ 'translate', 'translated' ]);

    this.animate(this.coordinates(position));

    this.release([ 'translate', 'translated' ]);
  };

  /**
   * Normalizes an absolute or a relative position for an item.
   * @public
   * @param {Number} position - The absolute or relative position to normalize.
   * @param {Boolean} [relative=false] - Whether the given position is relative or not.
   * @returns {Number} - The normalized position.
   */
  Owl.prototype.normalize = function(position, relative) {
    var n = (relative ? this._items.length : this._items.length + this._clones.length);

    if (!$.isNumeric(position) || n < 1) {
      return undefined;
    }

    if (this._clones.length) {
      position = ((position % n) + n) % n;
    } else {
      position = Math.max(this.minimum(relative), Math.min(this.maximum(relative), position));
    }

    return position;
  };

  /**
   * Converts an absolute position for an item into a relative position.
   * @public
   * @param {Number} position - The absolute position to convert.
   * @returns {Number} - The converted position.
   */
  Owl.prototype.relative = function(position) {
    position = this.normalize(position);
    position = position - this._clones.length / 2;
    return this.normalize(position, true);
  };

  /**
   * Gets the maximum position for an item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */
  Owl.prototype.maximum = function(relative) {
    var maximum, width, i = 0, coordinate,
      settings = this.settings;

    if (relative) {
      return this._items.length - 1;
    }

    if (!settings.loop && settings.center) {
      maximum = this._items.length - 1;
    } else if (!settings.loop && !settings.center) {
      maximum = this._items.length - settings.items;
    } else if (settings.loop || settings.center) {
      maximum = this._items.length + settings.items;
    } else if (settings.autoWidth || settings.merge) {
      revert = settings.rtl ? 1 : -1;
      width = this.$stage.width() - this.$element.width();
      while (coordinate = this.coordinates(i)) {
        if (coordinate * revert >= width) {
          break;
        }
        maximum = ++i;
      }
    } else {
      throw 'Can not detect maximum absolute position.'
    }

    return maximum;
  };

  /**
   * Gets the minimum position for an item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */
  Owl.prototype.minimum = function(relative) {
    if (relative) {
      return 0;
    }

    return this._clones.length / 2;
  };

  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */
  Owl.prototype.items = function(position) {
    if (position === undefined) {
      return this._items.slice();
    }

    position = this.normalize(position, true);
    return this._items[position];
  };

  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */
  Owl.prototype.mergers = function(position) {
    if (position === undefined) {
      return this._mergers.slice();
    }

    position = this.normalize(position, true);
    return this._mergers[position];
  };

  /**
   * Gets the absolute positions of clones for an item.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
   */
  Owl.prototype.clones = function(position) {
    var odd = this._clones.length / 2,
      even = odd + this._items.length,
      map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

    if (position === undefined) {
      return $.map(this._clones, function(v, i) { return map(i) });
    }

    return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
  };

  /**
   * Sets the current animation speed.
   * @public
   * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
   * @returns {Number} - The current animation speed in milliseconds.
   */
  Owl.prototype.speed = function(speed) {
    if (speed !== undefined) {
      this._speed = speed;
    }

    return this._speed;
  };

  /**
   * Gets the coordinate of an item.
   * @todo The name of this method is missleanding.
   * @public
   * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
   * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
   */
  Owl.prototype.coordinates = function(position) {
    var coordinate = null;

    if (position === undefined) {
      return $.map(this._coordinates, $.proxy(function(coordinate, index) {
        return this.coordinates(index);
      }, this));
    }

    if (this.settings.center) {
      coordinate = this._coordinates[position];
      coordinate += (this.width() - coordinate + (this._coordinates[position - 1] || 0)) / 2 * (this.settings.rtl ? -1 : 1);
    } else {
      coordinate = this._coordinates[position - 1] || 0;
    }

    return coordinate;
  };

  /**
   * Calculates the speed for a translation.
   * @protected
   * @param {Number} from - The absolute position of the start item.
   * @param {Number} to - The absolute position of the target item.
   * @param {Number} [factor=undefined] - The time factor in milliseconds.
   * @returns {Number} - The time in milliseconds for the translation.
   */
  Owl.prototype.duration = function(from, to, factor) {
    return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
  };

  /**
   * Slides to the specified item.
   * @public
   * @param {Number} position - The position of the item.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */
  Owl.prototype.to = function(position, speed) {
    if (this.settings.loop) {
      var distance = position - this.relative(this.current()),
        revert = this.current(),
        before = this.current(),
        after = this.current() + distance,
        direction = before - after < 0 ? true : false,
        items = this._clones.length + this._items.length;

      if (after < this.settings.items && direction === false) {
        revert = before + this._items.length;
        this.reset(revert);
      } else if (after >= items - this.settings.items && direction === true) {
        revert = before - this._items.length;
        this.reset(revert);
      }
      window.clearTimeout(this.e._goToLoop);
      this.e._goToLoop = window.setTimeout($.proxy(function() {
        this.speed(this.duration(this.current(), revert + distance, speed));
        this.current(revert + distance);
        this.update();
      }, this), 30);
    } else {
      this.speed(this.duration(this.current(), position, speed));
      this.current(position);
      this.update();
    }
  };

  /**
   * Slides to the next item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */
  Owl.prototype.next = function(speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) + 1, speed);
  };

  /**
   * Slides to the previous item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */
  Owl.prototype.prev = function(speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) - 1, speed);
  };

  /**
   * Handles the end of an animation.
   * @protected
   * @param {Event} event - The event arguments.
   */
  Owl.prototype.transitionEnd = function(event) {

    // if css2 animation then event object is undefined
    if (event !== undefined) {
      event.stopPropagation();

      // Catch only owl-stage transitionEnd event
      if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
        return false;
      }
    }

    this.state.inMotion = false;
    this.trigger('translated');
  };

  /**
   * Gets viewport width.
   * @protected
   * @return {Number} - The width in pixel.
   */
  Owl.prototype.viewport = function() {
    var width;
    if (this.options.responsiveBaseElement !== window) {
      width = $(this.options.responsiveBaseElement).width();
    } else if (window.innerWidth) {
      width = window.innerWidth;
    } else if (document.documentElement && document.documentElement.clientWidth) {
      width = document.documentElement.clientWidth;
    } else {
      throw 'Can not detect viewport width.';
    }
    return width;
  };

  /**
   * Replaces the current content.
   * @public
   * @param {HTMLElement|jQuery|String} content - The new content.
   */
  Owl.prototype.replace = function(content) {
    this.$stage.empty();
    this._items = [];

    if (content) {
      content = (content instanceof jQuery) ? content : $(content);
    }

    if (this.settings.nestedItemSelector) {
      content = content.find('.' + this.settings.nestedItemSelector);
    }

    content.filter(function() {
      return this.nodeType === 1;
    }).each($.proxy(function(index, item) {
      item = this.prepare(item);
      this.$stage.append(item);
      this._items.push(item);
      this._mergers.push(item.find('[data-merge]').andSelf('[data-merge]').attr('data-merge') * 1 || 1);
    }, this));

    this.reset($.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

    this.invalidate('items');
  };

  /**
   * Adds an item.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {HTMLElement|jQuery|String} content - The item content to add.
   * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
   */
  Owl.prototype.add = function(content, position) {
    position = position === undefined ? this._items.length : this.normalize(position, true);

    this.trigger('add', { content: content, position: position });

    if (this._items.length === 0 || position === this._items.length) {
      this.$stage.append(content);
      this._items.push(content);
      this._mergers.push(content.find('[data-merge]').andSelf('[data-merge]').attr('data-merge') * 1 || 1);
    } else {
      this._items[position].before(content);
      this._items.splice(position, 0, content);
      this._mergers.splice(position, 0, content.find('[data-merge]').andSelf('[data-merge]').attr('data-merge') * 1 || 1);
    }

    this.invalidate('items');

    this.trigger('added', { content: content, position: position });
  };

  /**
   * Removes an item by its position.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {Number} position - The relative position of the item to remove.
   */
  Owl.prototype.remove = function(position) {
    position = this.normalize(position, true);

    if (position === undefined) {
      return;
    }

    this.trigger('remove', { content: this._items[position], position: position });

    this._items[position].remove();
    this._items.splice(position, 1);
    this._mergers.splice(position, 1);

    this.invalidate('items');

    this.trigger('removed', { content: null, position: position });
  };

  /**
   * Adds triggerable events.
   * @protected
   */
  Owl.prototype.addTriggerableEvents = function() {
    var handler = $.proxy(function(callback, event) {
      return $.proxy(function(e) {
        if (e.relatedTarget !== this) {
          this.suppress([ event ]);
          callback.apply(this, [].slice.call(arguments, 1));
          this.release([ event ]);
        }
      }, this);
    }, this);

    $.each({
      'next': this.next,
      'prev': this.prev,
      'to': this.to,
      'destroy': this.destroy,
      'refresh': this.refresh,
      'replace': this.replace,
      'add': this.add,
      'remove': this.remove
    }, $.proxy(function(event, callback) {
      this.$element.on(event + '.owl.carousel', handler(callback, event + '.owl.carousel'));
    }, this));

  };

  /**
   * Watches the visibility of the carousel element.
   * @protected
   */
  Owl.prototype.watchVisibility = function() {

    // test on zepto
    if (!isElVisible(this.$element.get(0))) {
      this.$element.addClass('owl-hidden');
      window.clearInterval(this.e._checkVisibile);
      this.e._checkVisibile = window.setInterval($.proxy(checkVisible, this), 500);
    }

    function isElVisible(el) {
      return el.offsetWidth > 0 && el.offsetHeight > 0;
    }

    function checkVisible() {
      if (isElVisible(this.$element.get(0))) {
        this.$element.removeClass('owl-hidden');
        this.refresh();
        window.clearInterval(this.e._checkVisibile);
      }
    }
  };

  /**
   * Preloads images with auto width.
   * @protected
   * @todo Still to test
   */
  Owl.prototype.preloadAutoWidthImages = function(imgs) {
    var loaded, that, $el, img;

    loaded = 0;
    that = this;
    imgs.each(function(i, el) {
      $el = $(el);
      img = new Image();

      img.onload = function() {
        loaded++;
        $el.attr('src', img.src);
        $el.css('opacity', 1);
        if (loaded >= imgs.length) {
          that.state.imagesLoaded = true;
          that.initialize();
        }
      };

      img.src = $el.attr('src') || $el.attr('data-src') || $el.attr('data-src-retina');
    });
  };

  /**
   * Destroys the carousel.
   * @public
   */
  Owl.prototype.destroy = function() {

    if (this.$element.hasClass(this.settings.themeClass)) {
      this.$element.removeClass(this.settings.themeClass);
    }

    if (this.settings.responsive !== false) {
      $(window).off('resize.owl.carousel');
    }

    if (this.transitionEndVendor) {
      this.off(this.$stage.get(0), this.transitionEndVendor, this.e._transitionEnd);
    }

    for ( var i in this._plugins) {
      this._plugins[i].destroy();
    }

    if (this.settings.mouseDrag || this.settings.touchDrag) {
      this.$stage.off('mousedown touchstart touchcancel');
      $(document).off('.owl.dragEvents');
      this.$stage.get(0).onselectstart = function() {};
      this.$stage.off('dragstart', function() { return false });
    }

    // remove event handlers in the ".owl.carousel" namespace
    this.$element.off('.owl');

    this.$stage.children('.cloned').remove();
    this.e = null;
    this.$element.removeData('owlCarousel');

    this.$stage.children().contents().unwrap();
    this.$stage.children().unwrap();
    this.$stage.unwrap();
  };

  /**
   * Operators to calculate right-to-left and left-to-right.
   * @protected
   * @param {Number} [a] - The left side operand.
   * @param {String} [o] - The operator.
   * @param {Number} [b] - The right side operand.
   */
  Owl.prototype.op = function(a, o, b) {
    var rtl = this.settings.rtl;
    switch (o) {
      case '<':
        return rtl ? a > b : a < b;
      case '>':
        return rtl ? a < b : a > b;
      case '>=':
        return rtl ? a <= b : a >= b;
      case '<=':
        return rtl ? a >= b : a <= b;
      default:
        break;
    }
  };

  /**
   * Attaches to an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The event handler to attach.
   * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
   */
  Owl.prototype.on = function(element, event, listener, capture) {
    if (element.addEventListener) {
      element.addEventListener(event, listener, capture);
    } else if (element.attachEvent) {
      element.attachEvent('on' + event, listener);
    }
  };

  /**
   * Detaches from an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The attached event handler to detach.
   * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
   */
  Owl.prototype.off = function(element, event, listener, capture) {
    if (element.removeEventListener) {
      element.removeEventListener(event, listener, capture);
    } else if (element.detachEvent) {
      element.detachEvent('on' + event, listener);
    }
  };

  /**
   * Triggers an public event.
   * @protected
   * @param {String} name - The event name.
   * @param {*} [data=null] - The event data.
   * @param {String} [namespace=.owl.carousel] - The event namespace.
   * @returns {Event} - The event arguments.
   */
  Owl.prototype.trigger = function(name, data, namespace) {
    var status = {
      item: { count: this._items.length, index: this.current() }
    }, handler = $.camelCase(
      $.grep([ 'on', name, namespace ], function(v) { return v })
        .join('-').toLowerCase()
    ), event = $.Event(
      [ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
      $.extend({ relatedTarget: this }, status, data)
    );

    if (!this._supress[name]) {
      $.each(this._plugins, function(name, plugin) {
        if (plugin.onTrigger) {
          plugin.onTrigger(event);
        }
      });

      this.$element.trigger(event);

      if (this.settings && typeof this.settings[handler] === 'function') {
        this.settings[handler].apply(this, event);
      }
    }

    return event;
  };

  /**
   * Suppresses events.
   * @protected
   * @param {Array.<String>} events - The events to suppress.
   */
  Owl.prototype.suppress = function(events) {
    $.each(events, $.proxy(function(index, event) {
      this._supress[event] = true;
    }, this));
  }

  /**
   * Releases suppressed events.
   * @protected
   * @param {Array.<String>} events - The events to release.
   */
  Owl.prototype.release = function(events) {
    $.each(events, $.proxy(function(index, event) {
      delete this._supress[event];
    }, this));
  }

  /**
   * Checks the availability of some browser features.
   * @protected
   */
  Owl.prototype.browserSupport = function() {
    this.support3d = isPerspective();

    if (this.support3d) {
      this.transformVendor = isTransform();

      // take transitionend event name by detecting transition
      var endVendors = [ 'transitionend', 'webkitTransitionEnd', 'transitionend', 'oTransitionEnd' ];
      this.transitionEndVendor = endVendors[isTransition()];

      // take vendor name from transform name
      this.vendorName = this.transformVendor.replace(/Transform/i, '');
      this.vendorName = this.vendorName !== '' ? '-' + this.vendorName.toLowerCase() + '-' : '';
    }

    this.state.orientation = window.orientation;
  };

  /**
   * Get touch/drag coordinats.
   * @private
   * @param {event} - mousedown/touchstart event
   * @returns {object} - Contains X and Y of current mouse/touch position
   */

  function getTouches(event) {
    if (event.touches !== undefined) {
      return {
        x: event.touches[0].pageX,
        y: event.touches[0].pageY
      };
    }

    if (event.touches === undefined) {
      if (event.pageX !== undefined) {
        return {
          x: event.pageX,
          y: event.pageY
        };
      }

    if (event.pageX === undefined) {
      return {
          x: event.clientX,
          y: event.clientY
        };
      }
    }
  }

  /**
   * Checks for CSS support.
   * @private
   * @param {Array} array - The CSS properties to check for.
   * @returns {Array} - Contains the supported CSS property name and its index or `false`.
   */
  function isStyleSupported(array) {
    var p, s, fake = document.createElement('div'), list = array;
    for (p in list) {
      s = list[p];
      if (typeof fake.style[s] !== 'undefined') {
        fake = null;
        return [ s, p ];
      }
    }
    return [ false ];
  }

  /**
   * Checks for CSS transition support.
   * @private
   * @todo Realy bad design
   * @returns {Number}
   */
  function isTransition() {
    return isStyleSupported([ 'transition', 'WebkitTransition', 'MozTransition', 'OTransition' ])[1];
  }

  /**
   * Checks for CSS transform support.
   * @private
   * @returns {String} The supported property name or false.
   */
  function isTransform() {
    return isStyleSupported([ 'transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform' ])[0];
  }

  /**
   * Checks for CSS perspective support.
   * @private
   * @returns {String} The supported property name or false.
   */
  function isPerspective() {
    return isStyleSupported([ 'perspective', 'webkitPerspective', 'MozPerspective', 'OPerspective', 'MsPerspective' ])[0];
  }

  /**
   * Checks wether touch is supported or not.
   * @private
   * @returns {Boolean}
   */
  function isTouchSupport() {
    return 'ontouchstart' in window || !!(navigator.msMaxTouchPoints);
  }

  /**
   * Checks wether touch is supported or not for IE.
   * @private
   * @returns {Boolean}
   */
  function isTouchSupportIE() {
    return window.navigator.msPointerEnabled;
  }

  /**
   * The jQuery Plugin for the Owl Carousel
   * @public
   */
  $.fn.owlCarousel = function(options) {
    return this.each(function() {
      if (!$(this).data('owlCarousel')) {
        $(this).data('owlCarousel', new Owl(this, options));
      }
    });
  };

  /**
   * The constructor for the jQuery Plugin
   * @public
   */
  $.fn.owlCarousel.Constructor = Owl;

})(window.Zepto || window.jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

  /**
   * Creates the lazy plugin.
   * @class The Lazy Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Lazy = function(carousel) {

    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;

    /**
     * Already loaded items.
     * @protected
     * @type {Array.<jQuery>}
     */
    this._loaded = [];

    /**
     * Event handlers.
     * @protected
     * @type {Object}
     */
    this._handlers = {
      'initialized.owl.carousel change.owl.carousel': $.proxy(function(e) {
        if (!e.namespace) {
          return;
        }

        if (!this._core.settings || !this._core.settings.lazyLoad) {
          return;
        }

        if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
          var settings = this._core.settings,
            n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
            i = ((settings.center && n * -1) || 0),
            position = ((e.property && e.property.value) || this._core.current()) + i,
            clones = this._core.clones().length,
            load = $.proxy(function(i, v) { this.load(v) }, this);

          while (i++ < n) {
            this.load(clones / 2 + this._core.relative(position));
            clones && $.each(this._core.clones(this._core.relative(position++)), load);
          }
        }
      }, this)
    };

    // set the default options
    this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

    // register event handler
    this._core.$element.on(this._handlers);
  }

  /**
   * Default options.
   * @public
   */
  Lazy.Defaults = {
    lazyLoad: false
  }

  /**
   * Loads all resources of an item at the specified position.
   * @param {Number} position - The absolute position of the item.
   * @protected
   */
  Lazy.prototype.load = function(position) {
    var $item = this._core.$stage.children().eq(position),
      $elements = $item && $item.find('.owl-lazy');

    if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
      return;
    }

    $elements.each($.proxy(function(index, element) {
      var $element = $(element), image,
        url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');

      this._core.trigger('load', { element: $element, url: url }, 'lazy');

      if ($element.is('img')) {
        $element.one('load.owl.lazy', $.proxy(function() {
          $element.css('opacity', 1);
          this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
        }, this)).attr('src', url);
      } else {
        image = new Image();
        image.onload = $.proxy(function() {
          $element.css({
            'background-image': 'url(' + url + ')',
            'opacity': '1'
          });
          this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
        }, this);
        image.src = url;
      }
    }, this));

    this._loaded.push($item.get(0));
  }

  /**
   * Destroys the plugin.
   * @public
   */
  Lazy.prototype.destroy = function() {
    var handler, property;

    for (handler in this.handlers) {
      this._core.$element.off(handler, this.handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  }

  $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

  /**
   * Creates the auto height plugin.
   * @class The Auto Height Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var AutoHeight = function(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;

    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */
    this._handlers = {
      'initialized.owl.carousel': $.proxy(function() {
        if (this._core.settings.autoHeight) {
          this.update();
        }
      }, this),
      'changed.owl.carousel': $.proxy(function(e) {
        if (this._core.settings.autoHeight && e.property.name == 'position'){
          this.update();
        }
      }, this),
      'loaded.owl.lazy': $.proxy(function(e) {
        if (this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass)
          === this._core.$stage.children().eq(this._core.current())) {
          this.update();
        }
      }, this)
    };

    // set default options
    this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

    // register event handlers
    this._core.$element.on(this._handlers);
  };

  /**
   * Default options.
   * @public
   */
  AutoHeight.Defaults = {
    autoHeight: false,
    autoHeightClass: 'owl-height'
  };

  /**
   * Updates the view.
   */
  AutoHeight.prototype.update = function() {
    this._core.$stage.parent()
      .height(this._core.$stage.children().eq(this._core.current()).height())
      .addClass(this._core.settings.autoHeightClass);
  };

  AutoHeight.prototype.destroy = function() {
    var handler, property;

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

})(window.Zepto || window.jQuery, window, document);

/**
 * Video Plugin
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

  /**
   * Creates the video plugin.
   * @class The Video Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Video = function(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;

    /**
     * Cache all video URLs.
     * @protected
     * @type {Object}
     */
    this._videos = {};

    /**
     * Current playing item.
     * @protected
     * @type {jQuery}
     */
    this._playing = null;

    /**
     * Whether this is in fullscreen or not.
     * @protected
     * @type {Boolean}
     */
    this._fullscreen = false;

    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */
    this._handlers = {
      'resize.owl.carousel': $.proxy(function(e) {
        if (this._core.settings.video && !this.isInFullScreen()) {
          e.preventDefault();
        }
      }, this),
      'refresh.owl.carousel changed.owl.carousel': $.proxy(function(e) {
        if (this._playing) {
          this.stop();
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function(e) {
        var $element = $(e.content).find('.owl-video');
        if ($element.length) {
          $element.css('display', 'none');
          this.fetch($element, $(e.content));
        }
      }, this)
    };

    // set default options
    this._core.options = $.extend({}, Video.Defaults, this._core.options);

    // register event handlers
    this._core.$element.on(this._handlers);

    this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
      this.play(e);
    }, this));
  };

  /**
   * Default options.
   * @public
   */
  Video.Defaults = {
    video: false,
    videoHeight: false,
    videoWidth: false
  };

  /**
   * Gets the video ID and the type (YouTube/Vimeo only).
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {jQuery} item - The item containing the video.
   */
  Video.prototype.fetch = function(target, item) {

    var type = target.attr('data-vimeo-id') ? 'vimeo' : 'youtube',
      id = target.attr('data-vimeo-id') || target.attr('data-youtube-id'),
      width = target.attr('data-width') || this._core.settings.videoWidth,
      height = target.attr('data-height') || this._core.settings.videoHeight,
      url = target.attr('href');

    if (url) {
      id = url.match(/(http:|https:|)\/\/(player.|www.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com))\/(video\/|embed\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

      if (id[3].indexOf('youtu') > -1) {
        type = 'youtube';
      } else if (id[3].indexOf('vimeo') > -1) {
        type = 'vimeo';
      } else {
        throw new Error('Video URL not supported.');
      }
      id = id[6];
    } else {
      throw new Error('Missing video URL.');
    }

    this._videos[url] = {
      type: type,
      id: id,
      width: width,
      height: height
    };

    item.attr('data-video', url);

    this.thumbnail(target, this._videos[url]);
  };

  /**
   * Creates video thumbnail.
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {Object} info - The video info object.
   * @see `fetch`
   */
  Video.prototype.thumbnail = function(target, video) {

    var tnLink,
      icon,
      path,
      dimensions = video.width && video.height ? 'style="width:' + video.width + 'px;height:' + video.height + 'px;"' : '',
      customTn = target.find('img'),
      srcType = 'src',
      lazyClass = '',
      settings = this._core.settings,
      create = function(path) {
        icon = '<div class="owl-video-play-icon"></div>';

        if (settings.lazyLoad) {
          tnLink = '<div class="owl-video-tn ' + lazyClass + '" ' + srcType + '="' + path + '"></div>';
        } else {
          tnLink = '<div class="owl-video-tn" style="opacity:1;background-image:url(' + path + ')"></div>';
        }
        target.after(tnLink);
        target.after(icon);
      };

    // wrap video content into owl-video-wrapper div
    target.wrap('<div class="owl-video-wrapper"' + dimensions + '></div>');

    if (this._core.settings.lazyLoad) {
      srcType = 'data-src';
      lazyClass = 'owl-lazy';
    }

    // custom thumbnail
    if (customTn.length) {
      create(customTn.attr(srcType));
      customTn.remove();
      return false;
    }

    if (video.type === 'youtube') {
      path = "http://img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
      create(path);
    } else if (video.type === 'vimeo') {
      $.ajax({
        type: 'GET',
        url: 'http://vimeo.com/api/v2/video/' + video.id + '.json',
        jsonp: 'callback',
        dataType: 'jsonp',
        success: function(data) {
          path = data[0].thumbnail_large;
          create(path);
        }
      });
    }
  };

  /**
   * Stops the current video.
   * @public
   */
  Video.prototype.stop = function() {
    this._core.trigger('stop', null, 'video');
    this._playing.find('.owl-video-frame').remove();
    this._playing.removeClass('owl-video-playing');
    this._playing = null;
  };

  /**
   * Starts the current video.
   * @public
   * @param {Event} ev - The event arguments.
   */
  Video.prototype.play = function(ev) {
    this._core.trigger('play', null, 'video');

    if (this._playing) {
      this.stop();
    }

    var target = $(ev.target || ev.srcElement),
      item = target.closest('.' + this._core.settings.itemClass),
      video = this._videos[item.attr('data-video')],
      width = video.width || '100%',
      height = video.height || this._core.$stage.height(),
      html, wrap;

    if (video.type === 'youtube') {
      html = '<iframe width="' + width + '" height="' + height + '" src="http://www.youtube.com/embed/'
        + video.id + '?autoplay=1&v=' + video.id + '" frameborder="0" allowfullscreen></iframe>';
    } else if (video.type === 'vimeo') {
      html = '<iframe src="http://player.vimeo.com/video/' + video.id + '?autoplay=1" width="' + width
        + '" height="' + height
        + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
    }

    item.addClass('owl-video-playing');
    this._playing = item;

    wrap = $('<div style="height:' + height + 'px; width:' + width + 'px" class="owl-video-frame">'
      + html + '</div>');
    target.after(wrap);
  };

  /**
   * Checks whether an video is currently in full screen mode or not.
   * @todo Bad style because looks like a readonly method but changes members.
   * @protected
   * @returns {Boolean}
   */
  Video.prototype.isInFullScreen = function() {

    // if Vimeo Fullscreen mode
    var element = document.fullscreenElement || document.mozFullScreenElement
      || document.webkitFullscreenElement;

    if (element && $(element).parent().hasClass('owl-video-frame')) {
      this._core.speed(0);
      this._fullscreen = true;
    }

    if (element && this._fullscreen && this._playing) {
      return false;
    }

    // comming back from fullscreen
    if (this._fullscreen) {
      this._fullscreen = false;
      return false;
    }

    // check full screen mode and window orientation
    if (this._playing) {
      if (this._core.state.orientation !== window.orientation) {
        this._core.state.orientation = window.orientation;
        return false;
      }
    }

    return true;
  };

  /**
   * Destroys the plugin.
   */
  Video.prototype.destroy = function() {
    var handler, property;

    this._core.$element.off('click.owl.video');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Video = Video;

})(window.Zepto || window.jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

  /**
   * Creates the animate plugin.
   * @class The Navigation Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Animate = function(scope) {
    this.core = scope;
    this.core.options = $.extend({}, Animate.Defaults, this.core.options);
    this.swapping = true;
    this.previous = undefined;
    this.next = undefined;

    this.handlers = {
      'change.owl.carousel': $.proxy(function(e) {
        if (e.property.name == 'position') {
          this.previous = this.core.current();
          this.next = e.property.value;
        }
      }, this),
      'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
        this.swapping = e.type == 'translated';
      }, this),
      'translate.owl.carousel': $.proxy(function(e) {
        if (this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
          this.swap();
        }
      }, this)
    };

    this.core.$element.on(this.handlers);
  };

  /**
   * Default options.
   * @public
   */
  Animate.Defaults = {
    animateOut: false,
    animateIn: false
  };

  /**
   * Toggles the animation classes whenever an translations starts.
   * @protected
   * @returns {Boolean|undefined}
   */
  Animate.prototype.swap = function() {

    if (this.core.settings.items !== 1 || !this.core.support3d) {
      return;
    }

    this.core.speed(0);

    var left,
      clear = $.proxy(this.clear, this),
      previous = this.core.$stage.children().eq(this.previous),
      next = this.core.$stage.children().eq(this.next),
      incoming = this.core.settings.animateIn,
      outgoing = this.core.settings.animateOut;

    if (this.core.current() === this.previous) {
      return;
    }

    if (outgoing) {
      left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
      previous.css( { 'left': left + 'px' } )
        .addClass('animated owl-animated-out')
        .addClass(outgoing)
        .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', clear);
    }

    if (incoming) {
      next.addClass('animated owl-animated-in')
        .addClass(incoming)
        .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', clear);
    }
  };

  Animate.prototype.clear = function(e) {
    $(e.target).css( { 'left': '' } )
      .removeClass('animated owl-animated-out owl-animated-in')
      .removeClass(this.core.settings.animateIn)
      .removeClass(this.core.settings.animateOut);
    this.core.transitionEnd();
  }

  /**
   * Destroys the plugin.
   * @public
   */
  Animate.prototype.destroy = function() {
    var handler, property;

    for (handler in this.handlers) {
      this.core.$element.off(handler, this.handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

})(window.Zepto || window.jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.0.0
 * @author Bartosz Wojciechowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

  /**
   * Creates the autoplay plugin.
   * @class The Autoplay Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Autoplay = function(scope) {
    this.core = scope;
    this.core.options = $.extend({}, Autoplay.Defaults, this.core.options);

    this.handlers = {
      'translated.owl.carousel refreshed.owl.carousel': $.proxy(function() {
        this.autoplay();
      }, this),
      'play.owl.autoplay': $.proxy(function(e, t, s) {
        this.play(t, s);
      }, this),
      'stop.owl.autoplay': $.proxy(function() {
        this.stop();
      }, this),
      'mouseover.owl.autoplay': $.proxy(function() {
        if (this.core.settings.autoplayHoverPause) {
          this.pause();
        }
      }, this),
      'mouseleave.owl.autoplay': $.proxy(function() {
        if (this.core.settings.autoplayHoverPause) {
          this.autoplay();
        }
      }, this)
    };

    this.core.$element.on(this.handlers);
  };

  /**
   * Default options.
   * @public
   */
  Autoplay.Defaults = {
    autoplay: false,
    autoplayTimeout: 5000,
    autoplayHoverPause: false,
    autoplaySpeed: false
  };

  /**
   * @protected
   * @todo Must be documented.
   */
  Autoplay.prototype.autoplay = function() {
    if (this.core.settings.autoplay && !this.core.state.videoPlay) {
      window.clearInterval(this.interval);

      this.interval = window.setInterval($.proxy(function() {
        this.play();
      }, this), this.core.settings.autoplayTimeout);
    } else {
      window.clearInterval(this.interval);
    }
  };

  /**
   * Starts the autoplay.
   * @public
   * @param {Number} [timeout] - ...
   * @param {Number} [speed] - ...
   * @returns {Boolean|undefined} - ...
   * @todo Must be documented.
   */
  Autoplay.prototype.play = function(timeout, speed) {
    // if tab is inactive - doesnt work in <IE10
    if (document.hidden === true) {
      return;
    }

    if (this.core.state.isTouch || this.core.state.isScrolling
      || this.core.state.isSwiping || this.core.state.inMotion) {
      return;
    }

    if (this.core.settings.autoplay === false) {
      window.clearInterval(this.interval);
      return;
    }

    this.core.next(this.core.settings.autoplaySpeed);
  };

  /**
   * Stops the autoplay.
   * @public
   */
  Autoplay.prototype.stop = function() {
    window.clearInterval(this.interval);
  };

  /**
   * Pauses the autoplay.
   * @public
   */
  Autoplay.prototype.pause = function() {
    window.clearInterval(this.interval);
  };

  /**
   * Destroys the plugin.
   */
  Autoplay.prototype.destroy = function() {
    var handler, property;

    window.clearInterval(this.interval);

    for (handler in this.handlers) {
      this.core.$element.off(handler, this.handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

})(window.Zepto || window.jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.0.0
 * @author Artus Kolanowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
  'use strict';

  /**
   * Creates the navigation plugin.
   * @class The Navigation Plugin
   * @param {Owl} carousel - The Owl Carousel.
   */
  var Navigation = function(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;

    /**
     * Indicates whether the plugin is initialized or not.
     * @protected
     * @type {Boolean}
     */
    this._initialized = false;

    /**
     * The current paging indexes.
     * @protected
     * @type {Array}
     */
    this._pages = [];

    /**
     * All DOM elements of the user interface.
     * @protected
     * @type {Object}
     */
    this._controls = {};

    /**
     * Markup for an indicator.
     * @protected
     * @type {Array.<String>}
     */
    this._templates = [];

    /**
     * The carousel element.
     * @type {jQuery}
     */
    this.$element = this._core.$element;

    /**
     * Overridden methods of the carousel.
     * @protected
     * @type {Object}
     */
    this._overrides = {
      next: this._core.next,
      prev: this._core.prev,
      to: this._core.to
    };

    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */
    this._handlers = {
      'prepared.owl.carousel': $.proxy(function(e) {
        if (this._core.settings.dotsData) {
          this._templates.push($(e.content).find('[data-dot]').andSelf('[data-dot]').attr('data-dot'));
        }
      }, this),
      'add.owl.carousel': $.proxy(function(e) {
        if (this._core.settings.dotsData) {
          this._templates.splice(e.position, 0, $(e.content).find('[data-dot]').andSelf('[data-dot]').attr('data-dot'));
        }
      }, this),
      'remove.owl.carousel prepared.owl.carousel': $.proxy(function(e) {
        if (this._core.settings.dotsData) {
          this._templates.splice(e.position, 1);
        }
      }, this),
      'change.owl.carousel': $.proxy(function(e) {
        if (e.property.name == 'position') {
          if (!this._core.state.revert && !this._core.settings.loop && this._core.settings.navRewind) {
            var current = this._core.current(),
              maximum = this._core.maximum(),
              minimum = this._core.minimum();
            e.data = e.property.value > maximum
              ? current >= maximum ? minimum : maximum
              : e.property.value < minimum ? maximum : e.property.value;
          }
        }
      }, this),
      'changed.owl.carousel': $.proxy(function(e) {
        if (e.property.name == 'position') {
          this.draw();
        }
      }, this),
      'refreshed.owl.carousel': $.proxy(function() {
        if (!this._initialized) {
          this.initialize();
          this._initialized = true;
        }
        this._core.trigger('refresh', null, 'navigation');
        this.update();
        this.draw();
        this._core.trigger('refreshed', null, 'navigation');
      }, this)
    };

    // set default options
    this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

    // register event handlers
    this.$element.on(this._handlers);
  }

  /**
   * Default options.
   * @public
   * @todo Rename `slideBy` to `navBy`
   */
  Navigation.Defaults = {
    nav: false,
    navRewind: true,
    navText: [ 'prev', 'next' ],
    navSpeed: false,
    navElement: 'div',
    navContainer: false,
    navContainerClass: 'owl-nav',
    navClass: [ 'owl-prev', 'owl-next' ],
    slideBy: 1,
    dotClass: 'owl-dot',
    dotsClass: 'owl-dots',
    dots: true,
    dotsEach: false,
    dotData: false,
    dotsSpeed: false,
    dotsContainer: false,
    controlsClass: 'owl-controls'
  }

  /**
   * Initializes the layout of the plugin and extends the carousel.
   * @protected
   */
  Navigation.prototype.initialize = function() {
    var $container, override,
      options = this._core.settings;

    // create the indicator template
    if (!options.dotsData) {
      this._templates = [ $('<div>')
        .addClass(options.dotClass)
        .append($('<span>'))
        .prop('outerHTML') ];
    }

    // create controls container if needed
    if (!options.navContainer || !options.dotsContainer) {
      this._controls.$container = $('<div>')
        .addClass(options.controlsClass)
        .appendTo(this.$element);
    }

    // create DOM structure for absolute navigation
    this._controls.$indicators = options.dotsContainer ? $(options.dotsContainer)
      : $('<div>').hide().addClass(options.dotsClass).appendTo(this._controls.$container);

    this._controls.$indicators.on('click', 'div', $.proxy(function(e) {
      var index = $(e.target).parent().is(this._controls.$indicators)
        ? $(e.target).index() : $(e.target).parent().index();

      e.preventDefault();

      this.to(index, options.dotsSpeed);
    }, this));

    // create DOM structure for relative navigation
    $container = options.navContainer ? $(options.navContainer)
      : $('<div>').addClass(options.navContainerClass).prependTo(this._controls.$container);

    this._controls.$next = $('<' + options.navElement + '>');
    this._controls.$previous = this._controls.$next.clone();

    this._controls.$previous
      .addClass(options.navClass[0])
      .html(options.navText[0])
      .hide()
      .prependTo($container)
      .on('click', $.proxy(function(e) {
        this.prev(options.navSpeed);
      }, this));
    this._controls.$next
      .addClass(options.navClass[1])
      .html(options.navText[1])
      .hide()
      .appendTo($container)
      .on('click', $.proxy(function(e) {
        this.next(options.navSpeed);
      }, this));

    // override public methods of the carousel
    for (override in this._overrides) {
      this._core[override] = $.proxy(this[override], this);
    }
  }

  /**
   * Destroys the plugin.
   * @protected
   */
  Navigation.prototype.destroy = function() {
    var handler, control, property, override;

    for (handler in this._handlers) {
      this.$element.off(handler, this._handlers[handler]);
    }
    for (control in this._controls) {
      this._controls[control].remove();
    }
    for (override in this.overides) {
      this._core[override] = this._overrides[override];
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  }

  /**
   * Updates the internal state.
   * @protected
   */
  Navigation.prototype.update = function() {
    var i, j, k,
      options = this._core.settings,
      lower = this._core.clones().length / 2,
      upper = lower + this._core.items().length,
      size = options.center || options.autoWidth || options.dotData
        ? 1 : options.dotsEach || options.items;

    if (options.slideBy !== 'page') {
      options.slideBy = Math.min(options.slideBy, options.items);
    }

    if (options.dots || options.slideBy == 'page') {
      this._pages = [];

      for (i = lower, j = 0, k = 0; i < upper; i++) {
        if (j >= size || j === 0) {
          this._pages.push({
            start: i - lower,
            end: i - lower + size - 1
          });
          j = 0, ++k;
        }
        j += this._core.mergers(this._core.relative(i));
      }
    }
  }

  /**
   * Draws the user interface.
   * @todo The option `dotData` wont work.
   * @protected
   */
  Navigation.prototype.draw = function() {
    var difference, i, html = '',
      options = this._core.settings,
      $items = this._core.$stage.children(),
      index = this._core.relative(this._core.current());

    if (options.nav && !options.loop && !options.navRewind) {
      this._controls.$previous.toggleClass('disabled', index <= 0);
      this._controls.$next.toggleClass('disabled', index >= this._core.maximum());
    }

    this._controls.$previous.toggle(options.nav);
    this._controls.$next.toggle(options.nav);

    if (options.dots) {
      difference = this._pages.length - this._controls.$indicators.children().length;

      if (options.dotData && difference !== 0) {
        for (i = 0; i < this._controls.$indicators.children().length; i++) {
          html += this._templates[this._core.relative(i)];
        }
        this._controls.$indicators.html(html);
      } else if (difference > 0) {
        html = new Array(difference + 1).join(this._templates[0]);
        this._controls.$indicators.append(html);
      } else if (difference < 0) {
        this._controls.$indicators.children().slice(difference).remove();
      }

      this._controls.$indicators.find('.active').removeClass('active');
      this._controls.$indicators.children().eq($.inArray(this.current(), this._pages)).addClass('active');
    }

    this._controls.$indicators.toggle(options.dots);
  }

  /**
   * Extends event data.
   * @protected
   * @param {Event} event - The event object which gets thrown.
   */
  Navigation.prototype.onTrigger = function(event) {
    var settings = this._core.settings;

    event.page = {
      index: $.inArray(this.current(), this._pages),
      count: this._pages.length,
      size: settings && (settings.center || settings.autoWidth || settings.dotData
        ? 1 : settings.dotsEach || settings.items)
    };
  }

  /**
   * Gets the current page position of the carousel.
   * @protected
   * @returns {Number}
   */
  Navigation.prototype.current = function() {
    var index = this._core.relative(this._core.current());
    return $.grep(this._pages, function(o) {
      return o.start <= index && o.end >= index;
    }).pop();
  }

  /**
   * Gets the current succesor/predecessor position.
   * @protected
   * @returns {Number}
   */
  Navigation.prototype.getPosition = function(successor) {
    var position, length,
      options = this._core.settings;

    if (options.slideBy == 'page') {
      position = $.inArray(this.current(), this._pages);
      length = this._pages.length;
      successor ? ++position : --position;
      position = this._pages[((position % length) + length) % length].start;
    } else {
      position = this._core.relative(this._core.current());
      length = this._core.items().length;
      successor ? position += options.slideBy : position -= options.slideBy;
    }
    return position;
  }

  /**
   * Slides to the next item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */
  Navigation.prototype.next = function(speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
  }

  /**
   * Slides to the previous item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */
  Navigation.prototype.prev = function(speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
  }

  /**
   * Slides to the specified item or page.
   * @public
   * @param {Number} position - The position of the item or page.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
   */
  Navigation.prototype.to = function(position, speed, standard) {
    var length;

    if (!standard) {
      length = this._pages.length;
      $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
    } else {
      $.proxy(this._overrides.to, this._core)(position, speed);
    }
  }

  $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

})(window.Zepto || window.jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.0.0
 * @author Artus Kolanowski
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
  'use strict';

  /**
   * Creates the hash plugin.
   * @class The Hash Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Hash = function(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;

    /**
     * Hash table for the hashes.
     * @protected
     * @type {Object}
     */
    this._hashes = {};

    /**
     * The carousel element.
     * @type {jQuery}
     */
    this.$element = this._core.$element;

    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */
    this._handlers = {
      'initialized.owl.carousel': $.proxy(function() {
        if (this._core.settings.startPosition == 'URLHash') {
          $(window).trigger('hashchange.owl.navigation');
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function(e) {
        var hash = $(e.content).find('[data-hash]').andSelf('[data-hash]').attr('data-hash');
        this._hashes[hash] = e.content;
      }, this)
    };

    // set default options
    this._core.options = $.extend({}, Hash.Defaults, this._core.options);

    // register the event handlers
    this.$element.on(this._handlers);

    // register event listener for hash navigation
    $(window).on('hashchange.owl.navigation', $.proxy(function() {
      var hash = window.location.hash.substring(1),
        items = this._core.$stage.children(),
        position = this._hashes[hash] && items.index(this._hashes[hash]) || 0;

      if (!hash) {
        return false;
      }

      this._core.to(position, false, true);
    }, this));
  }

  /**
   * Default options.
   * @public
   */
  Hash.Defaults = {
    URLhashListener: false
  }

  /**
   * Destroys the plugin.
   * @public
   */
  Hash.prototype.destroy = function() {
    var handler, property;

    $(window).off('hashchange.owl.navigation');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  }

  $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

})(window.Zepto || window.jQuery, window, document);


/***/ }),
/* 129 */
/***/ (function(module, exports) {

if (!window.MetaDataManager) {

/**
 * MetaData Manager
 */

SNI.MetaData = {};

// Parameter name mapping from mdManager to PageDataManager.
SNI.MetaData.CQParamMapping = {
  'CATEGORYDSPNAME': 'categoryDisplayName',
  'CONTENTTAG1': 'contentTag1',
  'CONTENTTAG2': 'contentTag2',
  'DETAILID': 'detailId',
  'DELIVERY_CHANNEL': 'deliveryChannel',
  'DIMENSIONVALUES': 'dimensionValues',
  'FASTFWDID': 'fastFwdId',
  'FILTER': 'searchFilter',
  'HUBPATH': 'hubPath',
  'KEYWORDS': 'searchKeywords',
  'MEALTYPE': 'mealType',
  'MAININGREDIENT': 'mainIngredient',
  'NOSEARCHRESULTS': 'noSearchResults',
  'PAGENUMBER': 'pageNumber',
    'PUBLISHTIME': 'publishTime',
  'SCTNDSPNAME': 'sectionDisplayName',
  'SHOW_ABBR': 'showAbbreviation',
  'SPONSORSHIP': 'sponsorship',
  'SITE': 'siteName',
  'SEARCHTERMS': 'searchTerms',
  'SORT': 'searchSort',
  'SPOTLIGHT_1': 'spotlight1',
  'SPOTLIGHT_2': 'spotlight2',
  'SPOTLIGHT_CENTER_1_NAME': 'spotlightCenter1Name',
  'SPOTLIGHT_CENTER_1_STYLE': 'spotlightCenter1Style',
  'SPOTLIGHT_CENTER_2_NAME': 'spotlightCenter2Name',
  'SPOTLIGHT_CENTER_2_STYLE': 'spotlightCenter2Style',
  'TALENTNAME': 'talentName',
  'UNIQUEID': 'uniqueId',
  'USERID': 'userId',
  'ADKEY1': 'adkey1',
  'ADKEY2': 'adkey2',
  'CLASSIFICATION': 'classification',
  'CUISINE': 'cuisine',
  'DIMENSIONS': 'dimensions',
  'DIFFICULTY': 'difficulty',
  'DISH': 'dish',
  'KEYTERM': 'keyterm',
  'NUTRITION': 'nutrition',
  'OCCASIONS': 'occasions',
  'SOURCE': 'source',
  'TASTE': 'taste',
  'TECHNIQUE': 'technique',
  'TITLE': 'title',
  'TYPE': 'type',
  'URL': 'url',
  'RESTRICTED':'restricted',
  'SUBSECTION': 'SubSection',
  'SUBSECTIONL2': 'SubSectionL2',
  'TAGGROUP1': 'TagGroup1',
  'TAGGROUP2': 'TagGroup2',
  'SHOW': 'Show',
  'PROFESSIOAL': 'Professioal',
  'TALENT': 'Talent',
  'EDITOR': 'Editor',
  'PARTNER': 'Partner',
  'EDITORIALTRACKING': 'EditorialTracking',
  'PUBLISHEDDATE': 'PublishedDate',
  'OVERLAY_UNIQUEID': 'Overlay_UniqueID',
  'OVERLAY_URL': 'Overlay_URL',
  'OVERLAY_TAGGROUP1': 'Overlay_TagGroup1',
  'OVERLAY_TAGGROUP2': 'Overlay_TagGroup2',
  'OVERLAY_SHOW': 'Overlay_Show',
  'OVERLAY_PROFESSIONAL': 'Overlay_Professional',
  'OVERLAY_TALENT': 'Overlay_Talent',
  'OVERLAY_EDITOR': 'Overlay_Editor',
  'OVERLAY_PARTNER': 'Overlay_Partner',
  'TOURPOSITION': 'TourPosition'
};

SNI.MetaData.Parameter = function(){
  var parameters = {};    // object to store parameters

  this.addParameter = function(key, value){
    key = key.toUpperCase();    // always force key to uppercase before insert (case-insensitive insert and lookup)
    if(!parameters[key]) {
      parameters[key] = [];
    }
    parameters[key].push(value);
  };

  this.getParameter = function(key, separator){
    key = key.toUpperCase();    // always force key to uppercase before retrieval (case-insensitive insert and lookup)
    if(!parameters[key]) {
      return;
    }
    return parameters[key].join(separator);
  };

  this.getKeys = function(){
    return parameters;
  };

  this.setParameter = function(key, value){
    key = key.toUpperCase();    // always force key to uppercase before insert (case-insensitive insert and lookup)
    parameters[key] = [];
    parameters[key].push(value);
  };

  this.resetKeys = function() {
    parameters = {};
  };

};



/* -------------------------------------------
      MetaDataManager
------------------------------------------- */
SNI.MetaData.Manager = function(){

  var m = new SNI.MetaData.Parameter();

  this.addParameter = function(key, value) {
    m.addParameter(key, value);

    if (typeof CQ_Analytics == 'object' && CQ_Analytics.PageDataMgr && SNI.MetaData.CQParamMapping) {
      key = key.toUpperCase();
      if (key in SNI.MetaData.CQParamMapping) {
        CQ_Analytics.PageDataMgr.setProperty(SNI.MetaData.CQParamMapping[key], this.getParameterString(key));
      }
    }
  };
  this.addAttribute = this.addParameter;
  this.getParameter = m.getParameter;
  this.getKeys = m.getKeys;
  this.setParameter = function(key, value) {
    m.setParameter(key, value);

    if ( window.CQ_Analytics ){
      if (CQ_Analytics.PageDataMgr && SNI.MetaData.CQParamMapping) {
        key = key.toUpperCase();
        if (key in SNI.MetaData.CQParamMapping) {
          CQ_Analytics.PageDataMgr.setProperty(SNI.MetaData.CQParamMapping[key], this.getParameterString(key));
        }
      }
    }
  };
  this.resetKeys = m.resetKeys;

  // gets the value of the parameter, but returns empty string if parameter doesn't exist
  this.getParameterString = function(key) {
    var s =  this.getParameter(key," ");
    if ( s == null ) {
      s = "";
    }
    return s;
  };

  // these getters are for backwards compatibility; should use getParameterString() now

  // generic getters
  this.getPageType =    function() { return this.getParameterString("Type"); };
  this.getPageTitle =   function() { return this.getParameterString("Title"); };
  this.getSite =      function() { return this.getParameterString("Site"); };
  this.getSctnId =    function() { return this.getParameterString("SctnId"); };
  this.getSctnName =    function() { return this.getParameterString("SctnName"); };
  this.getSponsorship =   function() { return this.getParameterString("Sponsorship"); };
  this.getAbstract =    function() { return this.getParameterString("Abstract"); };
  this.getKeywords =    function() { return this.getParameterString("Keywords"); };
  this.getClassification =function() { return this.getParameterString("Classification"); };
  this.getSctnDspName =   function() { return this.getParameterString("SctnDspName"); };
  this.getCategoryDspName=function() { return this.getParameterString("CategoryDspName"); };
  this.getShowAbbr =    function() { return this.getParameterString("Show_Abbr"); };
  this.getRole =      function() { return this.getParameterString("Role"); };
  this.getDetailId =    function() { return this.getParameterString("DetailId"); };
  this.getPageNumber =  function() { return this.getParameterString("PageNumber"); };
  this.getUniqueId =    function() { return this.getParameterString("UniqueId"); };
  this.getUserId =    function() { return this.getParameterString("UserId"); };
  this.getFilters =     function() { return this.getParameterString("Filters"); };

  // other methods

  this.getSearchTerm = function() {
    var args = parseQueryString ();
    for (var arg in args) {
      var s = arg.toUpperCase();
      if ( s == 'SEARCHSTRING' ){
        return args[arg];
      }
    }
    return "";
  };

  this.setMultimediaFlag = function(flag) {
    if ( flag != null ) {
      this.addParameter("MultimediaFlag",flag);
    } else {
      this.addParameter("MultimediaFlag","");
    }
  };

  this.parseQueryString = function(str) {
    str = str ? str : document.location.search;
    var query = str.charAt(0) == '?' ? str.substring(1) : str;
    var args = {};
    if (query) {
      var fields = query.split('&');
      for (var f = 0; f < fields.length; f++) {
        var field = fields[f].split('=');
        args[unescape(field[0].replace(/\+/g, ' '))] =
      unescape(field[1].replace(/\+/g, ' '));
      }
    }
    return args;
  };

};

// MetaDataManager for backwards compatibility
var MetaDataManager = window.MetaDataManager = SNI.MetaData.Manager;

}


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(18) && !__webpack_require__(54)(function () {
  return Object.defineProperty(__webpack_require__(92)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(22);
var anObject = __webpack_require__(23);
var getKeys = __webpack_require__(94);

module.exports = __webpack_require__(18) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(32);
var toIObject = __webpack_require__(45);
var arrayIndexOf = __webpack_require__(275)(false);
var IE_PROTO = __webpack_require__(97)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(96);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(67)('meta');
var isObject = __webpack_require__(24);
var has = __webpack_require__(32);
var setDesc = __webpack_require__(22).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(54)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(283), __esModule: true };

/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * @gigya.js Initial login of Gigya
 * @author Ben/Justin
 */

/**
 * @showLoginRegScreen bring up the giya modal box
 * @logOut exports logout method
 * @isLoggedIn provides way to see if a user is logged in
 */
SNI.Application.addService('gigya/account', function (application) {

  // best practice to pull in global variables
  var debug = application.getService('logger').create('service.gigya.account'),
      check = application.getService('check').new(debug),
      gigya = check.exists('gigya.accounts') ? application.getGlobal('gigya') : false,
      moderation = application.getService('gigya/moderation'),
      isMobile = application.getService('device-type').isMobile,
      getBrand = application.getService('gigya/getBrand');

  var setScreenSet = {
    hgtv: 'Login-web',
    diy: 'DIY-Login-web',
    core: 'Core-RegistrationLogin',
    profile: 'Core-ProfileUpdate'
  };

  var brand = getBrand.basic();

  var moderatedFields = ['email', 'nickname', 'lastName', 'firstName', 'photoURL'];

  var screenSet = setScreenSet.core;

  function getModeratedFields() {
    return moderatedFields;
  }

  /*  Profile data can be under data.temp.* or profile.* we have a method for each, and then we compare */

  var getTempData = function getTempData(eventObj, field) {
    return eventObj && eventObj.data && eventObj.data.temp && eventObj.data.temp.profile && eventObj.data.temp.profile[field];
  };

  var getProfileData = function getProfileData(eventObj, field) {
    return eventObj && eventObj.profile && eventObj.profile[field];
  };

  var getCurrentProfileInfo = function getCurrentProfileInfo(eventObj) {
    var info = {};

    moderatedFields.forEach(function (field) {
      info[field] = getProfileData(eventObj, field) || '';
    });

    return info;
  };

  /* Get temp or profile data given a profile event Object - display what's available */
  var getProfileInfo = function getProfileInfo(eventObj) {
    var info = {};

    moderatedFields.forEach(function (field) {
      info[field] = getTempData(eventObj, field) || getProfileData(eventObj, field) || '';
    });

    return info;
  };

  /** moderate
  * send info to moderation
  * @param response {object} - form data
  */
  var moderate = function moderate(response) {
    moderation.processProfile(response);
  };

  var handleEditEmail = function handleEditEmail(response) {
    var profile = response.profile,
        formData = response.formData;

    var oldEmail = profile.email,
        newEmail = formData.email;

    if (oldEmail !== newEmail) {
      if (gigya.accounts) {
        gigya.accounts.setAccountInfo({ removeLoginEmails: oldEmail });
      }
      debug.log('removed', oldEmail);
      return true;
    }

    return false;
  };

  var checkForChanges = function checkForChanges(newInfo, oldInfo) {
    var formInfo = {},
        tmpKeys = Object.keys(newInfo),
        reg = /data\.temp\.profile\./;

    // Get all the temp fields from form, exclude email since it will be tested elsewhere
    var tempFields = tmpKeys.filter(function (key) {
      return reg.test(key);
    }).filter(function (key) {
      return key !== 'data.temp.profile.email';
    });
    var modFields = Object.keys(oldInfo).filter(function (key) {
      return key !== 'email';
    });

    tempFields.forEach(function (key) {
      var newKey = key.replace(reg, '');
      formInfo[newKey] = newInfo[key];
    });

    var diff = modFields.some(function (field) {
      return formInfo[field] !== oldInfo[field];
    });

    return diff;
  };

  var handleEditField = function handleEditField(eventObj) {
    var field = eventObj.field,
        value = eventObj.value;

    var trimVal = value.trim();
    if (field === 'data.temp.profile.nickname' && trimVal === '') {
      $('#data-nickname').val('Anonymous'); // Do not allow empty nickname
    }
    if (field === 'email') {
      // update hidden fields
      $('#fnCommunityEditEmail').val(value);
      $('#fnCommunityEditProfileEmail').val(value);
    }
  };

  var profileBeforeSubmit = function profileBeforeSubmit(response) {
    var emailChanged = handleEditEmail(response);
    // get moderated data i.e. temp || profile
    var profileData = getCurrentProfileInfo(response);
    // Compare form data vs. account object data
    var dataChanged = checkForChanges(response.formData, profileData);
    if (emailChanged || dataChanged) moderate(response);
  };

  var loginRegBeforeSubmit = function loginRegBeforeSubmit(eventObj) {
    debug.log('loginRegBeforeSubmit', eventObj);
    var form = eventObj.form,
        formData = eventObj.formData;

    var year = Number(formData['profile.birthYear']),
        month = formData['profile.birthMonth'],
        day = formData['profile.birthDay'];

    if (form === 'gigya-register-form' || form === 'gigya-profile-form') {
      if (year === new Date().getFullYear() - 13) {
        if (month === '' || day === '') {
          $('#registration-monthday-alert').show();
          $('.gigya-dob-container').addClass('gigya-error');
          debug.log('CANCEL FORM SUBMIT');
          return false;
        } else {
          $('.gigya-dob-container').removeClass('gigya-error');
          $('#registration-monthday-alert').hide();
        }
      }
    }
  };

  var _onAfterScreenLoad = function _onAfterScreenLoad(info) {
    var url = window.location.hostname.replace('www.', ''),
        domain = url || brand.toUpperCase(),
        site = domain + '\'s',
        name = void 0;

    switch (info.currentScreen) {
      case 'gigya-register-screen':
        var $elem = $('#gigya-register-screen'),
            elem = $elem.get(0);
        // Stop module if its still running
        if (elem) {
          try {
            application.stop(elem);
          } catch (e) {
            debug.log(e);
          }
          application.start(elem);
        }
        break;
      case 'gigya-registration-fail':
        $('.gigya-core-site').text(domain);
        break;
      case 'gigya-complete-registration-screen':
        name = info.profile.firstName;
        if (name) {
          $('.gigya-core-username').text(' ' + name);
        }
        $('.gigya-core-sitename').text(site);
        break;
    }
  };

  function onHide(reason) {
    document.removeEventListener('keydown', hideOnEsc);
  }

  // callbacks for api call
  function errorHandler(err) {

    if (err.errorCode === 403044) {
      if (gigya.accounts) {
        gigya.accounts.switchScreen({
          screenSet: screenSet,
          screen: 'gigya-registration-fail'
        });
      }
    }
  }

  /** @showLoginRegScreen makes a call to show login screen
  * takes an object in the call to handle errors, screenSet, beforeScreenLoad, and onHide
  */
  function showLoginRegScreen(event, isRegistration, screen, callback) {

    var isLoginEvent = event && event.eventName && event.eventName === 'siteLoginClicked';
    var defaultScreen = isLoginEvent ? 'gigya-login-screen' : isRegistration ? 'gigya-register-screen' : 'gigya-login-screen';
    var startScreen = screen || defaultScreen;

    if (gigya.accounts) {
      gigya.accounts.showScreenSet({
        screenSet: screenSet,
        startScreen: startScreen,
        dialogStyle: 'modern',
        sessionExpiration: -2,
        context: {},
        deviceType: isMobile ? 'mobile' : 'default',
        onError: errorHandler,
        onAfterScreenLoad: function onAfterScreenLoad(obj) {
          _onAfterScreenLoad(obj);
          if (typeof callback === 'function') {
            callback(obj);
          }
        },
        onBeforeSubmit: loginRegBeforeSubmit,
        onHide: onHide
      });
    }

    // close with esc key
    document.addEventListener('keydown', hideOnEsc);
  }

  function hideOnEsc(e) {
    if (e.keyCode === 27 || e.which === 27) {
      if (gigya.accounts) {
        gigya.accounts.hideScreenSet({ screenSet: screenSet });
      }
    }
  }

  /** @logOut
  * Can be called via running this method to log out
  */
  function logOut() {
    var message = function message(response) {
      debug.log('Logged out');
    };
    if (gigya.accounts) {
      gigya.accounts.logout({ callback: message });
    }
  }

  /** @isLoggedIn
  * checks if a user is logged in using gigya.accounts.getAccountInfo
  * if errocode is found a user is not logged in
  * two messages are broadcast out @gigya.loggedInFalse and @gigya.loggedInTrue
  */
  function isLoggedIn(customRequest) {
    var customText = customRequest || '';
    var broadCastState = function broadCastState(response) {
      if (response.errorCode === 0) {
        debug.log('user is logged in');
        application.broadcast('gigya.isloggedIn' + customText, response);
      } else {
        application.broadcast('gigya.isloggedOut' + customText);
        debug.log('user is logged out');
      }
    };
    // make call to gigya to get account info
    if (gigya.accounts) {
      gigya.accounts.getAccountInfo({
        callback: broadCastState
      });
    }
  }

  /** @insertProfle
  * gigya call to get screenset
  * response inserts the profile into div on page
  * @param {function} moderate is a callback function to run before we submit data to gigya
  */
  var insertProfile = function insertProfile(options) {
    if (!gigya) {
      return;
    }

    var params = {
      containerID: 'profile',
      screenSet: setScreenSet.profile,
      onBeforeSubmit: profileBeforeSubmit,
      onAfterScreenLoad: afterProfileLoad,
      onFieldChanged: handleEditField
    };

    var afterProfileLoad = options.afterProfileLoad;


    if (afterProfileLoad) {
      params.onAfterScreenLoad = afterProfileLoad;
    }

    gigya.accounts.showScreenSet(params);
  };

  return {
    showLoginScreen: showLoginRegScreen,
    showLoginRegScreen: showLoginRegScreen,
    logOut: logOut,
    isLoggedIn: isLoggedIn,
    insertProfile: insertProfile,
    getProfileInfo: getProfileInfo,
    getModeratedFields: getModeratedFields
  };
});

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(288);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 138 */
/***/ (function(module, exports) {



/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(290)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(140)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(68);
var $export = __webpack_require__(21);
var redefine = __webpack_require__(141);
var hide = __webpack_require__(31);
var has = __webpack_require__(32);
var Iterators = __webpack_require__(56);
var $iterCreate = __webpack_require__(291);
var setToStringTag = __webpack_require__(69);
var getPrototypeOf = __webpack_require__(292);
var ITERATOR = __webpack_require__(9)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31);


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(23);
var dPs = __webpack_require__(131);
var enumBugKeys = __webpack_require__(99);
var IE_PROTO = __webpack_require__(97)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(92)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(143).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(8).document;
module.exports = document && document.documentElement;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(294);
var global = __webpack_require__(8);
var hide = __webpack_require__(31);
var Iterators = __webpack_require__(56);
var TO_STRING_TAG = __webpack_require__(9)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(55);
var TAG = __webpack_require__(9)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(23);
var aFunction = __webpack_require__(65);
var SPECIES = __webpack_require__(9)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(64);
var invoke = __webpack_require__(303);
var html = __webpack_require__(143);
var cel = __webpack_require__(92);
var global = __webpack_require__(8);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(55)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var isObject = __webpack_require__(24);
var newPromiseCapability = __webpack_require__(100);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 150 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(132);
var hiddenKeys = __webpack_require__(99).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 152 */
/***/ (function(module, exports) {

SNI.Application.addService('url', function (application) {

  var debug = application.getService('logger').create('services/url');

  /**
   * do not put gac in the map because gac has no watch live page
   * gac: 'greatamericancountry',
   */
  var domainMap = {
    hgtv: 'hgtv',
    diy: 'diynetwork',
    gac: 'greatamericancountry',
    food: 'foodnetwork',
    cook: 'cookingchanneltv',
    travel: 'travelchannel'
  };

  /**
   * Brands that have watch sites
   */
  var watchSites = ['hgtv', 'diy', 'food', 'cook', 'travel'];

  /**
   * @param {string} brand The brand slug of the site
   * @param {object} domains An object with a mapping of brand slug => base domain (ie diy => diynetwork)
   */
  var brandToDomain = function brandToDomain(brand) {
    var domains = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : domainMap;

    if (brand in domainMap) {
      return domains[brand];
    }
    debug.error('Expected brand ' + brand + ' does not exist in the domainMap');
    return false;
  };

  /**
   *
   * @param {string} brand The brand slug of the desired watch site (defaults to the current brand)
   */
  var watchSite = function watchSite() {
    var brand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SNI.Config.brand;

    var domain = brandToDomain(brand);
    return domain && watchSites.includes(brand) ? '//watch.' + domain + '.com/live.html' : '';
  };

  return {
    brandToDomain: brandToDomain,
    watchSite: watchSite
  };
});

/***/ }),
/* 153 */
/***/ (function(module, exports) {

SNI.Application.addService('social', function (application) {
  return {
    sharebar: application.getService('social/sharebar')
  };
});

/***/ }),
/* 154 */
/***/ (function(module, exports) {

SNI.Application.addService('truncate', function (application) {
  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */
  //let debug = application.getService('logger').create('service.truncate');
  //let check = application.getService('check').new(debug);

  var re_str_tagname = '([a-z0-9\-]+)';
  var re_opener = function re_opener() {
    return new RegExp('<' + re_str_tagname + '[^><]*>', 'gi');
  };
  var re_closer = function re_closer() {
    return new RegExp('</' + re_str_tagname + '>', 'gi');
  };
  var re_inside_tags = function re_inside_tags() {
    return new RegExp('(<' + re_str_tagname + '>)(.*?)(</' + re_str_tagname + '>)', 'gi');
  };
  var re_ends_in_tag = function re_ends_in_tag() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : re_str_tagname;
    return new RegExp('</' + tag + '>$', 'gi');
  };

  function html(html, maxlen) {
    var trailer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var moreoptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { trimPunctuation: true };

    var pieces = void 0;
    var output = {};
    var trials = [];
    var attachTrailer = '';

    html = html.replace(/\s/g, ' '); //remove vertical whitespace since it's inconsequential and we do not expect it. note this makes <pre> tags unsupported

    if (removeTags(html).length <= maxlen) return html;

    pieces = splitRetainDelimiter(html, '>');
    pieces = splitWithin(pieces, ' <');
    pieces = splitWithin(pieces, ' ', true);

    for (var p = 0; p < pieces.length; p++) {
      var trial = getTrial(pieces, 0, p + 1, moreoptions);
      if (trial.text.length > 0) {
        if (trial.text.length <= maxlen) {
          output = trial;
          trials.push(trial);
          attachTrailer = trailer;
        } else {
          break;
        }
      }
    }
    if (trials.length > 1) {
      for (var q = trials.length - 1; q >= 0; q--) {
        if (output.text.length > trials[q].text.length) {
          break;
        } else {
          output = trials[q];
        }
      }
    }
    if (output.html && output.html !== '') {
      output.html = appendTrailer(output.html.trim(), attachTrailer);
    }
    return output.html ? output.html : '';
  }
  function removeTags(str) {
    return removeBrokenTags(str.replace(re_opener(), '').replace(re_closer(), '').replace(/\ +/g, ' ')).trim();
  }
  function closeTags(string) {
    var openers = findOpeners(string);
    var closers = findClosers(string);
    var unique = openers.filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).reverse();
    for (var i = 0; i < unique.length; i++) {
      var missing = countArrayItems(openers, unique[i]) - countArrayItems(closers, unique[i]);
      if (missing > 0) {
        for (var j = 0; j < missing; j++) {
          string += '</' + unique[i] + '>';
        }
      }
    }
    return removeTags(string) === '' ? '' : string;
  }
  //remove final tags cut off in the middle
  function removeBrokenTags(str) {
    return str.replace(new RegExp('</*' + re_str_tagname + '* *[^ >]*$', 'gi'), '');
  }
  function getTrial(pieces, start, current, options) {
    var html = pieces[start] && pieces[current] ? pieces.slice(start, current).join('') : '';
    html = removeBrokenTags(html);
    if (options.trimPunctuation) {
      html = trimPunctuation(html);
    }
    return {
      html: html,
      text: html.length ? removeTags(html) : ''
    };
  }
  function findOpeners(string) {
    var arr = string.match(re_opener());
    return Array.isArray(arr) ? arr.map(function (item) {
      var pieces = re_opener().exec(item);
      return pieces && pieces.length > 1 ? pieces[1] : item;
    }) : [];
  }
  function findClosers(string) {
    var arr = string.match(re_closer());
    return Array.isArray(arr) ? arr.map(function (item) {
      var pieces = re_closer().exec(item);
      return pieces && pieces.length > 0 ? pieces[1] : item;
    }) : [];
  }
  function appendTrailer(str, trailer) {
    //if ends in a tag, put the trailer inside it, unless it's a link
    var closed = closeTags(str);
    var re_ends_in_link = re_ends_in_tag('a');
    if (closed.match(re_ends_in_link)) {
      str = closed.replace(re_ends_in_link, '</a>' + trailer);
    } else {
      var re_final_tag = re_ends_in_tag();
      var finalTag = re_final_tag.exec(closed);
      finalTag = finalTag && finalTag.length ? finalTag[0] : false;
      if (finalTag) {
        str = closed.replace(re_final_tag, trailer + finalTag);
      } else {
        str += trailer;
      }
    }
    return str;
  }

  // semi-generic functions:

  //split a string into an array, but retain the delimiter appended to the end of each item
  function splitRetainDelimiter(input, delimiter) {
    var marker = '[,|,]';
    return input.replace(RegExp('' + delimiter, 'gi'), '' + delimiter + marker).split(marker);
  }
  function splitWithin(input) {
    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
    var insideTags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var output = [];
    for (var i = 0; i < input.length; i++) {
      if (insideTags === false || !input[i].match(re_opener())) {
        //but not within in tags (attributes are defined that way)
        var addThese = [];
        var text = insideTags ? rangeOfText(input[i]) : false;
        if (text) {
          addThese.push(input[i].substring(0, text.begin));
          addThese = addThese.concat(splitRetainDelimiter(input[i].substring(text.begin, text.end), delimiter));
          addThese.push(input[i].substring(text.end));
        } else {
          addThese = splitRetainDelimiter(input[i], delimiter);
        }
        output = output.concat(addThese);
      } else {
        output.push(input[i]);
      }
    }
    return output;
  }
  function countArrayItems(arr, item) {
    var count = 0;
    for (var i = 0; i < arr.length; i++) {
      if (item === arr[i]) count++;
    }
    return count;
  }
  function rangeOfText(str) {
    var m = re_inside_tags().exec(str);
    if (m) {
      return {
        begin: m.index + m[1].length,
        end: m.index + m[1].length + m[2].length
      };
    }
  }
  function trimPunctuation(string) {
    return string.trim().replace(/[^a-z0-9\>]$/gi, '');
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {
    html: html,
    removeTags: removeTags,
    closeTags: closeTags,
    removeBrokenTags: removeBrokenTags
  };
});

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.array-buffer.js
var es6_typed_array_buffer = __webpack_require__(156);
var es6_typed_array_buffer_default = /*#__PURE__*/__webpack_require__.n(es6_typed_array_buffer);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.data-view.js
var es6_typed_data_view = __webpack_require__(157);
var es6_typed_data_view_default = /*#__PURE__*/__webpack_require__.n(es6_typed_data_view);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.int8-array.js
var es6_typed_int8_array = __webpack_require__(158);
var es6_typed_int8_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_int8_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint8-array.js
var es6_typed_uint8_array = __webpack_require__(163);
var es6_typed_uint8_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_uint8_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js
var es6_typed_uint8_clamped_array = __webpack_require__(164);
var es6_typed_uint8_clamped_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_uint8_clamped_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.int16-array.js
var es6_typed_int16_array = __webpack_require__(165);
var es6_typed_int16_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_int16_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint16-array.js
var es6_typed_uint16_array = __webpack_require__(166);
var es6_typed_uint16_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_uint16_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.int32-array.js
var es6_typed_int32_array = __webpack_require__(167);
var es6_typed_int32_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_int32_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint32-array.js
var es6_typed_uint32_array = __webpack_require__(168);
var es6_typed_uint32_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_uint32_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.float32-array.js
var es6_typed_float32_array = __webpack_require__(169);
var es6_typed_float32_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_float32_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.float64-array.js
var es6_typed_float64_array = __webpack_require__(170);
var es6_typed_float64_array_default = /*#__PURE__*/__webpack_require__.n(es6_typed_float64_array);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.map.js
var es6_map = __webpack_require__(171);
var es6_map_default = /*#__PURE__*/__webpack_require__.n(es6_map);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.set.js
var es6_set = __webpack_require__(173);
var es6_set_default = /*#__PURE__*/__webpack_require__.n(es6_set);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.weak-map.js
var es6_weak_map = __webpack_require__(174);
var es6_weak_map_default = /*#__PURE__*/__webpack_require__.n(es6_weak_map);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.weak-set.js
var es6_weak_set = __webpack_require__(175);
var es6_weak_set_default = /*#__PURE__*/__webpack_require__.n(es6_weak_set);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.apply.js
var es6_reflect_apply = __webpack_require__(176);
var es6_reflect_apply_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_apply);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.construct.js
var es6_reflect_construct = __webpack_require__(177);
var es6_reflect_construct_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_construct);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.define-property.js
var es6_reflect_define_property = __webpack_require__(179);
var es6_reflect_define_property_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_define_property);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.delete-property.js
var es6_reflect_delete_property = __webpack_require__(180);
var es6_reflect_delete_property_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_delete_property);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.get.js
var es6_reflect_get = __webpack_require__(181);
var es6_reflect_get_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_get);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js
var es6_reflect_get_own_property_descriptor = __webpack_require__(182);
var es6_reflect_get_own_property_descriptor_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_get_own_property_descriptor);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js
var es6_reflect_get_prototype_of = __webpack_require__(183);
var es6_reflect_get_prototype_of_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_get_prototype_of);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.has.js
var es6_reflect_has = __webpack_require__(184);
var es6_reflect_has_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_has);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.is-extensible.js
var es6_reflect_is_extensible = __webpack_require__(185);
var es6_reflect_is_extensible_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_is_extensible);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.own-keys.js
var es6_reflect_own_keys = __webpack_require__(186);
var es6_reflect_own_keys_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_own_keys);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js
var es6_reflect_prevent_extensions = __webpack_require__(187);
var es6_reflect_prevent_extensions_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_prevent_extensions);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.set.js
var es6_reflect_set = __webpack_require__(188);
var es6_reflect_set_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_set);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js
var es6_reflect_set_prototype_of = __webpack_require__(189);
var es6_reflect_set_prototype_of_default = /*#__PURE__*/__webpack_require__.n(es6_reflect_set_prototype_of);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__(190);
var es6_promise_default = /*#__PURE__*/__webpack_require__.n(es6_promise);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__(194);
var es6_symbol_default = /*#__PURE__*/__webpack_require__.n(es6_symbol);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__(198);
var es6_object_assign_default = /*#__PURE__*/__webpack_require__.n(es6_object_assign);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.is.js
var es6_object_is = __webpack_require__(199);
var es6_object_is_default = /*#__PURE__*/__webpack_require__.n(es6_object_is);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.set-prototype-of.js
var es6_object_set_prototype_of = __webpack_require__(201);
var es6_object_set_prototype_of_default = /*#__PURE__*/__webpack_require__.n(es6_object_set_prototype_of);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__(202);
var es6_function_name_default = /*#__PURE__*/__webpack_require__.n(es6_function_name);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.raw.js
var es6_string_raw = __webpack_require__(203);
var es6_string_raw_default = /*#__PURE__*/__webpack_require__.n(es6_string_raw);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.from-code-point.js
var es6_string_from_code_point = __webpack_require__(204);
var es6_string_from_code_point_default = /*#__PURE__*/__webpack_require__.n(es6_string_from_code_point);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.code-point-at.js
var es6_string_code_point_at = __webpack_require__(205);
var es6_string_code_point_at_default = /*#__PURE__*/__webpack_require__.n(es6_string_code_point_at);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.repeat.js
var es6_string_repeat = __webpack_require__(207);
var es6_string_repeat_default = /*#__PURE__*/__webpack_require__.n(es6_string_repeat);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __webpack_require__(208);
var es6_string_starts_with_default = /*#__PURE__*/__webpack_require__.n(es6_string_starts_with);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.ends-with.js
var es6_string_ends_with = __webpack_require__(209);
var es6_string_ends_with_default = /*#__PURE__*/__webpack_require__.n(es6_string_ends_with);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__(210);
var es6_string_includes_default = /*#__PURE__*/__webpack_require__.n(es6_string_includes);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.flags.js
var es6_regexp_flags = __webpack_require__(211);
var es6_regexp_flags_default = /*#__PURE__*/__webpack_require__.n(es6_regexp_flags);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.match.js
var es6_regexp_match = __webpack_require__(213);
var es6_regexp_match_default = /*#__PURE__*/__webpack_require__.n(es6_regexp_match);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__(214);
var es6_regexp_replace_default = /*#__PURE__*/__webpack_require__.n(es6_regexp_replace);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__(215);
var es6_regexp_split_default = /*#__PURE__*/__webpack_require__.n(es6_regexp_split);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.search.js
var es6_regexp_search = __webpack_require__(216);
var es6_regexp_search_default = /*#__PURE__*/__webpack_require__.n(es6_regexp_search);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.from.js
var es6_array_from = __webpack_require__(217);
var es6_array_from_default = /*#__PURE__*/__webpack_require__.n(es6_array_from);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.of.js
var es6_array_of = __webpack_require__(218);
var es6_array_of_default = /*#__PURE__*/__webpack_require__.n(es6_array_of);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.copy-within.js
var es6_array_copy_within = __webpack_require__(219);
var es6_array_copy_within_default = /*#__PURE__*/__webpack_require__.n(es6_array_copy_within);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find.js
var es6_array_find = __webpack_require__(220);
var es6_array_find_default = /*#__PURE__*/__webpack_require__.n(es6_array_find);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find-index.js
var es6_array_find_index = __webpack_require__(221);
var es6_array_find_index_default = /*#__PURE__*/__webpack_require__.n(es6_array_find_index);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.fill.js
var es6_array_fill = __webpack_require__(222);
var es6_array_fill_default = /*#__PURE__*/__webpack_require__.n(es6_array_fill);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__(82);
var es6_array_iterator_default = /*#__PURE__*/__webpack_require__.n(es6_array_iterator);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.is-finite.js
var es6_number_is_finite = __webpack_require__(223);
var es6_number_is_finite_default = /*#__PURE__*/__webpack_require__.n(es6_number_is_finite);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.is-integer.js
var es6_number_is_integer = __webpack_require__(224);
var es6_number_is_integer_default = /*#__PURE__*/__webpack_require__.n(es6_number_is_integer);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.is-safe-integer.js
var es6_number_is_safe_integer = __webpack_require__(225);
var es6_number_is_safe_integer_default = /*#__PURE__*/__webpack_require__.n(es6_number_is_safe_integer);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.is-nan.js
var es6_number_is_nan = __webpack_require__(226);
var es6_number_is_nan_default = /*#__PURE__*/__webpack_require__.n(es6_number_is_nan);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.epsilon.js
var es6_number_epsilon = __webpack_require__(227);
var es6_number_epsilon_default = /*#__PURE__*/__webpack_require__.n(es6_number_epsilon);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.min-safe-integer.js
var es6_number_min_safe_integer = __webpack_require__(228);
var es6_number_min_safe_integer_default = /*#__PURE__*/__webpack_require__.n(es6_number_min_safe_integer);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.max-safe-integer.js
var es6_number_max_safe_integer = __webpack_require__(229);
var es6_number_max_safe_integer_default = /*#__PURE__*/__webpack_require__.n(es6_number_max_safe_integer);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.acosh.js
var es6_math_acosh = __webpack_require__(230);
var es6_math_acosh_default = /*#__PURE__*/__webpack_require__.n(es6_math_acosh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.asinh.js
var es6_math_asinh = __webpack_require__(231);
var es6_math_asinh_default = /*#__PURE__*/__webpack_require__.n(es6_math_asinh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.atanh.js
var es6_math_atanh = __webpack_require__(232);
var es6_math_atanh_default = /*#__PURE__*/__webpack_require__.n(es6_math_atanh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.cbrt.js
var es6_math_cbrt = __webpack_require__(233);
var es6_math_cbrt_default = /*#__PURE__*/__webpack_require__.n(es6_math_cbrt);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.clz32.js
var es6_math_clz32 = __webpack_require__(234);
var es6_math_clz32_default = /*#__PURE__*/__webpack_require__.n(es6_math_clz32);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.cosh.js
var es6_math_cosh = __webpack_require__(235);
var es6_math_cosh_default = /*#__PURE__*/__webpack_require__.n(es6_math_cosh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.expm1.js
var es6_math_expm1 = __webpack_require__(236);
var es6_math_expm1_default = /*#__PURE__*/__webpack_require__.n(es6_math_expm1);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.fround.js
var es6_math_fround = __webpack_require__(237);
var es6_math_fround_default = /*#__PURE__*/__webpack_require__.n(es6_math_fround);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.hypot.js
var es6_math_hypot = __webpack_require__(239);
var es6_math_hypot_default = /*#__PURE__*/__webpack_require__.n(es6_math_hypot);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.imul.js
var es6_math_imul = __webpack_require__(240);
var es6_math_imul_default = /*#__PURE__*/__webpack_require__.n(es6_math_imul);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.log1p.js
var es6_math_log1p = __webpack_require__(241);
var es6_math_log1p_default = /*#__PURE__*/__webpack_require__.n(es6_math_log1p);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.log10.js
var es6_math_log10 = __webpack_require__(242);
var es6_math_log10_default = /*#__PURE__*/__webpack_require__.n(es6_math_log10);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.log2.js
var es6_math_log2 = __webpack_require__(243);
var es6_math_log2_default = /*#__PURE__*/__webpack_require__.n(es6_math_log2);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.sign.js
var es6_math_sign = __webpack_require__(244);
var es6_math_sign_default = /*#__PURE__*/__webpack_require__.n(es6_math_sign);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.sinh.js
var es6_math_sinh = __webpack_require__(245);
var es6_math_sinh_default = /*#__PURE__*/__webpack_require__.n(es6_math_sinh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.tanh.js
var es6_math_tanh = __webpack_require__(246);
var es6_math_tanh_default = /*#__PURE__*/__webpack_require__.n(es6_math_tanh);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.math.trunc.js
var es6_math_trunc = __webpack_require__(247);
var es6_math_trunc_default = /*#__PURE__*/__webpack_require__.n(es6_math_trunc);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__(248);
var es7_array_includes_default = /*#__PURE__*/__webpack_require__.n(es7_array_includes);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.values.js
var es7_object_values = __webpack_require__(249);
var es7_object_values_default = /*#__PURE__*/__webpack_require__.n(es7_object_values);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.entries.js
var es7_object_entries = __webpack_require__(250);
var es7_object_entries_default = /*#__PURE__*/__webpack_require__.n(es7_object_entries);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__(251);
var es7_object_get_own_property_descriptors_default = /*#__PURE__*/__webpack_require__.n(es7_object_get_own_property_descriptors);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.string.pad-start.js
var es7_string_pad_start = __webpack_require__(252);
var es7_string_pad_start_default = /*#__PURE__*/__webpack_require__.n(es7_string_pad_start);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.string.pad-end.js
var es7_string_pad_end = __webpack_require__(253);
var es7_string_pad_end_default = /*#__PURE__*/__webpack_require__.n(es7_string_pad_end);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.timers.js
var web_timers = __webpack_require__(254);
var web_timers_default = /*#__PURE__*/__webpack_require__.n(web_timers);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.immediate.js
var web_immediate = __webpack_require__(255);
var web_immediate_default = /*#__PURE__*/__webpack_require__.n(web_immediate);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__(256);
var web_dom_iterable_default = /*#__PURE__*/__webpack_require__.n(web_dom_iterable);

// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __webpack_require__(257);
var runtime_default = /*#__PURE__*/__webpack_require__.n(runtime);

// EXTERNAL MODULE: ./src/app/entry.js
var entry = __webpack_require__(258);
var entry_default = /*#__PURE__*/__webpack_require__.n(entry);

// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var jquery = __webpack_require__(91);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// CONCATENATED MODULE: ./src/app/vendor/jquery-no-conflict.js


window.jQuery = window.$ = jquery_default.a;
// EXTERNAL MODULE: ./src/app/vendor/transition.js
var transition = __webpack_require__(259);
var transition_default = /*#__PURE__*/__webpack_require__.n(transition);

// EXTERNAL MODULE: ./src/app/vendor/tooltip.js
var tooltip = __webpack_require__(260);
var tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);

// EXTERNAL MODULE: ./src/app/vendor/popover.js
var popover = __webpack_require__(261);
var popover_default = /*#__PURE__*/__webpack_require__.n(popover);

// EXTERNAL MODULE: ./src/app/vendor/owl-carousel.js
var owl_carousel = __webpack_require__(128);
var owl_carousel_default = /*#__PURE__*/__webpack_require__.n(owl_carousel);

// EXTERNAL MODULE: ./src/app/vendor/royalslider-9.5.1.js
var royalslider_9_5_1 = __webpack_require__(262);
var royalslider_9_5_1_default = /*#__PURE__*/__webpack_require__.n(royalslider_9_5_1);

// EXTERNAL MODULE: ./src/app/vendor/hoverintent-1.8.0.js
var hoverintent_1_8_0 = __webpack_require__(263);
var hoverintent_1_8_0_default = /*#__PURE__*/__webpack_require__.n(hoverintent_1_8_0);

// EXTERNAL MODULE: ./src/app/vendor/sni/sni-aem-patch.js
var sni_aem_patch = __webpack_require__(264);
var sni_aem_patch_default = /*#__PURE__*/__webpack_require__.n(sni_aem_patch);

// EXTERNAL MODULE: ./src/app/vendor/sni/sni-config.js
var sni_config = __webpack_require__(265);
var sni_config_default = /*#__PURE__*/__webpack_require__.n(sni_config);

// EXTERNAL MODULE: ./src/app/vendor/sni/sni-vpc.js
var sni_vpc = __webpack_require__(266);
var sni_vpc_default = /*#__PURE__*/__webpack_require__.n(sni_vpc);

// EXTERNAL MODULE: ./src/app/vendor/sni/sni-util.js
var sni_util = __webpack_require__(267);
var sni_util_default = /*#__PURE__*/__webpack_require__.n(sni_util);

// EXTERNAL MODULE: ./src/app/vendor/sni/sni-metadata.js
var sni_metadata = __webpack_require__(129);
var sni_metadata_default = /*#__PURE__*/__webpack_require__.n(sni_metadata);

// EXTERNAL MODULE: ./src/app/vendor/t3-compat.js
var t3_compat = __webpack_require__(268);
var t3_compat_default = /*#__PURE__*/__webpack_require__.n(t3_compat);

// CONCATENATED MODULE: ./src/app/vendor/index.js














// EXTERNAL MODULE: ./src/app/modules/article-stream.js
var article_stream = __webpack_require__(269);
var article_stream_default = /*#__PURE__*/__webpack_require__.n(article_stream);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/taggedTemplateLiteral.js
var taggedTemplateLiteral = __webpack_require__(270);
var taggedTemplateLiteral_default = /*#__PURE__*/__webpack_require__.n(taggedTemplateLiteral);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(281);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/createClass.js
var createClass = __webpack_require__(282);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// CONCATENATED MODULE: ./src/app/services/logger.js


SNI.Application.addService('logger', function (application) {

  var util = application.getService('utility');
  var debugMode = util.isDebug();
  var devConsole = application.getGlobal('console');

  function output(level, msg, namespace) {
    if (debugMode && devConsole && devConsole[level]) {
      logFormat(msg, namespace);

      devConsole[level].apply ? devConsole[level].apply(devConsole, msg) : devConsole[level](msg);
    }
  }

  function logFormat(args, namespace) {
    var idlen = 30,
        minlen = 5,
        seplen = namespace.length < idlen ? idlen - namespace.length : minlen,
        repeatChar = function repeatChar(chr, times) {
      return new Array(times).join(chr);
    };

    args.unshift('[SNI-CORE] ' + repeatChar(' ', minlen) + ' ' + namespace + ' ' + repeatChar('-', seplen) + '>');
  }

  var Logger = function () {
    function Logger(namespace) {
      classCallCheck_default()(this, Logger);

      this.namespace = namespace;
    }

    createClass_default()(Logger, [{
      key: 'log',
      value: function log() {
        for (var _len = arguments.length, msg = Array(_len), _key = 0; _key < _len; _key++) {
          msg[_key] = arguments[_key];
        }

        output('log', msg, this.namespace);
      }
    }, {
      key: 'warn',
      value: function warn() {
        for (var _len2 = arguments.length, msg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          msg[_key2] = arguments[_key2];
        }

        output('warn', msg, this.namespace);
      }
    }, {
      key: 'error',
      value: function error() {
        for (var _len3 = arguments.length, msg = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          msg[_key3] = arguments[_key3];
        }

        output('error', msg, this.namespace);
      }
    }, {
      key: 'table',
      value: function table() {
        for (var _len4 = arguments.length, msg = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          msg[_key4] = arguments[_key4];
        }

        output('table', msg, this.namespace);
      }
    }]);

    return Logger;
  }();

  return {
    create: function create(namespace) {
      return new Logger(namespace);
    }
  };
});
// EXTERNAL MODULE: ./src/app/services/gigya/account.js
var account = __webpack_require__(136);
var account_default = /*#__PURE__*/__webpack_require__.n(account);

// EXTERNAL MODULE: ./src/app/services/check.js
var services_check = __webpack_require__(33);
var services_check_default = /*#__PURE__*/__webpack_require__.n(services_check);

// CONCATENATED MODULE: ./src/app/services/analytics.js



/**
 * Analytics logic that used window.CQ_Analytics directly is now located in our Adobe DTM library, as of the upgrade of AEM to version 6.1.
 * We're keeping this wrapper module for safety and maintenance reasons.
 */

SNI.Application.addService('analytics', function (application) {
  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */
  var debug = application.getService('logger').create('service.analytics');
  var check = application.getService('check').new(debug);

  var callDynamicPageview = function callDynamicPageview() {
    if (check.exists('SNI.Analytics.track')) {
      SNI.Analytics.track();
    }
  };

  var attachClickTracking = function attachClickTracking(options) {
    if (check.exists('SNI.Analytics.attachClickTracking')) {
      SNI.Analytics.attachClickTracking(options);
    }
  };

  var getValue = function getValue(key) {
    var oldSchoolS = check.exists('s') ? application.getGlobal('s') : false;
    return oldSchoolS ? oldSchoolS[key] : null;
  };

  var setValue = function setValue(key, value) {
    var oldSchoolS = check.exists('s') ? application.getGlobal('s') : false;
    if (oldSchoolS) {
      oldSchoolS[key] = value;
    }
  };

  var getProp = function getProp(index) {
    return getValue('prop' + index);
  };

  var setProp = function setProp(index, value) {
    return setValue('prop' + index, value);
  };

  var getEvar = function getEvar(index) {
    return getValue('eVar' + index);
  };

  var setEvar = function setEvar(index, value) {
    return setValue('eVar' + index, value);
  };

  var legacyPV = function legacyPV() {
    if (check.exists('s.t')) {
      application.getGlobal('s').t();
    }
  };

  var trackPrintEvent = function trackPrintEvent(eventName) {
    if (check.exists('moduleTrack')) {
      debug.log('trackPrintEvent', eventName);
      application.getGlobal('moduleTrack')(window, 'print', 'page print', '0', window.location.href, 'on-page interaction', eventName);
    }
  };

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */
  return {

    callDynamicPageview: callDynamicPageview,
    attachClickTracking: attachClickTracking,
    getValue: getValue,
    setValue: setValue,
    getProp: getProp,
    setProp: setProp,
    getEvar: getEvar,
    setEvar: setEvar,
    legacyPV: legacyPV,
    trackPrintEvent: trackPrintEvent,

    init: function init() {
      debug.warn('.init() is called.  We want to eliminate this.');
    }

  };
});
// CONCATENATED MODULE: ./src/app/services/print.js



SNI.Application.addService('print', function (application) {

  var debug = application.getService('logger').create('services.print');
  var analytics = application.getService('analytics');

  var ready = false;
  var systemPrint = true;

  function init(url, wrappingClass, callback) {
    if (url) {
      fetchAndAppend(url, wrappingClass, function () {
        ready = true;
      });
    } else {
      debug.error('init(): url is not set!');
    }

    bindShortcutKeys(function () {
      invoke('keyboard');
    });

    handlePrintEvents(window, function () {
      invoke('default');
      if (!ready) {
        alert('Please wait until the page has fully loaded before printing.');
      }
    }, function () {
      systemPrint = true;
      //debug.log(`afterprint: systemPrint is reverted to ${systemPrint.toString()}`);
    });
  }

  function invoke(initiator, e) {
    var printEvent = false;
    switch (initiator) {
      case 'mouse':
        printEvent = 'printer button';
        if (ready) {
          //if the external page is ready, let's print, otherwise allow the print button's normal link behavior to take over.
          e.preventDefault();
          systemPrint = false;
          window.print();
        }
        break;
      case 'keyboard':
        systemPrint = false;
        printEvent = 'print shortcut key';
        break;
      default:
        if (systemPrint) {
          printEvent = 'file print';
        }
        break;
    }
    if (printEvent) {
      analytics.trackPrintEvent(printEvent);
    }
  }

  function fetchAndAppend(url, wrappingClass, callback) {
    //fetch an html document, then append its <body> content to the current page, sans script tags.
    //this newly appended content is invisible to screen, visible to print media, while the normal page content is invisible to print media.
    $.ajax(url, {
      success: function success(response) {
        var markup = response.match(/<body[^\>]*>((.|\s)*)<\/body>/gm);
        markup = markup && markup.length ? markup[0].replace(/<script[^\>]*>(.|\s)*<\/script>/g, '') : false;
        if (markup) {
          debug.log('successfully fetched markup from ' + url);
          $('body > :not(script,style)').addClass('print-service-hide-onprint');
          $('body').append('\n              <style>\n              @media print {\n                .print-service-hide-onprint {\n                  display: none;\n                }\n              }\n              @media screen {\n                .print-service-hide-onscreen {\n                  display: none;\n                }\n              }\n              </style>\n              <div class="print-service-hide-onscreen ' + wrappingClass + '">\n                ' + markup + '\n              </div>\n            ');
          if (typeof callback === 'function') {
            callback();
          }
        } else {
          debug.error('failed to parse markup from ' + url);
        }
      },
      error: function error() {
        debug.error('failed to fetch markup from ' + url);
      }
    });
  }

  function handlePrintEvents(win, b, a) {
    var app = application.getGlobal('SNI');
    var before = initCallback(b);
    var after = initCallback(a);
    function initCallback(inf) {
      if (typeof inf === 'function') {
        return function () {
          var args = Array.prototype.slice.call(arguments);
          inf.apply(this, args);
        };
      }
    }

    if (typeof win.onbeforeprint !== 'undefined') {
      if (typeof before === 'function' && typeof win.onbeforeprint !== 'function') {
        win.onbeforeprint = before;
      }
      if (typeof after === 'function' && typeof win.onafterprint !== 'function') {
        win.onafterprint = after;
      }
    } else {
      if (win.matchMedia) {
        if (!app.mediaQueryListBinding) {
          var mediaQueryList = win.matchMedia('print');
          mediaQueryList.addListener(function (mql) {
            if (mql.matches) {
              if (typeof before === 'function') {
                before.apply(win);
              }
            } else if (typeof after === 'function') {
              after.apply(win);
            }
          });
          app.mediaQueryListBinding = true;
        }
      }
    }
  }

  function bindShortcutKeys(callback) {
    //allows us to capture command+p and/or control+p so that if a user tries to print, let's simulate a click on our print button for an optimized print experience.
    $(window).keydown(function (e) {
      if ((e.metaKey || e.ctrlKey) && e.keyCode === 80) {
        /*ctrl+p or command+p*/
        if (typeof callback === 'function') {
          callback();
        }
      }
    });
  }

  /*
  // based on example code from https://developer.mozilla.org/en-US/docs/Web/Guide/Printing
  function closePrint() {
    document.body.removeChild(this.__container__);
    window.focus();
  }
    function setPrint() {
    var iframe = this;
    iframe.contentWindow.__container__ = iframe;
    iframe.contentWindow.onbeforeunload = closePrint;
    handlePrintEvents(iframe.contentWindow, false, closePrint);
    try {
      //IE
      var result = iframe.contentWindow.document.execCommand('print', false, null);
      if (!result) iframe.contentWindow.print();
    } catch (e) {
      iframe.contentWindow.print();
    }
  }
    function printExternalPage(sURL) {
    debug.log(`printExternalPage("${sURL}")`);
    var oHiddFrame = document.createElement('iframe');
    oHiddFrame.onload = setPrint;
    oHiddFrame.style.visibility = 'hidden';
    oHiddFrame.style.position = 'fixed';
    oHiddFrame.style.right = '0';
    oHiddFrame.style.bottom = '0';
    oHiddFrame.src = sURL;
    document.body.appendChild(oHiddFrame);
  }
  */

  return {
    init: init,
    invoke: invoke,
    bindShortcutKeys: bindShortcutKeys
  };
});
// EXTERNAL MODULE: ./src/app/services/device-type.js
var device_type = __webpack_require__(34);
var device_type_default = /*#__PURE__*/__webpack_require__.n(device_type);

// CONCATENATED MODULE: ./src/app/modules/asset-actions.js


var _templateObject = taggedTemplateLiteral_default()(['?assetId=', '&gigyaUserId=', '&signatureTimestamp=', '&uidSignature=', ''], ['?assetId=', '&gigyaUserId=', '&signatureTimestamp=', '&uidSignature=', '']);






/*
 * Saves the recipe or opens the print dialog on click.
 */
SNI.Application.addModule('asset-actions', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var mdManager = context.getGlobal('mdManager');
  var detailId = mdManager.getDetailId();
  var parentEl = context.getElement();
  var mName = 'asset-actions';
  var debug = context.getService('logger').create('module.' + mName);
  var gigyaService = context.getService('gigya/account');
  var print = context.getService('print');
  var device = context.getService('device-type');

  var $saveButton = $(parentEl).find('[data-type="save-recipe"]');
  var savedText = 'Saved Recipe';
  var config = void 0,
      saveRecipeUrl = void 0,
      recipeStatusUrl = void 0;

  var defaults = {
    saveRecipeUrl: 'http://recipes.foodnetwork.com/api/box/item/save',
    recipeStatusUrl: 'http://recipes.foodnetwork.com/api/box/isSaved'
  };

  /**
   * URI encode the query string to pass to My Recipe Box.
   * @param {array} templateData Array of all the string parts of the template
   * @returns {string} URI encoded query string
   * @private
   */
  function uriEncodeString(templateData) {
    var s = templateData[0];

    for (var i = 1; i < arguments.length; i++) {
      var arg = String(arguments[i]);

      // Encode special characters in the substitution.
      s += encodeURIComponent(arg);

      // Don't escape special characters in the template.
      s += templateData[i];
    }

    return s;
  }

  /**
   * Build the query string to pass to My Recipe Box.
   * @param {string} detailId Detail id for the recipe
   * @param {object} accountInfo Gigya user account info
   * @returns {string} Query string to pass to MRB
   * @private
   */
  function getQueryString(detailId, accountInfo) {
    var gigyaUserId = accountInfo.UID;
    var signatureTimestamp = accountInfo.signatureTimestamp;
    var uidSignature = accountInfo.UIDSignature;

    return uriEncodeString(_templateObject, detailId, gigyaUserId, signatureTimestamp, uidSignature);
  }

  /**
   * Callback for Gigya getAccountInfo method.
   * @param {object} xhrOptions Xhr options
   * @param {number} errorCode Error code
   * @param {string} errorMessage Error message
   * @private
   */
  function gigyaCallback(xhrOptions, errorCode, errorMessage) {
    if (errorCode === 0) {
      $.ajax(xhrOptions);
    } else {
      debug.log(errorMessage);
    }
  }

  function setSavedState() {
    $saveButton.removeClass('a-Button--Save').addClass('a-Button--Saved').attr('disabled', 'disabled').removeAttr('data-type').html('<span class="a-Button--Saved__a-TextWrap">' + savedText + '</span>');
  }

  var messageHandlers = {
    'gigya.isloggedIn.asset-actions:init': function gigyaIsloggedInAssetActionsInit(res) {
      gigyaCallback({
        url: recipeStatusUrl + getQueryString(detailId, res),
        success: function success(resp) {
          // update the button to say 'Saved Recipe!'
          if (resp[detailId].isSaved) {
            setSavedState();
          }
        },
        error: function error(jqXHR, resp, err) {
          debug.error('gigya.isloggedIn.asset-actions:init', arguments);
        }
      }, res.errorCode, res.errorMessage);
    },
    'gigya.isloggedIn.asset-actions:save': function gigyaIsloggedInAssetActionsSave(res) {
      gigyaCallback({
        url: saveRecipeUrl + getQueryString(detailId, res),
        success: function success(resp) {
          // update the button to say 'Saved Recipe!'
          if (resp[detailId].isSaved) {
            setSavedState();
          }
        },
        error: function error(jqXHR, resp, err) {
          debug.error('gigya.isloggedIn.asset-actions:save', arguments);
        }
      }, res.errorCode, res.errorMessage);
    },
    'gigya.isloggedOut.asset-actions:save': function gigyaIsloggedOutAssetActionsSave() {
      gigyaService.showLoginScreen(true, false, '');
    }
  };

  function configSaveRecipeUrl() {
    if (config.saveRecipeUrl) {
      saveRecipeUrl = config.saveRecipeUrl;
    }
    if (config.recipeStatusUrl) {
      recipeStatusUrl = config.recipeStatusUrl;
    }
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    // behaviors: ['popup'],

    messages: Object.keys(messageHandlers),

    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },

    onclick: function onclick(event, element, elementType) {

      switch (elementType) {
        case 'save-recipe':
          event.preventDefault();

          gigyaService.isLoggedIn('.' + mName + ':save');

          break;

        case 'print':
          print.invoke('mouse', event);
          break;

        default:
          break;
      }
    },
    init: function init() {
      debug.log('init');
      config = Object.assign({}, defaults, context.getConfig());

      configSaveRecipeUrl();

      if (!device.isMobile) {
        print.init($('[data-type="print"]').attr('href'), 'recipePrint');
      }

      gigyaService.isLoggedIn('.' + mName + ':init');
    },


    uriEncodeString: uriEncodeString,

    getQueryString: getQueryString,

    gigyaCallback: gigyaCallback,

    recipeStatusUrl: recipeStatusUrl,

    saveRecipeUrl: saveRecipeUrl,

    setSavedState: setSavedState
  };
});
// EXTERNAL MODULE: ./src/app/modules/asset-label.js
var asset_label = __webpack_require__(285);
var asset_label_default = /*#__PURE__*/__webpack_require__.n(asset_label);

// EXTERNAL MODULE: ./src/app/modules/asset-multi-media.js
var asset_multi_media = __webpack_require__(286);
var asset_multi_media_default = /*#__PURE__*/__webpack_require__.n(asset_multi_media);

// EXTERNAL MODULE: ./src/app/modules/asset-navigation.js
var asset_navigation = __webpack_require__(287);
var asset_navigation_default = /*#__PURE__*/__webpack_require__.n(asset_navigation);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(137);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// CONCATENATED MODULE: ./src/app/modules/calendar.js

SNI.Application.addModule('calendar', function (context) {

  var $element = $(context.getElement()),
      debug = context.getService('logger').create('module.calendar');

  var defaults = {
    format: 'YYYY.MM.DD'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  function getDateFromPath() {
    var d = document.location.pathname.match(/.*tv-schedule[\.\-](\d\d\d\d\.\d\d\.\d\d)\..*/);
    return d === null ? d : d[1];
  }

  return {

    config: config,

    init: function () {
      var _ref = asyncToGenerator_default()(regeneratorRuntime.mark(function _callee() {
        var Pikaday, moment, picker, seldate, dateFromPath;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 453));

              case 2:
                Pikaday = _context.sent;
                _context.next = 5;
                return __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 310));

              case 5:
                moment = _context.sent;


                debug.log('calendar init');
                picker = void 0;


                picker = new Pikaday({
                  firstDay: 0,
                  field: $element[0],
                  showDaysInNextAndPreviousMonths: true,
                  onSelect: function onSelect() {
                    // change path to selected date--if it isn't that already
                    var path = $element.data('path'),
                        pattern = $element.data('pattern'),
                        url = '';
                    var dateFromPath = getDateFromPath();
                    var formatedDate = this.getMoment().format(config.format);
                    debug.log('user selected date: ' + formatedDate);
                    debug.log('current schedule date: ' + dateFromPath);
                    // rewrite location only if different (today is null)
                    if (formatedDate === dateFromPath || dateFromPath === null && formatedDate === moment().format(config.format)) debug.log('selected date already loaded');else {
                      debug.log('loading schedule for: ' + formatedDate);
                      if (path !== undefined && pattern !== undefined) {
                        url = path.replace(pattern, formatedDate);
                      }
                      //update input value with formatted date
                      $element.val(formatedDate);
                      //if path and pattern are provided then trigger url;
                      if (url !== '') {
                        document.location = url;
                      }
                    }
                  }
                });
                // setting the selected date class allows styling
                seldate = picker.getMoment(); // selected date is today if not explicit in path

                dateFromPath = getDateFromPath();

                if (dateFromPath !== null) seldate = moment(dateFromPath, 'YYYY.MM.DD');
                debug.log('selected date ' + seldate.format('YYYY-MM-DD'));
                picker.setMoment(seldate, true);
                debug.log(picker);

              case 15:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _ref.apply(this, arguments);
      }

      return init;
    }()

  };
});
// CONCATENATED MODULE: ./src/app/modules/carousel.js





SNI.Application.addModule('carousel', function (context) {

  // Private

  var debug = context.getService('logger').create('module.carousel');
  var check = context.getService('check').new(debug);
  var util = context.getService('utility');
  var percentVisible = util.percentVisible;
  var deviceType = context.getService('device-type');
  if (!check.jqueryPlugin('owlCarousel')) return {};

  var defaults = {
    startPosition: 0,
    loop: false,
    items: 1,
    margin: 0,
    lazyLoad: true,
    navigation: false,
    pagination: false,
    mouseDrag: false,
    thumbnails: false,
    superTheme: false,
    videoEmbed: false,
    autoplay: false,
    smartSpeed: 500,
    itemsPerPage: 3,
    totalItems: null, // the total number of items (not necessarily slides) in the carousel
    slidesPerPage: 3, // the number of slides that fit in a "page" when doing pagination

    selectors: {
      carouselContainer: '.carousel-container',
      moduleSelector: '[data-module="carousel"]',
      playListContainer: '.o-VideoPlaylistPromo__m-Carousel',
      slide: '[data-slide]',
      slideText: '.slide-text',
      activeClass: 'active',
      activeSlide: '.block.active, .block-text-right.active',
      thumbEmbedClass: 'thumbnail-embed',
      thumbImgClass: 'thumbnail-img',
      pagination: {
        all: '.playlist-pagination, .custom-pagination',
        custom: '.custom-pagination',
        count: '.pagination-count span',
        superLeadThemed: {
          navItem: '.super-lead-theme-pagination .block'
        },
        buttons: {
          next: '.nav-next',
          prev: '.nav-prev',
          both: '.nav-prev, .nav-next'
        }
      }
    }
  };
  var settings = context.getConfig();
  var config = $.extend(true, {}, defaults, settings);
  var selectors = config.selectors;

  // set the current context element as the carousel Wrapper

  var $carouselWrapper = $(context.getElement());
  var $carouselContainer = $carouselWrapper.find(selectors.carouselContainer);
  var $playListContainer = $carouselWrapper.closest(selectors.playListContainer);
  var $navNext = $carouselWrapper.find(selectors.pagination.buttons.next);
  var $navPrev = $carouselWrapper.find(selectors.pagination.buttons.prev);
  var $slideText = $carouselWrapper.find(selectors.slideText);
  var $pagination = $carouselWrapper.find(selectors.pagination.custom);
  if ($pagination.length === 0) $pagination = $carouselWrapper.next(selectors.pagination.custom);

  if ($playListContainer.length && !$navNext.length) {
    $pagination = $playListContainer.find(selectors.pagination.all).first();
    $navNext = $pagination.find(selectors.pagination.buttons.next);
    $navPrev = $pagination.find(selectors.pagination.buttons.prev);
  }

  function isStarted(element) {
    return context.application.isStarted(element);
  }

  function otherModules() {
    var $modules = $(config.selectors.moduleSelector).filter(function (i, e) {
      return isStarted(e);
    });
    return $modules;
  }

  function isMostVisible($modules, $carousel, $wrapper) {
    var openModal = $modules.parents('.o-Modal').length;
    var parentModal = $carousel.parents('.o-Modal').length;
    if (openModal > 0) {
      return parentModal > 0; // We are in a modal - we are the most visible
    } else {
      var wrapper = $wrapper.get(0);
      var $otherMods = $modules.not(wrapper);
      return visiblity(wrapper, $otherMods); // compare current visibility to other modules visibility
    }
  }

  function highestVisibility(arr) {
    arr.sort(function (a, b) {
      return a - b;
    });
    return arr.shift();
  }

  function visiblity(carousel, $modules) {
    var currentPct = percentVisible(carousel);

    var isHigher = false;
    var pcts = [];
    $modules.each(function (i, el) {
      var elPct = percentVisible(el);
      pcts.push(elPct);
    });
    var highest = highestVisibility(pcts); // Get the most visible element from all the other carousels on the page (which can be many, hence the array)
    isHigher = currentPct > highest;
    return isHigher;
  }

  function bindOwlInit() {

    setOwlDots();

    $carouselContainer.on('initialized.owl.carousel', function (event) {
      debug.log('initialized.owl.carousel fired');

      var slidePageIndex = event.page.index;
      var currentId = $(context.getElement()).attr('id');
      updatePagination(slidePageIndex, config.totalItems);
      context.broadcast('carousel.loaded', {
        carouselId: currentId
      });
    });
  }

  function setOwlDots() {
    if (config.itemsPerPage && config.totalItems !== null) {
      if (config.totalItems <= config.itemsPerPage) {
        config.dots = false;
      }
    }
  }

  function broadcastOwlTranslation() {
    $carouselContainer.on('change.owl.carousel', function (event) {
      var currentId = $(context.getElement()).attr('id');
      context.broadcast('carousel.changing', {
        carouselId: currentId
      });
    });

    $carouselContainer.on('changed.owl.carousel', function (event) {
      var currentIndex = event.item.index;
      context.broadcast('carousel.indexUpdated', {
        updatedIndex: currentIndex
      });
    });

    $carouselContainer.on('translated.owl.carousel', function (event) {
      var currentSlide = $carouselContainer.find('.' + selectors.activeClass).find(selectors.slide).data('slide');
      var currentId = $(context.getElement()).attr('id');
      context.broadcast('carousel.slideUpdated', {
        updatedSlide: currentSlide,
        carouselId: currentId
      });
    });
  }

  function updatePagination(slidePageIndex, itemCount) {
    var itemsPerPage = void 0,
        totalItems = void 0,
        pageRangeStart = void 0,
        pageRangeEnd = void 0;

    itemsPerPage = config.itemsPerPage;
    totalItems = config.totalItems;

    // calculates numbers to do things like: "showing 3 of 6"
    // pageRangeEnd ternary is used to prevent from exceeding the maximum length
    pageRangeStart = slidePageIndex * itemsPerPage + 1;
    pageRangeEnd = slidePageIndex * itemsPerPage + itemsPerPage < totalItems ? slidePageIndex * itemsPerPage + itemsPerPage : totalItems;
    $pagination.find('> div > a').data('slide-index', slidePageIndex);
    $pagination.find(selectors.pagination.count).eq(0).text(pageRangeStart + ' - ' + pageRangeEnd);

    if (config.loop === false) {
      // clear current disabled attributes
      $carouselWrapper.find(selectors.pagination.buttons.both).removeAttr('disabled');

      // disable next or previous links when appropriate
      if (slidePageIndex === 0) {
        $carouselWrapper.find(selectors.pagination.buttons.prev).attr('disabled', 'disabled');
      } else if (slidePageIndex === itemCount - 1) {
        $carouselWrapper.find(selectors.pagination.buttons.next).attr('disabled', 'disabled');
      }
    }
  }

  // TODO: Verifiy this is working correctly
  // Seems to work correctly based on my initial smoke test
  function initThumbnails() {
    debug.log('initThumbnails started');

    $carouselWrapper.addClass(selectors.thumbEmbedClass);

    $.each($carouselContainer.find('.owl-item'), function (i, element) {

      $carouselContainer.find('.owl-controls .owl-dot').eq(i).append('<div class="' + selectors.thumbImgClass + '" />').find('.' + selectors.thumbImgClass).css({
        'background': 'url(' + $(element).find('img').attr('data-src') + ') center center no-repeat',
        '-webkit-background-size': 'cover',
        '-moz-background-size': 'cover',
        '-o-background-size': 'cover',
        'background-size': 'cover'
      });
    });
  }

  // TODO: Verifiy this is working correctly
  // Seems to work correctly based on my initial smoke test
  function initSuperTheme() {
    var target = selectors.pagination.superLeadThemed;

    // on change pagination gets active class
    $carouselContainer.on('changed.owl.carousel', function (event) {
      var slideIndex = event.page.index;
      $carouselWrapper.find(target.navItem).removeClass(selectors.activeClass).eq(slideIndex).addClass(selectors.activeClass);
    });

    var timer = void 0;

    // on mouseenter change slide
    $carouselWrapper.find(target.navItem).on('mouseenter', function (event) {
      var $this = $(event.currentTarget);

      timer = setTimeout(function () {
        $this.siblings().removeClass(selectors.activeClass).eq($this.index()).addClass(selectors.activeClass);
        goToSlide($this.index());
        stopAutoPlay();
      }, 500);
    });

    $carouselWrapper.find(target.navItem).on('mouseleave', function (event) {
      clearTimeout(timer);
    });
  }

  function bindVideoEmbedPagination() {

    var slidePageIndex = 0;

    $carouselWrapper.on('changed.owl.carousel', function (event) {

      slidePageIndex = event.page.index;

      updatePagination(slidePageIndex, event.item.count);
    });

    $pagination.find(selectors.pagination.buttons.both).on('click', function (event) {
      var $this = $(event.currentTarget);
      if ($this.is(selectors.pagination.buttons.next)) {
        nextSlide();
      } else if ($this.is(selectors.pagination.buttons.prev)) {
        prevSlide();
      }
    });
  }

  function bindArrowKeys(e) {
    var keyCode = e.keyCode;
    // handle cursor keys
    if (keyCode === 37) {
      // go left
      prevSlide(e);
    } else if (keyCode === 39) {
      // go right
      nextSlide(e);
    }
  }

  function bindEvents() {
    debug.log('bindEvents Start');

    if (deviceType.isMobile) {

      $slideText.on('touchend', function () {
        setHeight($slideText);
      });

      window.addEventListener('orientationchange', function () {

        setTimeout(function () {
          setHeight($slideText);
        }, 200);
      });
    } else {
      $navNext.off('click').on('click', function () {
        nextSlide();
      });
      $navPrev.off('click').on('click', function () {
        prevSlide();
      });

      $(document.documentElement).keyup(bindArrowKeys);
    }

    debug.log('Events Bound');
  }

  /**
   * Determine if there are other competing keyboard event handlers and skip current event or allow it to continue with slide event
   */
  function handleSlideEvent(e, eventType) {
    if (e) {
      // When no event is passed then we are handling a click and we can bypass these checks
      var $otherModules = otherModules();
      if ($otherModules.length > 1) {
        // If there's other modules present then we have to determine if we are the most visible
        var isMost = isMostVisible($otherModules, $carouselContainer, $carouselWrapper);
        if (isMost) {
          e.stopImmediatePropagation();
        } else {
          return false;
        }
      }
    }
    $carouselContainer.trigger(eventType);
  }

  function nextSlide(e) {
    // e = keyboardEvent
    debug.log('nextSlide() called');
    handleSlideEvent(e, 'next.owl.carousel'); //  If this carousel should not i
  }

  function prevSlide(e) {
    // e = keyboardEvent
    debug.log('prevSlide() called');
    handleSlideEvent(e, 'prev.owl.carousel');
  }

  function goToSlide(pos) {
    $carouselContainer.trigger('to.owl.carousel', pos);
  }

  function stopAutoPlay() {
    $carouselContainer.trigger('stop.owl.autoplay');
  }

  function goToActiveSlide() {
    // when meta data updates its trigger a slide change
    var slideIndex = $carouselContainer.find(selectors.activeSlide).parents('.owl-item').index();
    if (slideIndex > -1) {
      goToSlide(slideIndex);
    }
  }

  function setHeight($sText) {
    var tallest = 0;

    $sText.each(function (i, element) {
      var $this = $(element);

      $this.outerHeight('auto');
      if ($this.outerHeight() > tallest) {
        tallest = $this.outerHeight();
      }
    });

    $sText.each(function (i, element) {
      if (tallest !== 0) {
        $(element).outerHeight(tallest);
      }
    });
  }

  function setNowPlaying(videoNum) {
    debug.log('Setting video ' + videoNum + ' as the one playing');
    $carouselWrapper.find('[data-vid-num]').removeClass('is-Active');
    $carouselWrapper.find('[data-vid-num=' + videoNum + ']').addClass('is-Active');
  }

  // public

  var module = {

    config: config,

    init: function init() {
      debug.log('Init Start');

      bindOwlInit();
      debug.log('Owl Init Bound');

      // initialize the carousel
      $carouselContainer.owlCarousel(config);
      debug.log('Owl Carousel initialized');

      //
      if (config.thumbnails) {
        initThumbnails();
        debug.log('Thumbnail Initialized');
      }

      // custom for super theme lead implementation
      // desktop only
      if (config.superTheme) {
        initSuperTheme($carouselWrapper);
        debug.log('Super Theme Initialized');
      }

      // if video embed or video overlay
      if (config.videoEmbed) {
        bindVideoEmbedPagination();
        debug.log('Video Embed Events Bound');
      }

      if (deviceType.isMobile) {
        setHeight($slideText);
        debug.log('Mobile Initialized');
      }

      bindEvents();
      broadcastOwlTranslation();
      debug.log('Carousel Module: Events Bound');

      debug.log('Init End');
    },

    destroy: function destroy() {
      if ($carouselContainer && $carouselContainer.owlCarousel) {
        debug.log('Clean up of owl carousel');
        $carouselContainer.trigger('destroy.owl.carousel');
      }
      $(document.documentElement).off('keyup', bindArrowKeys);
    },

    messages: ['update.metadata', 'carousel.update.slide'],

    behaviors: ['truncate'],

    onmessage: {
      'update.metadata': function updateMetadata(data) {
        goToActiveSlide();
        setNowPlaying(data);
      },
      'carousel.update.slide': function carouselUpdateSlide(data) {
        if (data.carouselId && data.carouselId === $(context.getElement()).attr('id')) {
          goToSlide(data.index);
        }
      }
    },

    onclick: function onclick(event, element, elementType) {
      debug.log('clicked on a ' + elementType);
      switch (elementType) {
        case 'slide':
          context.broadcast('carousel.slide.clicked', {
            id: $carouselWrapper.attr('id'),
            slide: element
          });
          break;
        case 'next-item':
          if (deviceType.isMobile) {
            nextSlide();
          }
          break;
        case 'previous-item':
          if (deviceType.isMobile) {
            prevSlide();
          }
          break;
      }
    }
  };

  return module;
});
// EXTERNAL MODULE: ./src/app/modules/collage.js
var collage = __webpack_require__(311);
var collage_default = /*#__PURE__*/__webpack_require__.n(collage);

// EXTERNAL MODULE: ./src/app/modules/content-feed.js
var content_feed = __webpack_require__(312);
var content_feed_default = /*#__PURE__*/__webpack_require__.n(content_feed);

// EXTERNAL MODULE: ./src/app/modules/dropdown-filter.js
var dropdown_filter = __webpack_require__(313);
var dropdown_filter_default = /*#__PURE__*/__webpack_require__.n(dropdown_filter);

// EXTERNAL MODULE: ./src/app/modules/editorial-promo.js
var editorial_promo = __webpack_require__(314);
var editorial_promo_default = /*#__PURE__*/__webpack_require__.n(editorial_promo);

// EXTERNAL MODULE: ./src/app/modules/engage-sciences.js
var engage_sciences = __webpack_require__(315);
var engage_sciences_default = /*#__PURE__*/__webpack_require__.n(engage_sciences);

// EXTERNAL MODULE: ./src/app/modules/episode-feed.js
var episode_feed = __webpack_require__(316);
var episode_feed_default = /*#__PURE__*/__webpack_require__.n(episode_feed);

// EXTERNAL MODULE: ./src/app/modules/episode-list.js
var episode_list = __webpack_require__(317);
var episode_list_default = /*#__PURE__*/__webpack_require__.n(episode_list);

// EXTERNAL MODULE: ./src/app/modules/footer.js
var footer = __webpack_require__(318);
var footer_default = /*#__PURE__*/__webpack_require__.n(footer);

// EXTERNAL MODULE: ./src/app/modules/full-width-promo.js
var full_width_promo = __webpack_require__(319);
var full_width_promo_default = /*#__PURE__*/__webpack_require__.n(full_width_promo);

// EXTERNAL MODULE: ./src/app/modules/gigya/comments-link.js
var comments_link = __webpack_require__(320);
var comments_link_default = /*#__PURE__*/__webpack_require__.n(comments_link);

// EXTERNAL MODULE: ./src/app/modules/gigya/comments.js
var comments = __webpack_require__(321);
var comments_default = /*#__PURE__*/__webpack_require__.n(comments);

// EXTERNAL MODULE: ./src/app/modules/gigya/loginReg.js
var loginReg = __webpack_require__(322);
var loginReg_default = /*#__PURE__*/__webpack_require__.n(loginReg);

// EXTERNAL MODULE: ./src/app/modules/gigya/profile.js
var profile = __webpack_require__(323);
var profile_default = /*#__PURE__*/__webpack_require__.n(profile);

// EXTERNAL MODULE: ./src/app/modules/gigya/ratings.js
var ratings = __webpack_require__(324);
var ratings_default = /*#__PURE__*/__webpack_require__.n(ratings);

// EXTERNAL MODULE: ./src/app/modules/header-mobile.js
var header_mobile = __webpack_require__(325);
var header_mobile_default = /*#__PURE__*/__webpack_require__.n(header_mobile);

// EXTERNAL MODULE: ./src/app/modules/header.js
var header = __webpack_require__(326);
var header_default = /*#__PURE__*/__webpack_require__.n(header);

// EXTERNAL MODULE: ./src/app/modules/how-to.js
var how_to = __webpack_require__(327);
var how_to_default = /*#__PURE__*/__webpack_require__.n(how_to);

// EXTERNAL MODULE: ./src/app/modules/image-embed.js
var image_embed = __webpack_require__(328);
var image_embed_default = /*#__PURE__*/__webpack_require__.n(image_embed);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(14);
var helpers_typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// CONCATENATED MODULE: ./src/app/modules/inline-gallery.js

SNI.Application.addModule('inline-gallery', function (context) {
  'use strict';

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var module = void 0,
      $galleryElement = void 0,
      galleryContainer = void 0,
      detailsContainer = void 0,
      slider = void 0,
      config = {},
      deviceType = void 0,
      debug = context.getService('logger').create('module.inline-gallery'),
      check = context.getService('check').new(debug),
      adLib = void 0,
      template = void 0,
      metadata = void 0,
      analytics = void 0,
      mediaStream = void 0,
      router = void 0,
      coldLoad = void 0,
      instance = void 0,
      defaults = void 0;

  var ll = context.getService('lazy-load');

  if (!check.jqueryPlugin('royalSlider')) return {};

  var SniAds = context.getGlobal('SniAds');
  coldLoad = true;
  defaults = {
    galleryType: 'dynamic',
    galleryViewType: 'inline',
    newTemplate: false,
    ajaxUrl: '',
    ajaxStayAhead: 3,
    ajaxFetchNumSlides: 10,
    ajaxPaging: false,
    ajaxImagesPerPage: 18,
    readyToFetchMore: true,
    adLibLoaded: false,
    coldLoad: true,
    pageTitle: '',
    pvHoverTime: '',
    galleryLoadingClass: 'loading',
    galleryAdSetup: {
      container: '.pv-content-wrapper',
      dismiss_elts: '.rsArrowIcn',
      disable_elts: '',
      blockDelay: 10
    },
    galleryContainer: '.slideshow-wrapper',
    detailsContainer: '.details-wrapper',
    nextClass: '[data-type="open-next-gallery"]',
    blurClass: 'm-NextAsset--blur',
    nextLink: '[data-type="open-next-gallery"] a',
    hotspot: true,
    previousPageNumber: true,
    previousArrowSelector: '.rsArrowLeft',
    nextArrowSelector: '.rsArrowRight',
    arrowDisabledSelector: '.rsArrowDisabled',
    rightDataType: 'increment-slide',
    leftDataType: 'decrement-slide',
    backNavPercent: 20,
    galleryStartingPosition: 0,
    overlayBigboxName: '',
    overlayPhotoIntName: '',
    overlayPhotoIntMobileName: '',
    interstitialShownClass: '.interstitial-show',
    interstitialClass: 'interstitial-shown',
    showTraySpan: '<span></span>',
    dynamicGalleryWrapper: '',
    onboardingTimeout: 5500,
    nextGalleryTimeout: 4000,
    hotspotUrl: window.location.pathname,
    hotspotElement: 'img.rsMainSlideImage',
    hotspotUrlName: 'hotspotUrl',
    rsOverflowCon: '.rsOverflow',
    pvSlideWrapCon: '.pv-slideshow-wrapper',
    pvContentWrapper: '.pv-content-wrapper',
    pvPhotoWrapCon: '.pv-photo-wrapper',
    pvDetailsWrapCon: '.m-AssetDataWrap',
    pvProductsWrapCon: '.m-ProductListWrap',
    pvSlideSelector: '.m-Slide',
    pvDetailsSelector: '.m-AssetData',
    pvProductListSelector: '.product-placeholder',
    pvDetailsArray: '',
    pvProductListArray: '',
    pvDropdownItems: '.pv-pl-nav-dropdown.dropdown-filter .dropdown-menu ul.inner li a',
    adWrapperElements: {
      galleryContent: '.o-Article__m-Content',
      galleryAside: '.o-Article__m-Aside',
      stage: '.o-Article__m-Body'
    },
    footerElement: '.o-Article__m-Footer',
    nextUpElements: {
      nextUpSelector: '.o-Article__m-Footer .nextUp',
      nextUpBlock: '.o-Article__m-Footer .nextUp .m-MediaBlock',
      nextUpContainer: '.nextUp'
    },
    timers: {},
    launchMeContainer: '.rsContainer',
    launchMeWrapper: '.o-PhotoGalleryPromo__m-VisualCta',
    launchMeText: '.m-VisualCtaTextWrap',
    launchMePhotoCount: '.a-CtaTextSecondary',
    xDown: null,
    yDown: null,
    swipeDir: '',
    secondPass: false,
    lastCloned: false,
    allowPV: true,
    mediaStream: '',
    galleryTitle: '',
    qString: '',
    weRecommend: '.weRecommend',
    weRecommendWidth: 0,
    nextUp: '.nextUp',
    sliderMessages: {
      afterSlideName: 'gallery.afterSlide',
      beforeAnimName: 'gallery.beforeAnimation',
      beforeSizeName: 'gallery.beforeSizeSet',
      afterContentSetName: 'gallery.afterContentSet'
    },
    originalGallery: 0,
    consecutiveGallery: 1,
    rsConfig: {
      autoHeight: false,
      autoScaleSlider: false,
      imageAlignCenter: false,
      globalCaption: false,
      fadeinLoadedSlide: false,
      arrowsNav: true,
      arrowsNavAutoHide: false,
      arrowsNavHideOnTouch: false,
      controlNavigation: 'none',
      controlsInside: true,
      imageScalePadding: 0,
      transitionSpeed: 0,
      transitionType: 'move',
      loop: true,
      addActiveClass: true,
      deeplinking: {
        change: false,
        enabled: true,
        prefix: 'photo-'
      },
      fullscreen: {
        enabled: false,
        buttonFS: false,
        nativeFS: true
      },
      keyboardNavEnabled: false,
      numImagesToPreload: 2,
      navigateByClick: false,
      imageScaleMode: 'fit-if-smaller',
      sliderDrag: false,
      sliderTouch: false,
      easeOut: 'linear',
      preloaderHTML: ''
    }
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setGalleryConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function setPreloaderHTML(markup) {
    config.rsConfig.preloaderHTML = markup;
  }

  function getServices(currentContext) {
    deviceType = currentContext.getService('device-type');
    template = currentContext.getService('template');
    metadata = currentContext.getService('metadata');
    analytics = currentContext.getService('analytics');
    mediaStream = currentContext.getService('media-stream');
    router = currentContext.getService('router');
  }

  function updateConsecutiveGallery(currentContext, metadataService, data) {
    if (!isNaN(parseInt(data.consecutiveGallery)) && !isNaN(parseInt(data.originalGallery))) {
      debug.log('updateConsecutiveGallery: data: ', data);
      metadataService.setGalleryData(data);
      currentContext.broadcast('gallerydataupdated', data);
    }
  }

  function setOnboardingTimeout(currentContext, isMobile) {
    if (isMobile) {
      currentContext.broadcast('gallerydataupdated', {
        onboardingTimeout: 4000
      });
    }
  }

  function extractData(content) {
    var go = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.secondPass;


    var src = $('img.rsMainSlideImage', content).attr('src');
    return {
      imageURL: src,
      proceed: go,
      element: $(content)
    };
  }

  function setAjaxConfig(currentContext, ajaxUrl, paging, isMobile, searchPage) {
    var url = void 0,
        page = void 0;

    if (paging) {
      if (isMobile) {
        page = searchPage || 1;
        currentContext.broadcast('gallerydataupdated', {
          ajaxPageWeAreOn: page
        });
      } else {
        url = ajaxUrl || window.location.href;
        page = url.substring(url.lastIndexOf('/p/')).split('/p/')[1] || '';
        page = page.split('?')[0];
        if (typeof page === 'undefined' || typeof parseInt(page) !== 'number' || page === '') {
          page = 1;
        }
        currentContext.broadcast('gallerydataupdated', {
          ajaxPageWeAreOn: page
        });
      }
    }
  }

  function updateCurrentPhotoSearchPage(currentContext, data) {
    currentContext.broadcast('gallerydataupdated', {
      currentSearchResultsPage: data.currentSearchResultsPage
    });
  }

  function cacheElements(elementContext, containerSelector, detailsSelector) {
    // self.$sniModule
    $galleryElement = $(elementContext.getElement());
    // self.$galleryContainer
    galleryContainer = $galleryElement.find(containerSelector);
    // self.$detailsContainer
    detailsContainer = $galleryElement.find(detailsSelector);
  }

  function updateDataAttributes(currentContext, target) {
    var title = target.data('galleryTitle'),
        ms = target.data('mediaStream');
    currentContext.broadcast('gallerydataupdated', {
      galleryTitle: title,
      mediaStream: ms
    });
  }

  function checkAdLibrary(currentContext, checkService) {
    currentContext.broadcast('gallerydataupdated', {
      adLibLoaded: checkService.exists(['SniAds.Gallery', 'SniAds.Event'])
    });
  }

  function checkStartSlide(currentContext, element) {

    if (typeof element.data('startSlide') !== 'undefined' || location.hash !== '') {
      var startPos = -1;

      // if deeplink hash exists get the start position from it
      // this overrides possible startposition comming from element data
      if (location.hash.indexOf('item-') > -1) {
        startPos = parseInt(location.hash.replace('#item-', '')) - 1;
      } else {
        startPos = parseInt(element.data('startSlide'));
      }

      // set new starting position if valid start position found above
      if (!Number.isNaN(startPos) && startPos > -1) {
        currentContext.broadcast('gallerydataupdated', {
          galleryStartingPosition: startPos
        });
      }
    }
  }

  function checkGalleryType(currentContext, isCurated) {
    if (isCurated) {
      currentContext.broadcast('gallerydataupdated', {
        galleryType: 'curated'
      });
    }
  }

  function setSliderConfig(currentContext, sliderSettings, isMobile, isTablet, pos) {
    var settings = void 0;

    settings = {
      startSlideId: pos
    };

    if (isMobile || isTablet) {
      settings = updateObject(settings, {
        transitionSpeed: 0
      });
    }

    if (config.galleryType === 'curated' && !config.newTemplate) {
      settings = updateObject(settings, {
        loop: false,
        autoScaleSlider: false
      });
    }

    currentContext.broadcast('gallerydataupdated', {
      rsConfig: updateRoyalSliderConfig(sliderSettings, settings)
    });
  }

  function setInterstitialConfig(settings) {
    if (settings.adLibLoaded) {
      var currentSettings = void 0,
          galleryType = void 0;

      galleryType = settings.galleryViewType;

      switch (galleryType) {
        case 'inline':
          currentSettings = {
            desktop: {
              wrapper: 'photo_interstitial_wrapper',
              slot: 'dfp_photo_interstitial',
              slotInst: 'overlayPhotoIntName',
              markup: 'interstitialWrapper'
            },
            mobile: {
              wrapper: 'photo_interstitial_wrapper_mobile',
              slot: 'dfp_smartphone_interstitial',
              slotInst: 'overlayPhotoIntMobileName',
              markup: 'interstitialWrapperMobile'
            }
          };
          break;
      }

      context.broadcast('gallerydataupdated', {
        interstitialSettings: settings.isMobile ? currentSettings.mobile : currentSettings.desktop
      });
    }
  }

  function populateDetailsWrapper(currentContext, detailsItemSelector, currentDetailsContainer) {
    currentContext.broadcast('gallerydataupdated', {
      pvDetailsArray: currentDetailsContainer.find(detailsItemSelector).toArray()
    });
  }

  function stageContent(currentSlideWrapper, currentGalleryContainer) {
    $(currentSlideWrapper).html('').append(currentGalleryContainer);
  }

  function createAdWrapper(adLib, container, templateService, config) {
    var galleryType = config.galleryType,
        adWrapperElements = config.adWrapperElements,
        newTemplate = config.newTemplate;

    var adTemplate = newTemplate ? templateService.adWrapper() : templateService.adWrapperLite();
    var $ad = void 0;
    if (adLib) {
      if (galleryType === 'curated') {
        container.parents(adWrapperElements.galleryContent).siblings(adWrapperElements.galleryAside).prepend(adTemplate);
      } else {
        $ad = $(adWrapperElements.stage);
        $ad.append(templateService.adWrapper());
      }
    }
  }

  function setWeRecommendWidth(currentContext, target, type) {
    if (type === 'curated' && $(target).length > 0) {
      currentContext.broadcast('gallerydataupdated', {
        weRecommendWidth: $(target).outerWidth()
      });
    } else {
      debug.warn('setWeRecommendWidth: no target');
    }
  }

  function stageNextUp(type, isMobile, next, templateService) {
    if (type === 'curated' && !isMobile) {
      if (!next.nextUpBlock.length) {
        $(next.nextUpContainer).hide();
      }
    }
  }

  function setPreviousState(currentContext, type) {
    if (type === 'curated') {
      var timestamp = void 0,
          previousUrl = void 0;

      timestamp = new Date().getTime();
      previousUrl = window.location.pathname + window.location.search;

      currentContext.broadcast('previousUrlChanged', {
        previousURL: previousUrl
      });

      currentContext.broadcast('stateChanged', {
        gallery: timestamp,
        launcher: true,
        href: previousUrl
      });

      // why is stateChanged broadcast twice?

      timestamp = new Date().getTime();

      currentContext.broadcast('stateChanged', {
        gallery: timestamp,
        launcher: true,
        href: previousUrl
      });
    }
  }

  function setMediaStreamData(mediaStreamService, currentMediaStream, currentTitle, currentUrl) {
    mediaStreamService.recordCurrentAndPreviousSS({
      'title': currentTitle,
      'url': currentUrl
    });

    if (currentMediaStream !== '' && currentMediaStream.length > 0) {
      mediaStreamService.setupNextSS(currentMediaStream);
    }
  }

  function createInterstitialContainer(settings, container, templateService) {
    if (settings.adLibLoaded) {

      if (settings.interstitialSettings.slotInst === '' || $('#' + settings.interstitialSettings.slotInst).length === 0) {
        container.before(templateService[settings.interstitialSettings.markup]());
        if (settings.isTablet || settings.isMobile) {
          container.before(templateService.interstitialMobileCloseBtn());
        }

        updateInterstitialSlotInstance(settings);
      } else {
        $('#' + settings.interstitialSettings.slotInst + ', #' + settings.interstitialSettings.wrapper).show();
        SniAds.refreshSlot(settings.interstitialSettings.slotInst);
      }

      createInterstitialOrientationHandler(settings, container);
    }
  }

  function updateInterstitialSlotInstance(settings) {
    debug.log('updateInterstitialSlotInstance: settings: ', settings);
    if (settings.adLibLoaded) {
      var newInterstitialSettings = void 0,
          newSlot = void 0;

      newSlot = SniAds.appendSlot(settings.interstitialSettings.wrapper, settings.interstitialSettings.slot, true);

      newInterstitialSettings = updateObject(settings.interstitialSettings, {
        slotInst: newSlot
      });

      context.broadcast('gallerydataupdated', {
        interstitialSettings: newInterstitialSettings
      });

      SniAds.Gallery.setInterstitialSlot(newInterstitialSettings.slotInst);
    }
  }

  function listenForOrientationChange(settings, container) {
    var orientationHandler = function orientationHandler() {
      if (isInterstitialShown(settings, container) && settings.overlayPhotoIntMobileName) {
        SniAds.refreshSlot(settings.overlayPhotoIntMobileName);
      }
    };
    return orientationHandler;
  }

  function createInterstitialOrientationHandler(settings, container) {
    var handler = listenForOrientationChange(settings, container);
    if (settings.adLibLoaded && settings.isMobile && window.addEventListener && window.removeEventListener) {
      window.addEventListener('orientationchange', handler, false);
      context.broadcast('gallerydataupdated', {
        interstitialOrientationHandler: handler
      });
    }
  }

  function getInterstitial(interstitialShown, container) {
    return container.closest(interstitialShown);
  }

  function isInterstitialShown(settings, container) {
    var intShown = settings.interstitialShownClass;
    if (getInterstitial(intShown, container).length > 0) {
      $(settings.pvDetailsWrapCon).css('visibility', 'visible');
    }
    return getInterstitial(intShown, container).length > 0;
  }

  function prepareGallery(container, loading) {
    container.removeClass(loading);
  }

  function createCustomSliderEvents(currentContext, settings, proto, mods) {
    $.extend(proto, {
      _addAfterSlideEvent: function _addAfterSlideEvent() {

        var self = this,
            sliderEvents = {
          rsAfterSlideChange: settings.afterSlideName,
          rsBeforeAnimStart: settings.beforeAnimName,
          rsBeforeSizeSet: settings.beforeSizeName
        },
            key = void 0;

        var _loop = function _loop() {
          var name = key,
              val = sliderEvents[name];

          self.ev.on(name, function (event) {
            currentContext.broadcast(val, {
              event: event
            });
          });
        };

        for (key in sliderEvents) {
          _loop();
        }

        self.ev.on('rsAfterContentSet', function (e, slideObject) {
          if (!self.sliderReady) {
            self.ev.trigger('rsSliderReady');
            currentContext.broadcast(settings.afterContentSetName, {
              event: e,
              slideObject: slideObject
            });
            self.sliderReady = true;
          }
          resizeWell(config.galleryType, config.rsOverflowCon, config.pvSlideWrapCon, config.weRecommend);
        });
      }
    });
    mods.addAfterSlideEvent = proto._addAfterSlideEvent;
  }

  function resizeWell(type, overflowContainer, wrapper, weRecommend) {
    if (type === 'curated') {

      var weRecommendOuterWidthStart = $(weRecommend).width(),
          $blocksStart = $(weRecommend).find('.m-MediaBlock'),
          blockWidthStart = $(weRecommend).find('.m-MediaBlock').outerWidth(),
          numBlocksStart = Math.floor(weRecommendOuterWidthStart / blockWidthStart);

      if (!config.newTemplate) {
        $(overflowContainer + ', ' + wrapper).outerHeight(($(overflowContainer).outerWidth() - (parseInt($(overflowContainer).css('padding-left')) + parseInt($(overflowContainer).css('padding-right')))) / 1.5);
      }
      $blocksStart.each(function () {
        $(this).hide();
      });
      $blocksStart.slice(0, numBlocksStart).each(function () {
        $(this).css('display', 'inline-block');
      });
      // hotspotResize();
    }
  }

  function setResizeHandler(type, overflowContainer, wrapper, resizeIt, center, currentSlider, isMobile, weRec) {
    var waitForFinalEvent = function () {
      var timers = {};
      return function (callback, ms, uniqueId) {
        if (!uniqueId) {
          uniqueId = 'Don\'t call this twice without a uniqueId';
        }
        if (timers[uniqueId]) {
          clearTimeout(timers[uniqueId]);
        }
        timers[uniqueId] = setTimeout(callback, ms);
      };
    }();
    $(window).off('resize.viewer');
    $(window).on('resize.viewer', function () {
      waitForFinalEvent(function () {
        resizeIt(type, overflowContainer, wrapper, weRec);
        if (!config.newTemplate) {
          center($(currentSlider.currSlide.content.context), isMobile, type);
        }
      }, 4, 'resize.viewer');
    }).trigger('resize');
  }

  function centerImage($slide, isMobile, type) {
    var $photoWrapper = $slide.find('.pv-photo-wrapper'),
        $photo = $slide.find('.rsImg');

    if (!isMobile && type === 'curated' && !config.newTemplate) {
      if ($photo.height() < $photoWrapper.height()) {
        $photo.css('padding-top', ($photoWrapper.height() - $photo.height()) / 2);
      }
    }
  }

  function startSlider(currentContext, container, settings) {
    slider = container.royalSlider(settings).data('royalSlider');
    currentContext.broadcast('gallery.sliderInit', {
      slider: slider
    });
  }

  function insertCTA(type, container, templateService, isMobile, lMContainer, lMText, numSlides) {
    if (type === 'curated' && config.galleryStartingPosition === 0) {

      container.append(templateService.clonedCredit());

      if (!isMobile && config.originalGallery === 0 && config.consecutiveGallery === 1) {
        $(lMContainer).prepend(templateService.launchMeContent());
        $(lMText).find(config.launchMePhotoCount).remove();
        $(lMText).append(templateService.launchMeFiller(numSlides));
        $(lMContainer).addClass('cta-active');
      }
    }
  }

  function transitionElements(slideContent, type, id, overflow, slideWrapper) {
    var $shareContainer = $(slideContent).find('.pv-photo-info'),
        $shareClone = void 0,
        creditText = '';

    if (type === 'curated' && !config.newTemplate) {
      if (id === 0) {
        $(overflow + ', ' + slideWrapper).outerHeight(($(overflow).outerWidth() - (parseInt($(overflow).css('padding-left')) + parseInt($(overflow).css('padding-right')))) / 1.5);
      }
      $shareContainer.show();
      $shareClone = $shareContainer.clone();
      $shareClone.removeClass('pv-photo-info').addClass('clone-zone');
      $shareContainer.hide();
      $('.cloned-credit').html('').append($shareClone.html());
      $shareClone.remove();
    }

    if (type === 'dynamic') {
      creditText = $shareContainer.find('.pv-photo-credit').text().trim();
      if (creditText === '') $shareContainer.hide();
    }

    if ($('.pv-details-wrapper .list-item').length <= 6) {
      $('.pv-details-wrapper .list-item--show-all').css('display', 'none');
    }
  }

  function setDetails(detailsWrapContainer, detailsArray, id) {
    $(detailsWrapContainer).html(detailsArray[id]);
  }

  function handleProductTracking(mdString) {
    var mdmData = JSON.parse(mdString);

    if (mdmData.products && mdmData.shopping === 'shopping') {
      context.broadcast('product.displayed', {
        partner: mdmData.partner,
        products: mdmData.products
      });
    }
  }

  function refreshAds(currentContext, isMobile, adLibLoaded, container, bigboxName, templateService, structure, type) {
    if (!isMobile && adLibLoaded) {
      var adWrapper = void 0,
          newSlot = void 0,
          $overBB = void 0;

      if (type === 'curated') {
        adWrapper = container.parents(structure.galleryContent).siblings(structure.galleryAside).find('.bigbox-ad');
      } else {
        adWrapper = container.closest('[data-module]').find('.bigbox-ad');
      }

      if (bigboxName === '') {
        newSlot = bigboxName;
        adWrapper.append(templateService.adText());
        if (type === 'curated') {
          adWrapper.prepend(templateService.overlayBigbox());
        } else {
          adWrapper.append(templateService.overlayBigbox());
        }
        newSlot = SniAds.appendSlot('overlay_bigbox', 'dfp_bigbox');
        currentContext.broadcast('gallerydataupdated', {
          overlayBigboxName: newSlot
        });
        SniAds.Gallery.setSyncSlot(newSlot);
      } else {
        $overBB = $('#overlay_bigbox').show();
        if (!adWrapper.has('#overlay_bigbox')) {
          $overBB.appendTo(adWrapper);
        } else {
          SniAds.refreshSlot(bigboxName);
        }
      }
    }
  }

  function handleInterstitial(currentContext, settings, currentSlider, container, checkService, fetch, interstitialShown, mediaStreamService, templateService) {
    if (checkService.exists(['SniAds.Gallery', 'SniAds.Event'])) {
      var isLastSlide = container.find(config.nextArrowSelector + '.rsArrowDisabled').length > 0,
          isFirstSlide = container.find(config.previousArrowSelector + '.rsArrowDisabled').length > 0;
      if (currentSlider.lastSlideId >= 0) {
        if (settings.galleryType === 'curated' && currentSlider.currSlideId >= currentSlider.lastSlideId && currentSlider.currSlideId !== currentSlider.numSlides - 1) {
          SniAds.Gallery.next();
        } else if (currentSlider.currSlideId >= currentSlider.lastSlideId && currentSlider.currSlideId !== currentSlider.numSlides - 1) {
          SniAds.Gallery.next();
        }
      } else {
        if (settings.galleryType === 'curated' && currentSlider.currSlideId < currentSlider.lastSlideId && currentSlider.currSlideId !== 0) {
          SniAds.Gallery.previous();
        } else if (currentSlider.currSlideId < currentSlider.lastSlideId && currentSlider.currSlideId !== 0) {
          SniAds.Gallery.previous();
        }
      }
      if (!settings.isMobile && interstitialShown(settings, container) && (isLastSlide || isFirstSlide || currentSlider.currSlideId === currentSlider.numSlides - 1 || currentSlider.currSlideId === 0)) {
        var arrows = container.find('.rsArrow');
        arrows.addClass('force-show').on('click.slidesend', function (e) {
          arrows.removeClass('force-show').unbind('click.slidesend');
          closeInterstitial(settings, fetch, container, checkService);
          if (isLastSlide || currentSlider.currSlideId === currentSlider.numSlides - 1) {
            addNextGalleryLink(currentContext, settings, container, currentSlider, interstitialShown, mediaStreamService, templateService);
          }
          return false;
        });
      }
    }
  }

  function closeInterstitial(settings, fetchInterstitial, container, checkService) {
    if (settings.adLibLoaded && $('#ad-gallery-control').attr('rel') !== 'gallery-blocked') {
      var interstitial = fetchInterstitial(settings.interstitialShownClass, container),
          interSlot = void 0;

      $(settings.pvDetailsWrapCon).css('visibility', 'visible');
      $('.photo-viewer').removeClass(settings.interstitialClass);
      if (interstitial.hasClass('interstitial-show')) {
        interstitial.removeClass('interstitial-show');
        debug.log('Hide Interstitial');
        if (checkService.exists('googletag')) {
          interSlot = SniAds.getDefinedSlots()[SniAds.Gallery.getConfigData().interstitialSlot];
          context.getGlobal('googletag').pubads().clear([interSlot]);
        }
        return true;
      }
      return false;
    }
  }

  function addNextGalleryLink(currentContext, settings, container, currentSlider, interstitialShown, mediaStreamService, templateService) {
    if (!interstitialShown(settings, container)) {
      var $galleryOverflow = container.find('.rsOverflow'),
          nextGallery = void 0,
          nextGalleryTitle = void 0,
          nextGalleryUrl = void 0,
          nextGalleryLinkText = 'NEXT UP';

      if (settings.galleryType === 'curated') {
        nextGallery = mediaStreamService.getNextSS();
        nextGalleryTitle = nextGallery.title;
        nextGalleryUrl = nextGallery.url;
        if (nextGalleryTitle && window.location.href.lastIndexOf(nextGallery.url) <= 1) {
          currentSlider.slider.removeClass(settings.blurClass);

          // Blue next gallery button in the end of slideshow.
          if (config.newTemplate) {
            $galleryOverflow.find('.rsArrowRight').addClass('rsArrowPrimary');
          }

          $galleryOverflow.append(templateService.nextGalleryModal({
            link: nextGalleryUrl,
            subHeadline: nextGalleryLinkText,
            headline: nextGalleryTitle
          }));
        } else if (!nextGalleryTitle) {
          currentContext.broadcast('gallerydataupdated', {
            suppressNextGalleryEvent: true
          });
        }
      }
    }
  }

  function removeNextGalleryLink(container, classSelector) {
    container.find(classSelector).remove();

    // Remove blue color for next gallery arrow.
    if (config.newTemplate) {
      container.find('.rsArrowRight').removeClass('rsArrowPrimary');
    }
  }

  function updateRoyalSliderConfig(sliderSettings, data) {
    var updatedRSConfig = void 0,
        newSettings = void 0;

    newSettings = data;
    updatedRSConfig = updateObject(sliderSettings, newSettings);

    return updatedRSConfig;
  }

  function goNextClick(container, threshold, clickX) {
    var sliderWidth = container.width(),
        clickPercentage = (clickX - container.offset().left) / sliderWidth * 100;

    if (clickPercentage > threshold) {
      return true;
    } else {
      return false;
    }
  }

  function delegateArrowEvents(container, leftSelector, leftType, rightSelector, rightType) {
    var left = container.find(leftSelector),
        right = container.find(rightSelector);

    if (left.length && right.length) {
      left.attr('data-type', leftType);
      right.attr('data-type', rightType);
    }
  }

  function removeLaunchMe(cta) {
    if ($(cta).length > 0) {
      $(cta).parent().removeClass('cta-active');
      $(cta).remove();
      ll.forceScroll();
    }
  }

  function traverseSlideshow(container, settings, pageX, currentSlider, checkService, fetch, go) {
    var ad = closeInterstitial(settings, fetch, container, checkService);

    if (!settings.isMobile && !ad) {
      if (go(container, settings.backNavPercent, pageX)) {
        currentSlider.next();
      } else {
        currentSlider.prev();
      }
    }
  }

  function createCustomPrevNextHandling(currentSlider) {
    currentSlider.lastSlideId = -1;
    currentSlider._arrowLeft.unbind();
    currentSlider._arrowRight.unbind();

    $(document).bind('keydown.photoGalleryModalKeyFilter', function (e) {
      switch (e.which) {
        case 37:
          if (closeInterstitial(config, getInterstitial, galleryContainer, check)) {
            return false;
          }
          currentSlider.prev();
          e.preventDefault();
          break;
        case 39:
          if ($(config.launchMeWrapper).length > 0) {
            removeLaunchMe(config.launchMeWrapper);
            setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
            handleProductTracking($(slider.currSlide.content.context).attr('data-mdm'));
            e.preventDefault();
          } else {
            if (closeInterstitial(config, getInterstitial, galleryContainer, check)) {
              return false;
            }
            currentSlider.next();
            e.preventDefault();
          }
          break;
      }
    });
  }

  function updateShopElement(currentContext, currentSlider) {
    currentContext.broadcast('shopElementChanged', {
      type: config.galleryType,
      newElement: currentSlider.currSlide.content
    });
  }

  function areWeThereYet(currentContext, currentSlider) {
    currentSlider.ev.one('rsTryingToAdvancePastLastSlide', function (event) {
      currentContext.broadcast('gallery.lastSlideReached', {
        currentEvent: event
      });
    });
  }

  function updateURL(currentContext, type, checkService, routingService, currentSlider, wrap) {
    if (checkService.exists('history.pushState') && type !== 'curated') {
      var slideContent = currentSlider.currSlide.content,
          assetURL = slideContent.data('assetUrl') || '',
          $slideContainer = $(slideContent).find(wrap),
          socialShare = $slideContainer.data('social-share') === true,
          assetURLMatch = assetURL.match(/^https?:\/\/[^\/]*/),
          assetURLOrigin = '',
          timestamp = void 0,
          slideID = void 0,
          sObj = void 0;

      if (assetURLMatch) {
        assetURLOrigin = assetURLMatch[0];
      }

      if (document.location.origin === assetURLOrigin || assetURL.indexOf('//') === -1) {

        if (!socialShare) {
          assetURL = routingService.getPreviousURL();
        }

        timestamp = new Date().getTime(), slideID = currentSlider.currSlideId;
        sObj = { sID: slideID, gallery: timestamp, href: assetURL };

        if (window.location.href.indexOf(assetURL) === -1) {
          currentContext.broadcast('stateChanged', sObj);
        }
      }
    }
  }

  function fetchNextGallery(currentContext, currentSlider, settings, container) {
    var normalizedSlideNumber = currentSlider.currSlideId + 1,
        totalSlides = currentSlider.numSlides,
        loop = settings.rsConfig.loop || false,
        lastCloned = settings.lastCloned || false,
        type = settings.galleryType || false,
        $slide = void 0,
        $clonedSlide = void 0;

    if (normalizedSlideNumber === totalSlides && !loop && type === 'curated') {
      $(config.nextArrowSelector + '.rsArrowDisabled').removeClass('rsArrowDisabled');
      if (lastCloned) {
        currentContext.broadcast('gallery.nextGalleryFetched');
        currentContext.broadcast('gallerydataupdated', {
          allowPV: false
        });
      } else {
        $slide = $(currentSlider.currSlide.content.context);
        $clonedSlide = $slide.clone();
        currentSlider.appendSlide($clonedSlide);
        currentContext.broadcast('gallerydataupdated', {
          lastCloned: true,
          allowPV: true
        });
      }
    } else {
      currentContext.broadcast('gallery.noNextGallery');
      currentContext.broadcast('gallerydataupdated', {
        allowPV: true
      });
    }
  }

  function getHotspotInstance(currentContext, currentUrl, currentImg, hotspotElement, defaultUrl, single) {
    var img = void 0,
        hotspotUrl = void 0,
        elementUrl = void 0,
        deferredHotspots = void 0;

    img = $(currentImg);
    if (!img.data(hotspotElement)) {
      hotspotUrl = currentUrl;
      deferredHotspots = $.Deferred();
      img.data(hotspotElement, deferredHotspots.promise());
      elementUrl = img.attr('src') || '';
      elementUrl = elementUrl.replace(/\.rend.*/, '');
      currentContext.broadcast('elementUpdated', {
        element: img,
        url: hotspotUrl || defaultUrl,
        imageUrl: elementUrl,
        hotspotShowAll: !single,
        initDeferred: deferredHotspots
      });
    }
  }

  function updateLastItem(currentSlider) {
    currentSlider.lastSlideId = currentSlider.currSlideId;
  }

  function setSecondPass(currentContext, currentSlider) {
    if (currentSlider > 0) {
      currentContext.broadcast('gallerydataupdated', {
        secondPass: true
      });
    }
  }

  function setupFilterListeners() {
    var pvHoverTimer = void 0;

    if (config.isTablet) {
      $(config.pvDropdownItems).addClass('tablet');
    }

    $('.list-item--show-all a').on('click', function () {
      var $this = $(this);
      $this.parent().parent().addClass('tags--all-visible');
    });

    $('.list-inline-expandable').each(function () {
      var $this = $(this),
          tags_count = $this.children('.list-item').length;
      if (tags_count <= 5) {
        $('.list-item--show-all').remove();
      }
    });

    $('.pv-pl-nav-dropdown.dropdown-filter').hover(function () {
      var self = this;
      pvHoverTimer = setTimeout(function () {
        $(self).closest('.pv-pl-nav-dropdown').addClass('open');
      }, 175);
    }, function () {
      clearTimeout(pvHoverTimer);
      $(this).removeClass('open');
    });
  }

  function setupHistoryListeners() {
    window.onpopstate = function (event) {
      if (check.exists('history.pushState')) {
        slider.goTo(event.state.sID);
        setDetails(config.pvDetailsWrapCon, config.pvDetailsArray, slider.currSlideId);
        setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
        transitionElements(slider.currSlide.content, config.galleryType, slider.currSlideId, config.rsOverflowCon, config.pvSlideWrapCon);
        refreshAds(context, config.isMobile, check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, config.overlayBigboxName, template, config.adWrapperElements, config.galleryType);
        handleInterstitial(context, config, slider, galleryContainer, check, getInterstitial, isInterstitialShown, mediaStream, template);
      }
    };
  }

  function incrementOriginalGallery(currentContext, metadataService, settings) {
    if (settings.allowPV) {
      settings.originalGallery++;
      updateConsecutiveGallery(currentContext, metadataService, {
        originalGallery: settings.originalGallery,
        consecutiveGallery: settings.consecutiveGallery
      });
    }
  }

  function processMetadata(target, options) {
    debug.log('processMetadata: instance: ', $(context.getElement()).attr('id'));
    var mdmData = (helpers_typeof_default()(target.data('mdm')) === 'object' ? target.data('mdm') : JSON.parse(target.data('mdm'))) || false,
        title = target.data('assetTitle') || false,
        currentURL = mdmData.URL || false,
        isPhotoLibrary = /photolibrary/.test(mdmData.UniqueId) || false,
        checkService = options.checkService || false,
        metadataService = options.metadataService || false,
        analyticsService = options.analyticsService || false,
        incrementValue = options.incrementValue || false,
        updateValues = options.updateValues || false,
        currentContext = options.context | false,
        previousPageNumber = options.previousPageNumber || false,
        mdmUniqueParameter = options.mdmUniqueParameter || 'Overlay_UniqueId',
        type = options.galleryType || false,
        transfer = void 0,
        currentMDM = void 0,
        currentPageNumber = void 0,
        behavioralInteraction = void 0,
        uniqueIDPrime = void 0;

    if (checkService) {
      var mdManager = context.getGlobal('mdManager');
      currentMDM = checkService.exists('mdManager') ? mdManager : false;
      if (currentMDM) {
        if (title) {
          mdManager.setParameter('CurrentRoom', title);
        }
      }
    }

    if (metadataService) {
      behavioralInteraction = metadataService.getMediaStreamNumber(mdmData, incrementValue) || false;
      uniqueIDPrime = metadataService.updateConsecutiveViewCount(mdmData) || false;
      if (mdmData) {
        if (isPhotoLibrary && currentURL) {
          delete mdmData.URL;
        }
        if (updateValues) {
          if (uniqueIDPrime) {
            transfer = {};
            if ((typeof mdmUniqueParameter === 'undefined' ? 'undefined' : helpers_typeof_default()(mdmUniqueParameter)) === 'object') {
              for (var key in mdmUniqueParameter) {
                transfer[key] = uniqueIDPrime;
              }
            } else {
              transfer[mdmUniqueParameter] = uniqueIDPrime;
            }
            mdmData = updateValues(mdmData, transfer);
          }
          if (behavioralInteraction) {
            mdmData = updateValues(mdmData, {
              behavioralInteraction: behavioralInteraction
            });
          }
        }
        metadataService.updateFromJSON(mdmData);
      } else {
        debug.warn('processMetadata: MDM Data Missing: Cannot Update Metadata');
      }
    } else {
      debug.warn('processMetadata: No Metadata Service: Cannot Update Metadata');
    }

    if (analyticsService) {
      analyticsService.callDynamicPageview();
      if (currentMDM && type) {
        currentPageNumber = currentMDM.getPageNumber() || false;
        if (currentPageNumber !== previousPageNumber && type === 'curated') {
          currentContext.broadcast('gallerydataupdated', {
            previousPageNumber: currentPageNumber
          });
        }
      }
    } else {
      debug.warn('processMetadata: No Analytics Service: Cannot Fire Pageview');
    }
  }

  function setupTouchListeners() {
    $(config.pvSlideWrapCon).on('touchstart.gallery', function (event) {
      config.xDown = event.originalEvent.touches[0].clientX;
      config.yDown = event.originalEvent.touches[0].clientY;
    });

    $(config.pvSlideWrapCon).on('touchmove.gallery', function (event) {
      if (!config.xDown || !config.yDown) {
        return;
      }

      var xUp = event.originalEvent.touches[0].clientX;
      var yUp = event.originalEvent.touches[0].clientY;

      var xDiff = config.xDown - xUp;
      var yDiff = config.yDown - yUp;

      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        if (xDiff > 0) {
          // left swipe
          refreshAds(context, config.isMobile, check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, config.overlayBigboxName, template, config.adWrapperElements, config.galleryType);
          handleInterstitial(context, config, slider, galleryContainer, check, getInterstitial, isInterstitialShown, mediaStream, template);
          slider.next();
        } else {
          // right swipe
          if (slider.currSlideId !== 0) {
            refreshAds(context, config.isMobile, check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, config.overlayBigboxName, template, config.adWrapperElements, config.galleryType);
            handleInterstitial(context, config, slider, galleryContainer, check, getInterstitial, isInterstitialShown, mediaStream, template);
          }
          slider.prev();
        }
        setDetails(config.pvDetailsWrapCon, config.pvDetailsArray, slider.currSlideId);
        setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
        transitionElements(slider.currSlide.content, config.galleryType, slider.currSlideId, config.rsOverflowCon, config.pvSlideWrapCon);
      }
      config.xDown = null;
      config.yDown = null;
    });
  }

  function setQString() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'curated';

    if (type === 'curated' && location.search) {
      config.qString = setQueryToJSON();
      return true;
    } else {
      return false;
    }
  }

  function setQueryToJSON() {
    var pairs = location.search.slice(1).split('&'),
        result = {};

    pairs.forEach(function (pair) {
      pair = pair.split('=');
      result[pair[0]] = decodeURIComponent(pair[1] || '');
    });

    return JSON.parse(JSON.stringify(result));
  }

  function setDeepLink(currentContext, type) {
    if (type === 'curated') {
      var timestamp = void 0;
      if (setQString(type) && config.qString.im) {
        config.qString.im = config.qString.im.replace(/[^0-9]/gim, '').trim();
        if (config.qString.im !== '') {
          slider.goTo(parseInt(config.qString.im));
        }
        timestamp = new Date().getTime();
        currentContext.broadcast('stateChanged', {
          gallery: timestamp,
          href: window.location.pathname + window.location.search.replace(/\??\&?im\=[^\&]+/gim, '')
        });
      }
    }
  }

  function addSlideNumber() {
    if (config.galleryType === 'curated') {
      galleryContainer.find('.rsCurr').text(slider.currSlideId + 1).end().find('.rsLength').text(slider.numSlides);
    }
  }

  function createSlideNumbering(container, count, add, type) {
    if (type === 'curated') {
      container.append(count);
      add();
    }
  }

  function setupAjaxHandler(type, currentSlider, currentContext, stayAheadAmount, readyToFetch) {
    if (type === 'dynamic') {
      var currentSlide = currentSlider.currSlideId + 1,
          numberOfSlides = currentSlider.numSlides;

      if (numberOfSlides - currentSlide <= stayAheadAmount) {
        if (readyToFetch) {
          currentContext.broadcast('gallery.loadingAdditionalContent');
        }
      } else {
        currentContext.broadcast('gallerydataupdated', {
          readyToFetchMore: true
        });
      }
    }
  }

  function getAdditionalContent(currentContext, ajaxUrl, paging, currentAjaxPage, currentSlider, ajaxFetchNumSlides, slideClass) {
    var detailsClass = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
    var detailsArray = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

    var finalAjaxUrl = ajaxUrl,
        countOfHTML = void 0,
        lastHTML = void 0,
        nextPage = void 0,
        $slideData = void 0;

    if (finalAjaxUrl !== '') {
      countOfHTML = finalAjaxUrl.match(/.html/g) || 0;

      if (countOfHTML.length > 1) {
        lastHTML = finalAjaxUrl.lastIndexOf('.html');
        finalAjaxUrl = finalAjaxUrl.substring(0, lastHTML);
      }

      if (paging) {
        nextPage = ++currentAjaxPage;

        currentContext.broadcast('gallerydataupdated', {
          ajaxPageWeAreOn: nextPage
        });

        if (finalAjaxUrl.lastIndexOf('/p/') !== -1) {
          finalAjaxUrl = finalAjaxUrl.substring(0, finalAjaxUrl.lastIndexOf('/p/'));
        }
        finalAjaxUrl += '/p/' + nextPage;
      } else {
        finalAjaxUrl += '/o/' + currentSlider.numSlides + '/n/' + ajaxFetchNumSlides;
      }

      finalAjaxUrl = finalAjaxUrl + '.html';

      if (check.isLocalhost() || check.isAuthor()) {
        finalAjaxUrl += '?wcmmode=disabled';
      }

      currentContext.broadcast('gallerydataupdated', {
        readyToFetchMore: false
      });

      $.get(finalAjaxUrl, function (data) {
        $slideData = $('<div>').append(data);

        appendSlideData($slideData, currentSlider, slideClass, currentContext, detailsClass, detailsArray);
      });
    }
  }

  function appendSlideData($data, currentSlider, newContentClass, currentContext, newDetailsClass, detailsArray) {
    var transfer = void 0;
    $data.find(newContentClass).each(function () {
      currentSlider.appendSlide(this);
      currentContext.broadcast('contentUpdated', {
        newContent: this
      });
    });
    if (newDetailsClass && detailsArray) {
      transfer = detailsArray;
      $data.find(newDetailsClass).each(function () {
        transfer.push(this);
      });
      currentContext.broadcast('gallerydataupdated', {
        pvDetailsArray: transfer
      });
    }
  }

  function killItWithFire() {
    // $(document).unbind('keydown.photoGalleryModalKeyFilter');
    $(window).off('resize.viewer');
    $(config.pvSlideWrapCon).off('touchstart.gallery');
    $(config.pvSlideWrapCon).off('touchmove.gallery');
    $('.rsArrow').off('click.slidesend');
    $('.list-item--show-all a').off('click');
    $('.pv-pl-nav-dropdown.dropdown-filter').off('hover');
  }

  var messageHandlers = {
    'gallery.sliderInit': function gallerySliderInit() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        debug.log('gallery.sliderInit: instance: ', $(context.getElement()).attr('id'), mediaStream.getInstance());
        // Desible CTA on new PG templates.
        if (!config.newTemplate) insertCTA(config.galleryType, galleryContainer, template, config.isMobile, config.launchMeContainer, config.launchMeText, slider.numSlides);
        setDetails(config.pvDetailsWrapCon, config.pvDetailsArray, slider.currSlideId);
        transitionElements(slider.currSlide.content, config.galleryType, slider.currSlideId, config.rsOverflowCon, config.pvSlideWrapCon);
        if (check.exists(['SniAds.Gallery', 'SniAds.Event'])) {
          SniAds.ready(function () {
            refreshAds(context, config.isMobile, check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, config.overlayBigboxName, template, config.adWrapperElements, config.galleryType);
            handleInterstitial(context, config, slider, galleryContainer, check, getInterstitial, isInterstitialShown, mediaStream, template);
          });
        }
        createCustomPrevNextHandling(slider);
        areWeThereYet(context, slider);
        setupFilterListeners();
        setupHistoryListeners();
        setupTouchListeners();
        setDeepLink(context, config.galleryType);
        createSlideNumbering(galleryContainer, template.slideCount(), addSlideNumber, config.galleryType);
        debug.log(delegateArrowEvents, getHotspotInstance);
        delegateArrowEvents(galleryContainer, config.previousArrowSelector, config.leftDataType, config.nextArrowSelector, config.rightDataType);
        getHotspotInstance(context, $(slider.currSlide.content.context).data(config.hotspotUrlName), slider.currSlide.content.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, false);
        updateShopElement(context, slider);
        // setupAjaxHandler(config.galleryType, slider, context, config.ajaxStayAhead, config.readyToFetchMore);
      }
    },
    'gallery.afterSlide': function galleryAfterSlide() {
      debug.log('gallery.afterSlide', slider.currSlide.content);

      if ($(context.getElement()).attr('id') === mediaStream.getInstance() && !config.inProgressOfLastSlideAction) {
        setupAjaxHandler(config.galleryType, slider, context, config.ajaxStayAhead, config.readyToFetchMore);
        centerImage($(slider.currSlide.content.context), config.isMobile, config.galleryType);
        updateURL(context, config.galleryType, check, router, slider, config.pvPhotoWrapCon);
        fetchNextGallery(context, slider, config, galleryContainer);
        updateLastItem(slider);
        setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
        setSecondPass(context, slider.currSlideId);
        incrementOriginalGallery(context, metadata, config);
        if (config.secondPass && config.allowPV) {
          processMetadata($(slider.currSlide.content.context), {
            checkService: check,
            metadataService: metadata,
            analyticsService: analytics,
            incrementValue: 1,
            updateValues: updateObject,
            currentContext: context,
            previousPageNumber: config.previousPageNumber,
            mdmUniqueParameter: { UniqueID: false, Overlay_UniqueId: false },
            type: config.galleryType
          });
        }
        setDetails(config.pvDetailsWrapCon, config.pvDetailsArray, slider.currSlideId);
        transitionElements(slider.currSlide.content, config.galleryType, slider.currSlideId, config.rsOverflowCon, config.pvSlideWrapCon);
        updateShopElement(context, slider);
        context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content, true));

        refreshAds(context, config.isMobile, check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, config.overlayBigboxName, template, config.adWrapperElements, config.galleryType);
        handleInterstitial(context, config, slider, galleryContainer, check, getInterstitial, isInterstitialShown, mediaStream, template);
        getHotspotInstance(context, $(slider.currSlide.content.context).data(config.hotspotUrlName), slider.currSlide.content.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, false);
        ll.forceScroll();
        // context.broadcast('contentUpdated', {
        //   newContent: $(slider.currSlide.content)
        // });
      } else {
        context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content, true));
      }
    },
    'gallery.beforeAnimation': function galleryBeforeAnimation() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        addSlideNumber();
        ll.forceScroll();
      }
    },
    'gallery.beforeSizeSet': function galleryBeforeSizeSet() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        debug.log('gallery.beforeSizeSet');
      }
    },
    'gallery.afterContentSet': function galleryAfterContentSet() {
      debug.log('gallery.afterContentSet', slider.currSlide.content);
      context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content, true));

      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        setResizeHandler(config.galleryType, config.rsOverflowCon, config.pvSlideWrapCon, resizeWell, centerImage, slider, config.isMobile, config.weRecommend);
        updateShopElement(context, slider);
      }
    },
    'gallery.lastSlideReached': function galleryLastSlideReached() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        if (isInterstitialShown(config, galleryContainer)) {
          closeInterstitial(config, getInterstitial, galleryContainer, check);
          addNextGalleryLink(context, config, galleryContainer, slider, isInterstitialShown, mediaStream, template);
        }
        context.broadcast('gallerydataupdated', {
          inProgressOfLastSlideAction: true
        });
        if (!config.suppressNextGalleryEvent) {
          context.broadcast('mediaStream.readyForNextSS');
        }
        if ($(config.nextLink).length) {
          $(config.nextLink).html(template.loadingHTML());
          slider.slider.removeClass(config.blurClass);
        }
      }
    },
    'test.gallery.showNextAssetModal': function testGalleryShowNextAssetModal(_ref) {
      var _ref$link = _ref.link,
          link = _ref$link === undefined ? '#' : _ref$link,
          _ref$subHeadline = _ref.subHeadline,
          subHeadline = _ref$subHeadline === undefined ? 'Next Up' : _ref$subHeadline,
          _ref$headline = _ref.headline,
          headline = _ref$headline === undefined ? 'Gallery Title' : _ref$headline;

      var $galleryOverflow = $('.rsOverflow');
      $galleryOverflow.append(template.nextGalleryModal({
        link: link,
        subHeadline: subHeadline,
        headline: headline
      }));
    },
    'gallery.nextGalleryFetched': function galleryNextGalleryFetched() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        addNextGalleryLink(context, config, galleryContainer, slider, isInterstitialShown, mediaStream, template);
      }
    },
    'gallery.noNextGallery': function galleryNoNextGallery() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        removeNextGalleryLink(galleryContainer, config.nextClass);
      }
    },
    'gallery.loadingAdditionalContent': function galleryLoadingAdditionalContent() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        getAdditionalContent(context, config.ajaxUrl, config.ajaxPaging, config.ajaxPageWeAreOn, slider, config.ajaxFetchNumSlides, config.galleryContainer + ' ' + config.pvSlideSelector, config.detailsContainer + ' ' + config.pvDetailsSelector, config.pvDetailsArray);
      }
    },
    'gallerydataupdated': function gallerydataupdated(data) {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        setGalleryConfig(config, data);
      }
    },
    'photos.searchPageUpdated': function photosSearchPageUpdated(data) {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        updateCurrentPhotoSearchPage(context, data);
      }
    },
    'mediaStream.consecutiveGalleryUpdated': function mediaStreamConsecutiveGalleryUpdated(data) {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        updateConsecutiveGallery(context, metadata, {
          originalGallery: config.originalGallery,
          consecutiveGallery: data.consecutiveGallery
        });
      }
    },
    'mediaStream.headingToPreviousSS': function mediaStreamHeadingToPreviousSS() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        killItWithFire();
      }
    },
    'mediaStream.headingToNextSS': function mediaStreamHeadingToNextSS() {
      if ($(context.getElement()).attr('id') === mediaStream.getInstance()) {
        killItWithFire();
      }
    },
    'ajax.areaContentLoaded': function ajaxAreaContentLoaded() {
      setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
    }
  };

  function doProcessMetadata() {
    if (config.secondPass && config.allowPV) {
      processMetadata($(slider.currSlide.content.context), {
        checkService: check,
        metadataService: metadata,
        analyticsService: analytics,
        incrementValue: 1,
        updateValues: updateObject,
        currentContext: context,
        previousPageNumber: config.previousPageNumber,
        mdmUniqueParameter: { UniqueID: false, Overlay_UniqueId: false },
        type: config.galleryType
      });
    }
  }

  // remove CTA and set up first image
  function doLaunch() {
    removeLaunchMe(config.launchMeWrapper);
    setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
    handleProductTracking($(slider.currSlide.content.context).attr('data-mdm'));
    context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content, true));
    doProcessMetadata();
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  module = {
    behaviors: ['shop-this-look', 'social-pinterest', 'hotspot', 'product-list', 'lazy-load'],

    messages: Object.keys(messageHandlers),

    init: function init() {
      getServices(context);
      instance = $(context.getElement()).attr('id');
      mediaStream.setInstance(instance);
      setGalleryConfig(defaults, context.getConfig());
      config.pvProductListArray = $(config.pvProductListSelector).toArray();
      checkAdLibrary(context, check);
      if (check.exists(['SniAds.Gallery', 'SniAds.Event'])) {
        adLib = context.getService('ads');
        SniAds.Gallery.init({
          galleryCfg: {
            container: '.pv-content-wrapper',
            dismiss_elts: '.rsArrowIcn',
            disable_elts: '',
            blockDelay: 10
          }
        });
        adLib.event.subscribe('slotRenderComplete', function (slot) {
          var id = slot.slot.getSlotElementId();
          if (!slot.isEmpty && /dfp_photo_interstitial/.test(id)) {
            $('.photo-viewer').addClass(config.interstitialClass);
          }
        });
        if (!coldLoad) {
          SniAds.Gallery.reset();
        }
        coldLoad = false;
      }
      checkGalleryType(context, $('.container-site').hasClass('inline-horizontal'));
      var viewCountData = metadata.getGalleryData();
      if (viewCountData) {
        if (typeof viewCountData.originalGallery !== 'undefined') {
          config.originalGallery = viewCountData.originalGallery;
        }
        if (typeof viewCountData.consecutiveGallery !== 'undefined') {
          config.consecutiveGallery = viewCountData.consecutiveGallery;
        }
        updateConsecutiveGallery(context, metadata, {
          originalGallery: config.originalGallery,
          consecutiveGallery: config.consecutiveGallery
        });
      } else {
        updateConsecutiveGallery(context, metadata, {
          originalGallery: config.originalGallery,
          consecutiveGallery: config.consecutiveGallery
        });
      }
      checkStartSlide(context, $(context.getElement()));
      setGalleryConfig(config, { isMobile: deviceType.isMobile, isTablet: deviceType.isTablet });
      setSliderConfig(context, config.rsConfig, config.isMobile, config.isTablet, config.galleryStartingPosition);
      if (config.galleryType === 'curated') {
        context.broadcast('gallerydataupdated', {
          adWrapper: config.newTemplate ? template.adWrapper() : template.adWrapperLite()
        });
      }
      var $footer = $(config.footerElement);
      if ($footer.text().trim().length === 0) {
        $footer.hide();
      } else {
        setWeRecommendWidth(context, config.weRecommend, config.galleryType);
        stageNextUp(config.galleryType, config.isMobile, config.nextUpElements, template);
      }
      setPreviousState(context, config.galleryType);
      updateDataAttributes(context, $(context.getElement()));
      if (config.galleryType === 'curated') {
        setMediaStreamData(mediaStream, config.mediaStream, config.galleryTitle, window.location.href);
      }
      setPreloaderHTML(template.preloaderHTML());
      cacheElements(context, config.galleryContainer, config.detailsContainer);
      populateDetailsWrapper(context, config.pvDetailsSelector, detailsContainer);
      stageContent(config.pvSlideWrapCon, galleryContainer);
      createAdWrapper(check.exists(['SniAds.Gallery', 'SniAds.Event']), galleryContainer, template, config);
      setInterstitialConfig(config);
      if (check.exists(['SniAds.Gallery', 'SniAds.Event'])) {
        SniAds.ready(function () {
          createInterstitialContainer(config, galleryContainer, template);
        });
      }
      prepareGallery(galleryContainer, config.galleryLoadingClass);
      createCustomSliderEvents(context, config.sliderMessages, $.rsProto, $.rsModules);
      setAjaxConfig(context, config.ajaxUrl, config.ajaxPaging, config.isMobile, config.currentSearchResultsPage);
      startSlider(context, galleryContainer, config.rsConfig);
      updateDataAttributes(context, $galleryElement);
      setOnboardingTimeout(context, config.isMobile);
      // set md for first image if it is visible and active
      if ($(config.launchMeWrapper).length === 0) {
        doProcessMetadata();
      }
    },

    destroy: function destroy() {
      killItWithFire();
    },

    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'open-next-gallery':
          event.preventDefault();
          slider.next();
          setDetails(config.pvDetailsWrapCon, config.pvDetailsArray, slider.currSlideId);
          setDetails(config.pvProductsWrapCon, config.pvProductListArray, slider.currSlideId);
          transitionElements(slider.currSlide.content, config.galleryType, slider.currSlideId, config.rsOverflowCon, config.pvSlideWrapCon);
          break;
        case 'close-gallery-cta':
          doLaunch();
          break;
        case 'contain-gallery':
          traverseSlideshow(galleryContainer, config, event.pageX, slider, check, getInterstitial, goNextClick);
          break;
        case 'increment-slide':
          if ($(config.launchMeWrapper).length > 0) {
            doLaunch();
          } else {
            traverseSlideshow(galleryContainer, config, event.pageX, slider, check, getInterstitial, goNextClick);
          }
          break;
        case 'decrement-slide':
          traverseSlideshow(galleryContainer, config, event.pageX, slider, check, getInterstitial, goNextClick);
          break;
        case 'product-link':
          var dynamicSTL = config['shop-this-look'].dynamicSTL,
              partner = config['shop-this-look'].vendor,
              productTitle = $(element).closest('div[data-product-title]').data('product-title');

          // Format data for tracking
          var _metadata = dynamicSTL ? {
            partner: partner,
            title: partner + '|' + productTitle,
            imagecount: 'n/a',
            productcount: 'n/a'
          } : {
            title: productTitle
          };

          context.broadcast('product.clicked', _metadata);
          break;
        default:
          break;
      }
    }
  };

  return module;
});
// EXTERNAL MODULE: ./src/app/modules/instagram-embed.js
var instagram_embed = __webpack_require__(340);
var instagram_embed_default = /*#__PURE__*/__webpack_require__.n(instagram_embed);

// EXTERNAL MODULE: ./src/app/modules/jukebox.js
var jukebox = __webpack_require__(341);
var jukebox_default = /*#__PURE__*/__webpack_require__.n(jukebox);

// EXTERNAL MODULE: ./src/app/modules/load-more.js
var load_more = __webpack_require__(342);
var load_more_default = /*#__PURE__*/__webpack_require__.n(load_more);

// EXTERNAL MODULE: ./src/app/modules/mobile-nav.js
var mobile_nav = __webpack_require__(343);
var mobile_nav_default = /*#__PURE__*/__webpack_require__.n(mobile_nav);

// EXTERNAL MODULE: ./src/app/modules/multi-content-stream.js
var multi_content_stream = __webpack_require__(344);
var multi_content_stream_default = /*#__PURE__*/__webpack_require__.n(multi_content_stream);

// EXTERNAL MODULE: ./src/app/modules/newsletter.js
var newsletter = __webpack_require__(345);
var newsletter_default = /*#__PURE__*/__webpack_require__.n(newsletter);

// CONCATENATED MODULE: ./src/app/modules/next-up.js



SNI.Application.addModule('next-up', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.next-up');
  var check = context.getService('check').new(debug);
  var element = context.getElement();
  var $element = $(element);

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  var defaults = {
    blockSelector: '.m-MediaBlock',
    linkSelector: '.m-MediaBlock__a-Headline a',
    localStorageName: 'nextUp'
  };

  var settings = Object.assign({}, defaults, context.getConfig());

  var init = function init() {

    debug.log('Next-Up Module: initialized');

    // if no local storage just show the first one
    if (!check.supports('localStorage')) {
      $element.find(settings.selector + ':first').show();
      return false;
    }
    // go through each block and see if the link is to a page already visited
    $element.find(settings.blockSelector).each(function () {
      //console.log('i am this');
      var link = $(this).find(settings.linkSelector).attr('href');
      if (!isURLinLS(settings.localStorageName, link)) {
        // find the first block that is not in local storage, show it, and get out
        $(this).show();
        return false;
      }
    });

    addCurrentPageIntoLS(settings.localStorageName);
  };

  // storing the URL as an array of objects in case we ever want to add more data to it, like number of times visited or something
  function addCurrentPageIntoLS(lsKey) {

    var currentURL = window.location.pathname,
        URLsInLS = localStorage.getItem(lsKey),
        foundURL = false;

    try {
      URLsInLS = JSON.parse(URLsInLS);
    } catch (e) {
      URLsInLS = '';
    }

    // if we have an existing array
    if (Array.isArray(URLsInLS)) {

      $(URLsInLS).each(function () {

        // we currently are already storing this URL
        if (this.url === currentURL) {
          foundURL = true;
          return false;
        }
      });

      if (!foundURL) {
        URLsInLS.push({ 'url': currentURL });
      }
    } else {

      // we do not have an existing array so make one
      URLsInLS = [{ 'url': currentURL }];
    }

    localStorage.setItem(lsKey, JSON.stringify(URLsInLS));
  }

  function isURLinLS(lsKey, URL) {
    var URLsInLS = localStorage.getItem(lsKey),
        foundURL = false;

    try {
      URLsInLS = JSON.parse(URLsInLS);
    } catch (e) {
      URLsInLS = '';
    }

    if (Array.isArray(URLsInLS)) {

      $(URLsInLS).each(function () {
        // if we find an instance, return true
        if (this.url === URL) {
          foundURL = true;
          // break out of .each
          return false;
        }
      });

      // once we go through them, if not found, return false
      if (foundURL) {
        return true;
      } else {
        return false;
      }
    } else {

      // if no array, return false
      return false;
    }
  }

  return {
    init: init
  }; //end return
});
// EXTERNAL MODULE: ./src/app/modules/nutrition-info.js
var nutrition_info = __webpack_require__(346);
var nutrition_info_default = /*#__PURE__*/__webpack_require__.n(nutrition_info);

// EXTERNAL MODULE: ./src/app/modules/on-tv-full-width.js
var on_tv_full_width = __webpack_require__(347);
var on_tv_full_width_default = /*#__PURE__*/__webpack_require__.n(on_tv_full_width);

// EXTERNAL MODULE: ./src/app/modules/on-tv.js
var on_tv = __webpack_require__(348);
var on_tv_default = /*#__PURE__*/__webpack_require__.n(on_tv);

// EXTERNAL MODULE: ./src/app/modules/page.js
var page = __webpack_require__(349);
var page_default = /*#__PURE__*/__webpack_require__.n(page);

// EXTERNAL MODULE: ./src/app/modules/photo-category.js
var photo_category = __webpack_require__(350);
var photo_category_default = /*#__PURE__*/__webpack_require__.n(photo_category);

// EXTERNAL MODULE: ./src/app/modules/photo-gallery-launcher.js
var photo_gallery_launcher = __webpack_require__(351);
var photo_gallery_launcher_default = /*#__PURE__*/__webpack_require__.n(photo_gallery_launcher);

// EXTERNAL MODULE: ./src/app/modules/photo-gallery.js
var photo_gallery = __webpack_require__(352);
var photo_gallery_default = /*#__PURE__*/__webpack_require__.n(photo_gallery);

// EXTERNAL MODULE: ./src/app/modules/photo-grid.js
var photo_grid = __webpack_require__(353);
var photo_grid_default = /*#__PURE__*/__webpack_require__.n(photo_grid);

// EXTERNAL MODULE: ./src/app/modules/pinterest-embed.js
var pinterest_embed = __webpack_require__(354);
var pinterest_embed_default = /*#__PURE__*/__webpack_require__.n(pinterest_embed);

// EXTERNAL MODULE: ./src/app/modules/point-of-interest.js
var point_of_interest = __webpack_require__(355);
var point_of_interest_default = /*#__PURE__*/__webpack_require__.n(point_of_interest);

// EXTERNAL MODULE: ./src/app/modules/product-launch.js
var product_launch = __webpack_require__(356);
var product_launch_default = /*#__PURE__*/__webpack_require__.n(product_launch);

// EXTERNAL MODULE: ./src/app/modules/profile-promo.js
var profile_promo = __webpack_require__(357);
var profile_promo_default = /*#__PURE__*/__webpack_require__.n(profile_promo);

// EXTERNAL MODULE: ./src/app/services/url.js
var url = __webpack_require__(152);
var url_default = /*#__PURE__*/__webpack_require__.n(url);

// CONCATENATED MODULE: ./src/app/modules/program-schedule.js

/**
 * This module is used on tv schedule pages
 */
SNI.Application.addModule('program-schedule', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  // let debug = context.getService('logger').create('module.program-schedule');
  var $element = $(context.getElement());
  var defaults = {};
  var config = Object.assign({}, defaults, context.getConfig());
  var url = context.getService('url');

  var millisPerMinute = 1000 * 60;
  var tenMinutesBeforeInMillis = -10 * millisPerMinute;
  var twentyMinutesAfterInMillis = 20 * millisPerMinute;

  /**
   * Removes the "Load Earlier Shows" button
   * @returns {void}
   */
  var removeLoadEarlierBtn = function removeLoadEarlierBtn() {
    return $element.find('[data-type="btn-load-earlier"]').remove();
  };

  /**
   * Gets the air time of the episode from the DOM
   * @param {JQueryElement} $episodeCard
   */
  var getEpisodeTime = function getEpisodeTime($episodeCard) {
    return new Date($episodeCard.attr('data-time'));
  };

  /**
   * @return {Number}
   * @param {Date} present 
   * @param {Date} past 
   */
  var minutesElapsed = function minutesElapsed(present, past) {
    return Math.floor((present.getTime() - past.getTime()) / millisPerMinute);
  };

  /**
   * @param {Date} currentTime 
   * @param {Date} airTime 
   */
  var isPastEpisode = function isPastEpisode(currentTime, airTime) {
    return currentTime.getTime() > airTime.getTime();
  };

  /**
   * returns true if any elements have the episode-past class
   */
  var hasPastEpisodes = function hasPastEpisodes() {
    return $element.find('.episode-past').length > 0;
  };

  /**
   * Ensures the last hour or the last two thirty minute episodes are revealed.
   * See COOKXP-138.
   * @param {JQueryElement} $episodeCard 
   */
  var revealPreviousEpisodes = function revealPreviousEpisodes($episodeCard) {
    var $lastEpisode = $episodeCard.prev();

    // No previous episode, skip out
    if (!$lastEpisode.length) return;

    $lastEpisode.removeClass('episode-past');

    if (minutesElapsed(getEpisodeTime($episodeCard), getEpisodeTime($lastEpisode)) <= 30) {
      $lastEpisode.prev().removeClass('episode-past');
    }
  };

  // Note that unlike 'whatsOnTv' component, the data-time is correctly correct for all timezones, there is no need to shift.
  // This is because the date and timezone can optionally be specified to the server when the page render.
  // E.g. http://localhost:4502/content/hgtv-com/en/shows/tv-schedule.2013.06.06.EST.html
  function hidePastSchedule(now) {
    var notNow = true;
    var watchUrl = url.watchSite();

    $element.find('.m-EpisodeCard').each(function (__, episodeCard) {
      var $episodeCard = $(episodeCard);
      var airTime = getEpisodeTime($episodeCard);

      var diff = now.getTime() - airTime.getTime();
      var onNow = tenMinutesBeforeInMillis <= diff && diff < twentyMinutesAfterInMillis;

      if (onNow) {
        notNow = false;
        $episodeCard.find('.m-DateBlock__m-TextWrap').prepend('<span class="m-DateBlock__a-Label">On Now</span>');
        if (watchUrl) {
          $episodeCard.find('.m-MediaBlock__m-TextWrap').append('<a class="m-MediaBlock__a-Button" href="' + watchUrl + '">Watch Live TV</a>');
        }
        revealPreviousEpisodes($episodeCard);
      } else if (isPastEpisode(now, airTime)) {
        $episodeCard.addClass('episode-past');
      }
    });

    if (notNow && watchUrl) {
      var $episodeCard = $element.find('.m-EpisodeCard:not(.episode-past)').first();

      revealPreviousEpisodes($episodeCard);

      $episodeCard.find('.m-MediaBlock__m-TextWrap').append('<a class="m-MediaBlock__a-Button" href="' + watchUrl + '">Watch Live TV</a>');
    }

    if (!hasPastEpisodes()) {
      removeLoadEarlierBtn();
    }
  }

  function init() {
    var now = new Date();
    var scheduleDate = new Date(parseInt(config.scheduleDate, 10));

    // scheduleDate came from UTC, so we need to adjust;
    scheduleDate.setMinutes(now.getTimezoneOffset());

    var isTodaySchedule = now.getDate() === scheduleDate.getDate() && now.getMonth() === scheduleDate.getMonth() && now.getFullYear() === scheduleDate.getFullYear();

    if (isTodaySchedule) {
      hidePastSchedule(now);
    } else {
      removeLoadEarlierBtn();
    }
  }

  function handleClick(evt, elt, eltType) {
    if (eltType === 'btn-load-earlier') {
      $element.removeClass('episodes-hide-past');
      $(elt).parent().remove();
      evt.preventDefault();
    }
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {

    init: init,

    onclick: handleClick

  };
});
// EXTERNAL MODULE: ./src/app/modules/promo-collage.js
var promo_collage = __webpack_require__(358);
var promo_collage_default = /*#__PURE__*/__webpack_require__.n(promo_collage);

// EXTERNAL MODULE: ./src/app/modules/recipe-body.js
var recipe_body = __webpack_require__(359);
var recipe_body_default = /*#__PURE__*/__webpack_require__.n(recipe_body);

// EXTERNAL MODULE: ./src/app/modules/recipe-box-nav.js
var recipe_box_nav = __webpack_require__(360);
var recipe_box_nav_default = /*#__PURE__*/__webpack_require__.n(recipe_box_nav);

// EXTERNAL MODULE: ./src/app/modules/recipe-info.js
var recipe_info = __webpack_require__(361);
var recipe_info_default = /*#__PURE__*/__webpack_require__.n(recipe_info);

// EXTERNAL MODULE: ./src/app/modules/recipe-ingredients.js
var recipe_ingredients = __webpack_require__(362);
var recipe_ingredients_default = /*#__PURE__*/__webpack_require__.n(recipe_ingredients);

// EXTERNAL MODULE: ./src/app/modules/recipe-lead.js
var recipe_lead = __webpack_require__(363);
var recipe_lead_default = /*#__PURE__*/__webpack_require__.n(recipe_lead);

// EXTERNAL MODULE: ./src/app/modules/recipe-method.js
var recipe_method = __webpack_require__(364);
var recipe_method_default = /*#__PURE__*/__webpack_require__.n(recipe_method);

// EXTERNAL MODULE: ./src/app/modules/recipe-playlist.js
var recipe_playlist = __webpack_require__(365);
var recipe_playlist_default = /*#__PURE__*/__webpack_require__.n(recipe_playlist);

// EXTERNAL MODULE: ./src/app/modules/recipe-search-form.js
var recipe_search_form = __webpack_require__(366);
var recipe_search_form_default = /*#__PURE__*/__webpack_require__.n(recipe_search_form);

// EXTERNAL MODULE: ./src/app/modules/recipe-shopping-list.js
var recipe_shopping_list = __webpack_require__(367);
var recipe_shopping_list_default = /*#__PURE__*/__webpack_require__.n(recipe_shopping_list);

// EXTERNAL MODULE: ./src/app/modules/recipe-video.js
var recipe_video = __webpack_require__(368);
var recipe_video_default = /*#__PURE__*/__webpack_require__.n(recipe_video);

// EXTERNAL MODULE: ./src/app/modules/related-videos.js
var related_videos = __webpack_require__(369);
var related_videos_default = /*#__PURE__*/__webpack_require__.n(related_videos);

// EXTERNAL MODULE: ./src/app/modules/reviews-that-matter.js
var reviews_that_matter = __webpack_require__(370);
var reviews_that_matter_default = /*#__PURE__*/__webpack_require__.n(reviews_that_matter);

// EXTERNAL MODULE: ./src/app/modules/search-filter.js
var search_filter = __webpack_require__(371);
var search_filter_default = /*#__PURE__*/__webpack_require__.n(search_filter);

// EXTERNAL MODULE: ./src/app/modules/search-filters.js
var search_filters = __webpack_require__(372);
var search_filters_default = /*#__PURE__*/__webpack_require__.n(search_filters);

// CONCATENATED MODULE: ./src/app/behaviors/typeahead/hints.js


var HAS_HINTS_CLASS = 'has-Hints';
var TYPEAHEAD_HINTS_CONTAINER_SELECTOR = '[data-typeahead-hints]';

var hints_hideHints = function hideHints($element) {
  var searchFormWrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SEARCH_FORM_WRAPPER_SELECTOR;
  var hasHints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HAS_HINTS_CLASS;

  var $hintsContainer = $element.find(TYPEAHEAD_HINTS_CONTAINER_SELECTOR);
  if ($hintsContainer.length > 0) {
    $hintsContainer.empty().closest(searchFormWrapper).removeClass(hasHints);
  }
};

var hints_showHints = function showHints($element, hints) {
  var searchFormWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SEARCH_FORM_WRAPPER_SELECTOR;
  var hasHints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : HAS_HINTS_CLASS;

  var $hintsContainer = $element.find(TYPEAHEAD_HINTS_CONTAINER_SELECTOR);
  if (hints !== '') {
    $hintsContainer.closest(searchFormWrapper).addClass(hasHints);
  }

  $hintsContainer.html(hints);
};
// CONCATENATED MODULE: ./src/app/modules/search-form.js


/** 
 * NOTE: There's an explicit dependency on this selector by the typeahead behavior 
 * This selector appears along side the hints class which decorates some css
 * properties on the search form when there are typeahead hints. 
 **/
var SEARCH_FORM_WRAPPER_SELECTOR = '[data-search-form-wrapper]';

/**
 * This selector targets the element that houses the populated class which
 * reveals the clear button when there is text in the field. 
 */
var SEARCH_FORM_FIELD_SELECTOR = '[data-search-form-field]';

/**
 * Present on the field when there is some text in the search form. CSS
 * hooks into this to reveal the clear button.
 */
var IS_POPULATED_CLASS = 'is-Populated';

/**
 * 
 * @param {jQueryElement} $element The jQuery element representing the current module
 * @param {jQueryElement} $input The jQuery element representing the input field to be reset
 * @param {Boolean} focus If the input should be given focus after clearing
 */
var search_form_resetInput = function resetInput($element, $input) {
  var focus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  focus ? $input.val('').focus() : $input.val('');
  $element.find(SEARCH_FORM_FIELD_SELECTOR).removeClass(IS_POPULATED_CLASS);
  hints_hideHints($element);
};

SNI.Application.addModule('search-form', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var defaults = {
    searchType: 'module search'
  };

  var $element = $(context.getElement());
  var config = Object.assign({}, defaults, context.getConfig());
  var debug = context.getService('logger').create('module.search-form');
  var check = context.getService('check').new(debug);
  var util = context.getService('utility');

  var mdManager = context.getGlobal('mdManager');
  var location = context.getGlobal('location');
  var cqWCMDisabled = context.getGlobal('cqWCMDisabled');

  var $searchInput = void 0;

  var deviceType = context.getService('device-type');
  var siteSlug = config.searchSite ? config.searchSite : check.exists('mdManager') && mdManager.getParameter('site') ? mdManager.getParameter('site').replace(/-.*$/, '') : '';

  // TODO: Break this down and clean it up
  var doSubmit = function doSubmit($form) {
    var formAction = $form.attr('action');

    var isInHeaderFooter = $form.attr('id').indexOf('siteSearchInput_') > -1 || typeof $form.attr('data-mobile-search-box') !== 'undefined';
    if (isInHeaderFooter) {
      formAction = check.isFriendlyHost() ? '/search' : '/content/' + siteSlug + '-com/en/search.html';
    } else {
      if (!check.isFriendlyHost() && $form.attr('id') === 'photoSearchInput') {
        formAction = '/content/' + siteSlug + '-photos/en/photo-library.html';
      }
    }
    if (deviceType.isMobile && !check.isFriendlyHost()) {
      if (formAction.match(/\.html/g) && !formAction.match(/\.mobile.\.html/g)) {
        formAction = formAction.replace(/\.html/g, '.mobile.html');
      }
    }
    if (formAction.indexOf('//') === -1) {
      formAction = location.protocol + '//' + util.getMainHostname() + formAction;
    }

    if (config.forceUrl) {
      formAction = config.forceUrl;
    }

    var queryActionSuffix = check.isAuthor() ? '-.html' + (cqWCMDisabled ? '?wcmmode=disabled' : '') : '-';
    var formTerm = decodeURI($searchInput.val()).replace(/\%3D/g, '').replace(/\=/g, '').replace(/\%3C/g, '').replace(/</g, '').replace(/\%28/g, '').replace(/\(/g, '').replace(/\"/g, '').replace(/\%3F/g, '').replace(/\?/g, '');

    $searchInput.val(formTerm);

    var searchQueryAction = formTerm.replace(/\-/g, '_').replace(/\s/g, '-').replace(/\%20/g, '-');

    var href = formAction + '/' + searchQueryAction + queryActionSuffix;
    var searchFormMetrics = { internalSearchType: config.searchType };

    if (check.supports('localStorage')) {
      localStorage.setItem('searchFormMetrics', JSON.stringify(searchFormMetrics));
    }

    /** If in an iframe, open search in a new window.*/
    if (window.top !== window.self) {
      window.open(href);
    } else {
      /** doing window location here for CQ. If we just change the action and natively submit this form, it will add a querystring (or POST). Either of these methods break CQ caching, so we cannot do it. Because of that, we have to hack a bit with the form submission */
      window.location = href;
    }

    return false;
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  return {
    behaviors: ['typeahead'],
    init: function init() {
      $searchInput = $element.find('[data-type="search-input"]');

      $searchInput.on('input', function (event) {
        $element.find(SEARCH_FORM_FIELD_SELECTOR).toggleClass(IS_POPULATED_CLASS, event.target.value.length > 0);
      });
    },
    onmousedown: function onmousedown(event, element, elementType) {
      if (elementType === 'reset-btn') {
        event.preventDefault();
      }
    },
    onsubmit: function onsubmit(event) {
      event.preventDefault();
      doSubmit($element);
    },
    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'reset-btn':
          search_form_resetInput($element, $searchInput, true);
          break;
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/modules/select-button.js
var select_button = __webpack_require__(373);
var select_button_default = /*#__PURE__*/__webpack_require__.n(select_button);

// EXTERNAL MODULE: ./src/app/modules/shopping-embed.js
var shopping_embed = __webpack_require__(374);
var shopping_embed_default = /*#__PURE__*/__webpack_require__.n(shopping_embed);

// EXTERNAL MODULE: ./src/app/modules/shopping-lead.js
var shopping_lead = __webpack_require__(375);
var shopping_lead_default = /*#__PURE__*/__webpack_require__.n(shopping_lead);

// EXTERNAL MODULE: ./src/app/modules/shopping-promo.js
var shopping_promo = __webpack_require__(376);
var shopping_promo_default = /*#__PURE__*/__webpack_require__.n(shopping_promo);

// EXTERNAL MODULE: ./src/app/services/template.js
var services_template = __webpack_require__(104);
var services_template_default = /*#__PURE__*/__webpack_require__.n(services_template);

// CONCATENATED MODULE: ./src/app/services/utility.js



SNI.Application.addService('utility', function (application) {

  var check = application.getService('check').new();

  var counter = 0;

  function deepMerge(target, src) {
    var array = Array.isArray(src);
    var dst = array && [] || {};

    if (array) {
      target = target || [];
      dst = dst.concat(target);
      src.forEach(function (e, i) {
        if (typeof dst[i] === 'undefined') {
          dst[i] = e;
        } else if ((typeof e === 'undefined' ? 'undefined' : helpers_typeof_default()(e)) === 'object') {
          dst[i] = deepMerge(target[i], e);
        } else {
          if (target.indexOf(e) === -1) {
            dst.push(e);
          }
        }
      });
    } else {
      if (target && (typeof target === 'undefined' ? 'undefined' : helpers_typeof_default()(target)) === 'object') {
        Object.keys(target).forEach(function (key) {
          dst[key] = target[key];
        });
      }
      Object.keys(src).forEach(function (key) {
        if (helpers_typeof_default()(src[key]) !== 'object' || !src[key]) {
          dst[key] = src[key];
        } else {
          if (!target[key]) {
            dst[key] = src[key];
          } else {
            dst[key] = deepMerge(target[key], src[key]);
          }
        }
      });
    }

    return dst;
  }

  function bindClickOutside($el, namespace, fn, exception) {
    setTimeout(function () {
      $(document).on('click.' + namespace, function (e) {
        var isOutsideMenu = $(e.target) !== $el && !$.contains($el[0], e.target);
        if (isOutsideMenu && (!exception || e.target !== exception)) {
          e.preventDefault();
          fn(e);
        }
      });
      //allow escape key to call 'fn'
      $(document).on('keyup.' + namespace, function (e) {
        e.which === 27 && fn(e);
      });
    }, 1);
  }

  function unbindClickOutside(namespace) {
    $(document).off('click.' + namespace);
    $(document).off('keyup.' + namespace);
  }

  function getMainHostname() {
    var originalHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.hostname;


    // Don't mutate original hostname
    var host = originalHost;

    if (check.isFriendlyHost(host)) {

      //special case for golden-www.brand.com
      var splitHost = host.split('.');
      if (splitHost.length === 3 && splitHost[0] === 'golden-www') {
        return host;
      }

      // If golden subdomain is used, switch to main golden domain
      if (splitHost[0].includes('golden-')) {
        host = host.replace(/^[^\.]*/g, 'golden-www');
      } else {
        host = host.replace(/^[^\.]*/g, 'www');
      }
    }
    return host;
  }

  function stdTimezoneOffset(date) {
    var jan = new Date(date.getFullYear(), 0, 1),
        jul = new Date(date.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }

  function isDaylightSavings(date) {
    return date.getTimezoneOffset() < stdTimezoneOffset(date);
  }

  function getZone(dateTime) {
    var dst = isDaylightSavings(dateTime);
    var zone = 'eastern';
    switch (dateTime.getTimezoneOffset()) {
      default:
        zone = 'eastern'; // eastern|central|mountain|pacific
        break;
      case 240:
        // GMT -4:00
        zone = 'eastern';
        break;
      case 300:
        // GMT -5:00
        zone = dst ? 'central' : 'eastern';
        break;
      case 360:
        // GMT -6:00
        zone = dst ? 'mountain' : 'central';
        break;
      case 420:
        // GMT -7:00
        zone = dst ? 'pacific' : 'mountain';
        break;
      case 480:
        // GMT -8:00
        zone = 'pacific';
        break;
    }
    return zone;
  }

  return {
    isDebug: function isDebug() {
      return this.getUrlParam(window.location.href, 'debug') === 'true' || check.supports('localStorage') && localStorage.getItem('debug') === 'true';
    },


    /*
    * memoize.js
    * by @philogb and @addyosmani
    * with further optimizations by @mathias
    * and @DmitryBaranovsk
    * perf tests: http://bit.ly/q3zpG3
    * Released under an MIT license.
    */
    memoize: function memoize(fn) {
      return function () {
        var args = Array.prototype.slice.call(arguments),
            hash = '',
            i = args.length,
            currentArg = null;
        while (i--) {
          currentArg = args[i];
          hash += currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg;
          fn.memoize || (fn.memoize = {});
        }
        return hash in fn.memoize ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);
      };
    },


    /**
     * This function goes into the element provided and pulls out either data attributes per setting or a JSON object of settings as override
     */
    getSettings: function getSettings(defaults, $element) {
      /** TODO: Get out of not a jquery element passed in */
      var options = {},
          settings = {};

      /** go through the defaults and see if for any of them we have individual data attributes specified */
      for (var key in defaults) {
        if ($element.data(key) !== undefined) {
          options[key] = $element.data(key);
        }
      }

      /** we have the concept of overrides, so if someone created an override vs single data attribute, go ahead and include that */
      var overrides = $element.data('moduleOverrides');
      if (overrides) {
        if (typeof overrides === 'string') {
          overrides = overrides.trim();
          overrides = overrides.length ? JSON.parse(overrides) : {};
        }
        options = $.extend(true, options, overrides);
      }

      /** return the defaults overriden with the passed in options as settings */
      settings = $.extend(true, {}, defaults, options);
      return settings;
    },


    /**
     * This will register your function as a jQuery plugin
     * @constructor
     * @param {string} fnName - The named function.
     * @param {object} fnRef - A reference to the function.
     */
    registerjQueryPlugin: function registerjQueryPlugin(fnName, FnRef) {

      // PLUGIN DEFINITION
      // =========================

      var old = $.fn[fnName];

      $.fn[fnName] = function (option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('sni.' + fnName);
          var options = (typeof option === 'undefined' ? 'undefined' : helpers_typeof_default()(option)) === 'object' && option;

          if (!data && option === 'destroy') return;
          if (!data) $this.data('sni.' + fnName, data = new FnRef(this, options));
          if (typeof option === 'string') data[option]();
        });
      };

      $.fn[fnName].Constructor = FnRef;

      // NO CONFLICT
      // ===================

      $.fn[fnName].noConflict = function () {
        $.fn[fnName] = old;
        return this;
      };
    },


    /**
     * Get a URL parameter value
     * @param  {string} param URL
     * @param  {string} param Parameter name
     * @return {string}       Parameter value
     */
    getUrlParam: function getUrlParam(url, param) {
      param = param.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
      var regex = new RegExp('[\\?&]' + param + '=([^&#]*)'),
          results = regex.exec(url);
      return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    },


    /**
     * Determine if an element is within the viewport. Uses a 'visibility' parameter to determine if the entire element is
     * in view (full) or if any part of the element is in view (partial).
     * @param  {DOMElement}  el           DOM element to test
     * @param  {string}      visibility  'full' or 'partial'
     * @return {Boolean}
     */
    isInViewport: function isInViewport(el, visibility) {
      var rect = el.getBoundingClientRect();

      if (rect.top + rect.left + rect.bottom + rect.right === 0) return false; // bail on 0 size rects

      /** Give 'visibility' a default if it's not provided */
      if (!visibility) {
        visibility = 'full';
      }

      /** Return true if the entire element is in the viewport */
      if (visibility === 'full') {
        return rect.top >= 0 && rect.left >= 0 && rect.bottom <= $(window).height() && rect.right <= $(window).width();
      }

      /** Return true if any part of the element is in the viewport */
      if (visibility === 'partial') {
        return rect.top <= $(window).height() && rect.bottom >= 0 && rect.right >= 0;
      }
    },


    /*
      Calculate how much of an element is visible on the viewport
      */
    percentVisible: function percentVisible(element) {
      if (!(element && element.getBoundingClientRect)) return 0; // nothing to see here
      var rect = element.getBoundingClientRect();
      var height = rect.height,
          top = rect.top,
          bottom = rect.bottom;

      var finalHeight = void 0;
      var windowHeight = window.innerHeight;

      if (top > windowHeight || bottom < 0) {
        // Not in view
        finalHeight = 0;
      } else if (top >= 0 && bottom <= windowHeight) {
        //   In full view
        finalHeight = height;
      } else {
        // partially in view
        var calcTop = top < 0 ? 0 : top;
        var calcBot = bottom < windowHeight ? bottom : windowHeight;
        finalHeight = calcBot - calcTop;
      }

      return finalHeight / height * 100;
    },
    getIdFromSelector: function getIdFromSelector(selector) {
      return selector.split(' #').pop().replace(/#/g, '').trim();
    },
    setCounter: function setCounter(amount) {
      counter = amount;
    },
    getCounter: function getCounter() {
      return counter;
    },


    ajaxLoadScript: function ajaxLoadScript(scriptUrl) {
      $.getScript(scriptUrl).done(function (script, textStatus) {
        $('div.log').text('ajaxLoadScript()loaded successfully! It was a ' + textStatus);
      }).fail(function (jqxhr, settings, exception) {
        $('div.log').text('ajaxLoadScript() source error!');
      });
    },

    addJavaScriptCssClass: function addJavaScriptCssClass() {
      $('html').addClass('js core-js');
    },

    throttle: function throttle(fn, threshhold, scope) {
      threshhold || (threshhold = 250);
      var last = void 0,
          deferTimer = void 0;
      return function () {
        var context = scope || this;

        var now = +new Date(),
            args = arguments;
        if (last && now < last + threshhold) {
          // hold on to it
          clearTimeout(deferTimer);
          deferTimer = setTimeout(function () {
            last = now;
            fn.apply(context, args);
          }, threshhold);
        } else {
          last = now;
          fn.apply(context, args);
        }
      };
    },


    getMainHostname: getMainHostname,

    getModuleConfig: application.getModuleConfig,

    bindClickOutside: bindClickOutside,

    unbindClickOutside: unbindClickOutside,

    deepMerge: deepMerge,

    stdTimezoneOffset: stdTimezoneOffset,

    isDaylightSavings: isDaylightSavings,

    getZone: getZone
  };
});
// CONCATENATED MODULE: ./src/app/services/lazy-load.js



SNI.Application.addService('lazy-load', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var _$images = false,
      //this will be an object that holds all the images in the current page that we'll be lazy loading, populated by addImages()
  modUtil = context.getService('utility'),
      debug = context.getService('logger').create('service.lazy-load'),
      deviceType = context.getService('device-type'),
      $window = $(window),
      loadEvent = 'scroll.lazy-load resize.lazy-load',
      loadEventEnglish = loadEvent.split(' ').join('|'),
      settingsKey = 'sni.lazyLoadSettings';

  function applyToBackground(el, url) {
    $(el).parent().addClass('has-LazyLoadedBackground').css({
      backgroundImage: 'url(\'' + url + '\')'
    });
  }

  function shouldApplyToBackground(settings) {
    var value = settings.moveImageToBackground;
    return typeof value !== 'undefined' && value.constructor === Array && (value.includes('desktop') && !deviceType.isMobile || value.includes('mobile') && deviceType.isMobile);
  }

  /**
   * Iterate through an array of images and modify each image to use replace the src attribute with the data-src
   * attribute.
   *
   * @private
   * @param  {array} images    Array of images to load
   */
  function loadImages($images) {
    var count = 0;

    $images.each(function () {
      var el = this,
          settings = getSettings($(el)),
          currentSrc = el.getAttribute('src'),
          dataSrc = el.getAttribute('data-src'),
          allowed = settings.usePlaceholder ? settings.placeholder === currentSrc : !currentSrc;

      if (dataSrc && allowed) {
        if (shouldApplyToBackground(settings)) {
          applyToBackground(el, dataSrc);
        } else {
          el.setAttribute('src', dataSrc);
        }
        count++;
      }
    });

    if (count > 0) {
      debug.log(count + ' images started loading in ' + $images.eq(0).closest('[data-module]').attr('id') + '.');
    }
    return removeLoading($images);
  }

  /** Remove loaded images from the list of images so we'll know when there are no more to load */
  function removeLoading($loading) {
    _$images = _$images.not($loading);
    return $loading;
  }

  /**
   * Given an array of images, determine which images are in the viewport and return an array of only the
   * visible images.
   *
   * @private
   * @param  {object} $window   Window object
   * @param  {array}  $images   Array of all images available to the module
   * @return {array}            Array of visible images
   */
  function getVisibleImages($window, $images) {
    var inview = $images.filter(function () {
      return modUtil.isInViewport(this, 'partial');
    });
    return inview;
  }

  /**
   * Polling function fired every time the window is scrolled. Calls getVisibleImages to determine which
   * images are in the viewport and then calls loadImages on the visible images.
   *
   * @private
   * @param  {jQuery object} $w   The window
   * @param  {array} $images      Array of all images to be tracked
   */
  function trackInview($window, $images) {
    var $inview = getVisibleImages($window, $images),
        $loading = $();

    if ($inview.length > 0) {
      $loading = loadImages($inview);
    }
    return $loading;
  }

  function getSettings($el) {
    return $el.data(settingsKey);
  }

  function getImagesByType(triggerType, $images) {
    return _$images.filter(function () {
      var s = getSettings($(this));
      return s && s.trigger === triggerType;
    });
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  var service = {
    init: function init() {
      if (!service.inited) {
        /** Track on scroll and resize until all _$images are loaded. */
        $window.on(loadEvent, function () {
          debug.log(loadEventEnglish + ' fired.');
          if (_$images === false) {
            debug.warn('...before addImages() did.');
          } else {
            trackInview($window, getImagesByType('inview'));
            loadImages(getImagesByType('scroll'));

            if (_$images.length === 0) {
              debug.log('no more images left to lazy load.');
              service.destroy();
            }
          }
        });
        service.inited = true;
      }
      return service;
    },
    forceScroll: function forceScroll() {
      var count = 1;
      var fire = setInterval(function () {
        //allow some time for dom changes and fire again, as dom changes are the use case for this method
        if (count > 10) {
          clearInterval(fire);
        } else {
          $window.trigger(loadEvent.split(' ')[0]);
        }
        count++;
      }, 30);
    },


    inited: false,

    /**
     * Given module parameters, add images and application data to the $_images list of images we'll be lazy loading
     *
     * @public
     * @param  {object} obj     In the following format:
     *  {
     *    container: [module element wrapped in jQuery object],
     *    settings:  [settings object merged from defaults in behavior and markup],
     *  }
     */
    addImages: function addImages(obj) {
      var settings = obj.settings,
          $element = obj.container,
          $addImgs = $element.find('img'),
          $hasDataSrc = $addImgs.filter('[data-src]');

      if ($addImgs.length !== $hasDataSrc.length) {
        debug.warn('found images missing data-src attributes.', $addImgs.not($hasDataSrc));
      }

      /** Replace the existing src with a base64 encoded placeholder. A blank src attribute can trigger http requests and should be avoided. The placeholder gives the image position in the page so that it's not skipped as a hidden element */
      if (settings.usePlaceholder) {
        $addImgs.filter('[data-src]').attr('src', settings.placeholder);
      }

      _$images = _$images === false ? $addImgs : _$images.add($addImgs);

      if ($addImgs.length) {
        trackInview($window, $addImgs.data(settingsKey, settings));
      } else {
        debug.warn('no lazy-loadable images found in element:', $element);
      }
    },


    loadImages: loadImages, //  Used when images are not in view but we still need to load them dynamically

    destroy: function destroy() {
      service.inited = false;
      _$images = false;
      $window.off(loadEvent);
      debug.log('destroying service and unbinding ' + loadEventEnglish + '.');
      return service;
    }
  };

  return service;
});
// CONCATENATED MODULE: ./src/app/modules/shopping.js





SNI.Application.addModule('shopping', function (context) {

  var debug = context.getService('logger').create('module.shopping'),
      device = context.getService('device-type'),
      template = context.getService('template'),
      lazy = context.getService('lazy-load'),
      shopping = context.getService('track-shopping');

  var $element = void 0,
      $carousel = void 0,
      defaults = void 0,
      config = void 0;

  defaults = {
    type: 'inspirational',
    productListSelector: '.productList',
    productListOrganism: '.o-ProductList',
    carouselSelector: '.m-Carousel',
    activeClass: '.active',
    fullWidth: false
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function hideAllProducts() {
    $element.find(config.productListSelector).removeClass('show').addClass('hide');
  }

  function displayProductList(index) {
    $element.find(config.productListSelector + '[data-index=\'' + index + '\']').removeClass('hide').addClass('show');
  }

  function updateProduct(el) {
    var currentIndex = void 0;
    if ($(el).attr('data-index')) {
      currentIndex = $(el).attr('data-index');
      context.broadcast('carousel.update.slide', {
        index: currentIndex,
        carouselId: $element.find('[data-module="carousel"]').attr('id')
      });
    }
  }

  function getMetaData() {
    var metadata1 = $element.data('mdm') || {},
        metadata2 = {};

    if (!$carousel.length) {
      metadata2 = $(config.carouselSelector, context.getElement()).find('[data-mdm]').data('mdm');
    } else {
      metadata2 = $carousel.find(config.activeClass).find('[data-mdm]').data('mdm');
    }

    return updateObject(metadata1, metadata2);
  }

  function trackProductClick(title) {
    var metadata = getMetaData();

    metadata.products = title;
    shopping.trackProductClick(metadata);
  }

  return {
    behaviors: ['lazy-load'],

    init: function init() {
      debug.log('shopping init!');
      $element = $(context.getElement());
      $carousel = $element.find('[data-module="carousel"]');
      setConfig(defaults, context.getConfig());
      if (config.fullWidth || device.isMobile) {
        $(config.productListOrganism).prepend(template.productIndicator('o-ProductList__a-ProductIndicator'));
      }
    },

    onmessage: {
      'carousel.slideUpdated': function carouselSlideUpdated(data) {
        switch (config.type) {
          case 'inspirational':
            if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id')) {
              hideAllProducts();
              displayProductList(data.updatedSlide);
              shopping.trackProductImpression(getMetaData());
              lazy.forceScroll();
            }
            break;
          default:
            break;
        }
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'update-product':
          event.preventDefault();
          if (config.type === 'multi') {
            event.preventDefault();
            updateProduct(element);
          }
          break;
        case 'product-link':
          trackProductClick($(element).closest('div[data-product-title]').data('product-title'));
          break;
        default:
          break;
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/modules/show-more.js
var show_more = __webpack_require__(377);
var show_more_default = /*#__PURE__*/__webpack_require__.n(show_more);

// EXTERNAL MODULE: ./src/app/modules/show-promo.js
var show_promo = __webpack_require__(378);
var show_promo_default = /*#__PURE__*/__webpack_require__.n(show_promo);

// EXTERNAL MODULE: ./src/app/modules/site-search-results.js
var site_search_results = __webpack_require__(379);
var site_search_results_default = /*#__PURE__*/__webpack_require__.n(site_search_results);

// EXTERNAL MODULE: ./src/app/modules/social-share.js
var social_share = __webpack_require__(380);
var social_share_default = /*#__PURE__*/__webpack_require__.n(social_share);

// EXTERNAL MODULE: ./src/app/modules/story-promo.js
var story_promo = __webpack_require__(381);
var story_promo_default = /*#__PURE__*/__webpack_require__.n(story_promo);

// EXTERNAL MODULE: ./src/app/modules/sub-navigation.js
var sub_navigation = __webpack_require__(382);
var sub_navigation_default = /*#__PURE__*/__webpack_require__.n(sub_navigation);

// EXTERNAL MODULE: ./src/app/modules/super-lead-hero.js
var super_lead_hero = __webpack_require__(383);
var super_lead_hero_default = /*#__PURE__*/__webpack_require__.n(super_lead_hero);

// EXTERNAL MODULE: ./src/app/modules/tabbed-mobile-search.js
var tabbed_mobile_search = __webpack_require__(384);
var tabbed_mobile_search_default = /*#__PURE__*/__webpack_require__.n(tabbed_mobile_search);

// EXTERNAL MODULE: ./src/app/modules/theme-selector.js
var theme_selector = __webpack_require__(385);
var theme_selector_default = /*#__PURE__*/__webpack_require__.n(theme_selector);

// EXTERNAL MODULE: ./src/app/modules/tweet-embed.js
var tweet_embed = __webpack_require__(386);
var tweet_embed_default = /*#__PURE__*/__webpack_require__.n(tweet_embed);

// CONCATENATED MODULE: ./src/app/modules/vertical-gallery.js

SNI.Application.addModule('vertical-gallery', function (context) {
  'use strict';

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var debug = context.getService('logger').create('module.vertical-gallery'),
      check = context.getService('check').new(debug),
      modUtil = context.getService('utility'),
      template = context.getService('template'),
      modal = context.getService('modal'),
      metadata = context.getService('metadata'),
      analytics = context.getService('analytics'),
      mediaStream = context.getService('media-stream'),
      deviceType = context.getService('device-type'),
      ajaxService = context.getService('ajax'),
      coldLoad = true,
      SniAds = void 0,
      mdManager = void 0,
      adLibLoaded = void 0,
      collapsibleFooterTemplate = void 0,
      module = void 0,
      element = void 0,
      $element = void 0,
      config = void 0,
      defaults = void 0;

  defaults = {
    autoLoadMore: false,
    loadMoreCheck: false,
    loadSelector: '[data-ui-loader]',
    galleryType: 'dynamic',
    galleryAdsContainer: '.photoLibraryViewerPage',
    watchScroll: true,
    modContainer: '',
    photoBoxId: window.location.href.indexOf('qa1') > -1 ? '00000147-5e54-d873-a7cf-fff6fe0f0000' : '00000147-82ed-dfc8-ad6f-bbede4210000',
    headlineSelector: '.o-PhotoGalleryPromo__a-Headline',
    hotspot: true,
    hotspotUrl: window.location.pathname,
    hotspotUrlName: 'hotspotUrl',
    hotspotElement: '[data-hotspot-el]',
    currHotspotEnabled: '',
    modalScrollOffset: '',
    cardScrollOffset: '',
    filterScrollOffset: '',
    backButton: '<button type="button" class="icon icon-angle-up btn btn-primary btn-back-to-top smooth-hide">TOP</button>',
    topClass: '.btn-back-to-top',
    cardTextSelector: '[data-text]', // Container for card text
    cardSelector: '[data-card]',
    previousCard: $(),
    currentCard: $('[data-card]').first(),
    previousPartialCard: $(),
    currentPartialCard: $('[data-card]').first(),
    secondPass: false,
    currentModal: '',
    overlayBigboxName: '',
    overlayPhotoIntName: '',
    overlayPhotoIntMobileName: '',
    mpbRefreshHref: '',
    mpbAssetId: '',
    device: '',
    currentSite: '',
    animatedClass: 'animated',
    animatedSelector: '.animated',
    separatorClass: '.o-Article__m-Divider',
    collapsibleFooterButton: '.collapsible-footer',
    desktopTopButton: '.back-to-top-btn',
    desktopTopHolder: '.back-to-top-desktop',
    nextUpClass: '.nextUpAnimated',
    nextUpText: 'nextUpAnimated',
    nextUpWrapper: '.o-Article__m-NextUpWrap',
    weRecWrapper: '.o-Article__m-WeRecommendWrap',
    interstitialCardWrapper: '.interstitial-card',
    scrollDirection: '',
    scrollableInstances: [],
    previousScrollPosition: 0,
    collapsibleFooterContent: {},
    footer: '.footer',
    isPhotoSavedMPB: false,
    adFreq: false,
    triggerOK: true,
    waitingForContent: true,
    interstitialCard: '<div class="card interstitial-card"></div>',
    interstitialWrapper: '<div id="photo_interstitial_wrapper"></div>',
    interstitialWrapperMobile: '<div id="photo_interstitial_wrapper_mobile" class="interstitial"></div>',
    interstitialMobileCloseBtn: '<div id="photo_interstitial_mobile_close"><i class="icon icon-times"></i></div>',
    interstitialScrollOffset: '',
    mediaStream: '',
    galleryTitle: '',
    galleryUrl: '',
    qString: '',
    heightOffset: 90,
    maxImageHeight: 964,
    minImageHeight: 0,
    prevInt: 0,
    intCounter: 1,
    bigCounter: 1,
    isWoz: navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false,
    pinOnStart: false, // Show pinterest button without waiting for a scroll event
    newTemplate: false
  };

  function setStickyFooterHandlers() {
    if (!config.isMobile) {
      $(config.collapsibleFooterButton).off('click.stickyFeet');
      if ($(config.footer).length > 0) {
        $(config.footer).addClass('sticky-feet-closed');
      }
      $(config.collapsibleFooterButton).on('click.stickyFeet', function (e) {
        e.preventDefault();
        if ($(config.footer).length > 0) {
          if ($(config.footer).hasClass('sticky-feet-open')) {
            $(config.footer).removeClass('sticky-feet-open');
            $(config.footer).addClass('sticky-feet-closed');
          } else {
            $(config.footer).removeClass('sticky-feet-closed');
            $(config.footer).addClass('sticky-feet-open');
          }
        }
      });
    }
  }

  function setQueryToJSON() {
    var pairs = window.location.search.slice(1).split('&'),
        result = {};

    pairs.forEach(function (pair) {
      pair = pair.split('=');
      result[pair[0]] = decodeURIComponent(pair[1] || '');
    });

    return JSON.parse(JSON.stringify(result));
  }

  function setQString() {
    if (config.galleryType === 'curated' && location.search) {
      config.qString = setQueryToJSON();
      return true;
    } else {
      return false;
    }
  }

  function setDeepLink() {
    var hash = window.location.hash;

    if (setQString() && config.qString.im) {
      config.qString.im = config.qString.im.replace(/[^0-9]/gim, '').trim();
      if (config.qString.im !== '') {
        $(config.cardSelector + '[data-card-index="' + config.qString.im + '"]')[0].scrollIntoView();
      }
      var timestamp = new Date().getTime();
      context.broadcast('stateChanged', {
        gallery: timestamp,
        href: window.location.pathname + window.location.search.replace(/[\?|\&]im\=[^\&]+/gim, '').replace(/^\&/, '?')
      });
    }

    if (hash && hash.indexOf('#item-') > -1) {
      var queryStart = hash.indexOf('?');
      if (queryStart > -1) {
        hash = hash.slice(0, queryStart);
      }
      var slideIndex = hash.replace('#item-', '');
      if (!Number.isNaN(slideIndex)) {
        $(config.cardSelector + '[data-card-index="' + slideIndex + '"]')[0].scrollIntoView();
        var _timestamp = new Date().getTime();
        context.broadcast('stateChanged', {
          gallery: _timestamp,
          href: window.location.href
        });
      }
    }
  }

  function getSite(content) {
    if (check.exists('mdManager') && mdManager.getParameterString('site') && typeof content !== 'undefined') {
      config.currentSite = mdManager.getParameterString('site').toUpperCase();
      if ((typeof content === 'undefined' ? 'undefined' : helpers_typeof_default()(content)) === 'object') {
        content.site = config.currentSite;
      }
    }
  }

  function loadCollapsibleFooter(content) {
    if (typeof content !== 'undefined') {
      collapsibleFooterTemplate = template.collapsibleFooterButton(content);
    }
  }

  function resizeImageHeight() {
    $(window).off('resize.imageHeight');
    $(window).on('resize.imageHeight', function () {
      $(config.cardSelector).each(function () {
        var $photoCard = $(this),
            currentImage = $photoCard.find('.media img');
        setImageHeight($(currentImage));
      });
      if (!config.isMobile && config.galleryType === 'curated') {
        config.topScrollOffset = $(config.cardSelector).eq(3).offset().top;
      }
    });
  }

  function setImageHeight($card) {
    var diffHeight = $(window).outerHeight() - config.heightOffset;

    if (diffHeight < config.maxImageHeight || diffHeight >= config.minImageHeight) {
      $card.css('max-height', diffHeight);
    }
  }

  function addBackToTop() {
    if (config.isMobile) {
      config.topScrollOffset = $(config.cardSelector).eq(3).offset().top + 21;
      $('body').prepend(config.backButton);
      $(config.topClass).off('click.top');
      $(config.topClass).on('click.top', function () {
        $('html,body').animate({
          scrollTop: 0
        }, 1000);
      });
    } else {
      config.topScrollOffset = $(config.cardSelector).eq(3).offset().top + 98;
      $('body').prepend(collapsibleFooterTemplate);
      $(config.desktopTopButton).off('click.top');
      $(config.desktopTopButton).on('click.top', function (e) {
        e.preventDefault();
        $('html,body').animate({
          scrollTop: 0
        }, 1000);
        $(config.footer).removeClass('sticky-feet');
        $('.next-up-wrapper').each(function () {
          $(this).removeClass('fixer');
        });
        $('.we-recommend-wrapper').each(function () {
          $(this).removeClass('lefty');
        });
      });
    }
  }

  function cacheElements(element) {
    $element = $(element);
    debug.log($element);
  }

  function isInterstitialShown() {
    if (getInterstitial().length > 0) {
      $('.filters').hide();
    } else {
      if (window.location.href.indexOf('photos/viewer') === -1) {
        $('.filters').show();
      }
    }
    return getInterstitial().length > 0;
  }

  function placeDesktopInterstitials() {
    var intmarker = void 0,
        prevmarker = void 0,
        prevbig = void 0;

    setTimeout(function () {
      if (adLibLoaded && $('.currentCard').length > 0) {
        $('.currentCard').after(config.interstitialCard);
        config.prevInt = config.intCounter;
        prevmarker = '.int-' + config.prevInt;
        intmarker = 'int-' + config.intCounter;
        prevbig = config.bigCounter;
        $('.currentCard').next().addClass(intmarker);
        $('.' + intmarker).hide();
        SniAds.appendSlot(intmarker, 'dfp_photo_vertical_interstitial', {}, true);
        SniAds.appendSlot(intmarker, 'dfp_bigbox', {}, true);
        SniAds.refreshSlots(['dfp_photo_vertical_interstitial_' + config.intCounter, 'dfp_bigbox_' + config.bigCounter]);
        setTimeout(function () {
          $('#dfp_bigbox_' + prevbig).hide();
          if ($(prevmarker).children('div:not(#dfp_bigbox_' + prevbig + ')').find('iframe').contents().find('body:not(:empty)').length > 0) {
            $(prevmarker).show();
          } else {
            $(prevmarker).remove();
          }
        }, 500);
        config.intCounter++;
        config.bigCounter++;
        intmarker = 'int-' + config.intCounter;
      }
    }, 100);
  }

  function setMediaStreamData() {

    mediaStream.recordCurrentAndPreviousSS({
      'title': config.galleryTitle,
      'url': config.galleryUrl
    });

    if (config.mediaStream !== '' && config.mediaStream.length > 0) {
      mediaStream.setupNextSS(config.mediaStream);
    }
  }

  function getNextUpImage(ajaxUrl) {
    var image = void 0;
    $.ajax({
      url: ajaxUrl,
      type: 'get',
      dataType: 'html',
      async: false,
      success: function success(data) {
        image = $(data).filter('meta[property="og:image"]').attr('content').replace(/^(.+?)(\.rend\..+?)$/igm, '$1') || '';
      }
    });
    return image;
  }

  function updateNextUpContent(context, className, content, accepted) {
    var renditionedImage = void 0;
    if (!accepted && $(context).find('.media img').length !== 0) {
      renditionedImage = $(context).find('.media img').attr('src').replace(/^(.+?)(\.rend\..+?)$/igm, content.image + '$2');
      $(context).find('.media a').attr('href', content.url).end().find('.media img').attr('src', renditionedImage).end().find('.text a').attr('href', content.url).end().find('.text a h4').text(content.title);
      $(context).removeClass(className);
    }
  }

  function checkNextUpContent(context, data) {
    var currentNextUpTitle = $(context).find('.text a h4').text(),
        isMatching = currentNextUpTitle === data.title ? true : false;
    return isMatching;
  }

  function fetchNextUp() {
    var nextUpContent = void 0,
        isMatching = void 0;

    nextUpContent = mediaStream.getNextSS();
    if (nextUpContent && nextUpContent.url) {
      nextUpContent.image = getNextUpImage(nextUpContent.url);
    }
    isMatching = checkNextUpContent(config.nextUpClass, nextUpContent);
    updateNextUpContent(config.nextUpClass, config.nextUpText, nextUpContent, isMatching);
  }

  function initLoadMoreTrigger($loadMoreTrigger) {
    var $window = $(window),
        scrollEvent = 'scroll.lazyload',
        resizeEvent = 'resize.lazyload',
        currentAjaxUrl = void 0,
        nextGallery = void 0,
        nextGalleryUrl = void 0;

    if (config.galleryType === 'curated') {
      setMediaStreamData();
      nextGallery = mediaStream.getNextSS();
      nextGalleryUrl = nextGallery ? nextGallery.url : false;
      if (!config.isMobile) {
        fetchNextUp();
      }
    }

    if (!$loadMoreTrigger.length) return;

    $window.on(scrollEvent + ' ' + resizeEvent, function () {
      if (modUtil.isInViewport($loadMoreTrigger[0])) {

        if (config.galleryType === 'curated' && nextGalleryUrl) {
          currentAjaxUrl = nextGalleryUrl;
        } else {
          currentAjaxUrl = $loadMoreTrigger.data('ajaxUrl');
        }

        context.broadcast('loadMore.triggered', {
          type: 'loadMore.triggered',
          element: $loadMoreTrigger,
          ajaxUrl: currentAjaxUrl
        });

        if (adLibLoaded && config.galleryType === 'dynamic') {
          SniAds.appendSlot('.bigbox-' + $loadMoreTrigger.attr('data-pagenum'), 'dfp_bigbox');
        }
      }
    });

    return $loadMoreTrigger;
  }

  function loadEmUp(deets) {
    var cqWCMDisabled = context.getGlobal('cqWCMDisabled') || false,
        $currentTrigger = void 0;

    if (cqWCMDisabled && config.autoLoadMore) {
      $currentTrigger = deets.element;
      if (typeof $currentTrigger !== 'undefined') {
        if (config.triggerOK) {
          var ajaxURL = deets.ajaxUrl,
              page = void 0;

          if (config.galleryType === 'dynamic') {
            page = ajaxURL.split('/p/')[1] || '';
          }

          debug.log('init: ajaxURL: ', ajaxURL, page);

          if (!ajaxURL) {
            debug.error('init: Yikes! No URL for next page, exiting');
            return false;
          }

          $('body').addClass('lazy');
          $('.loadmore-trigger, .loadmore-fallback').remove();

          ajaxService.loadAreaContent({
            target: 'photoScroll',
            suppressLoadAnim: true,
            href: ajaxURL
          });

          config.triggerOK = false;
          return false;
        }
      }
    }
  }

  function addTagsButton($tagsButton, $tagList) {
    var tagModal = void 0;

    $tagsButton.click(function () {
      config.watchScroll = false;
      config.modalScrollOffset = $(window).scrollTop();
      tagModal = modal.open('tag-overlay', $tagList);
      config.currentModal = tagModal;
    });
  }

  function setItUp() {
    // context.broadcast('socialShare.remove', {});

    $(config.cardSelector).each(function () {
      var $photoCard = $(this),
          $utilsWrapper = $photoCard.find('.photocard-utils-wrapper'),
          $tagsButton = $utilsWrapper.find('.tagsButton'),
          $tagList = $photoCard.find('.tag-list').html(),
          theCount = modUtil.getCounter();

      if (typeof $photoCard.data('photocardSeen') === 'undefined') {
        $photoCard.data('photocardSeen', true);
        if (config.galleryType === 'curated') {
          theCount--;
          modUtil.setCounter(theCount);
        }

        // if ( check.exists('mdManager') && mdManager.getParameterString('site').toLowerCase().match('hgtv') && config.galleryType === 'dynamic') {
        //   addPhotoBox($photoCard, $photoWrapper, $mpbContainer, $saveButton);
        // }

        if ($($tagList).length) {
          addTagsButton($tagsButton, $tagList);
        }

        // HOTSPOTS GO HERE
        // addHotspots($photoCard);
        getHotspotInstance(context, $photoCard.data(config.hotspotUrlName), $photoCard.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, false);

        if (adLibLoaded && config.galleryType === 'curated') {
          if (config.device === 'mobile' && modUtil.getCounter() === 0) {
            $photoCard.after('<p class="ad-text">More photos after this Ad</p><div class="bigbox-ad bigbox-trigger"></div>');
            modUtil.setCounter(config.adFreq);
          }
        }
      }
      if (!config.isMobile && config.galleryType === 'curated') {
        setImageHeight($($(this).find('.media img')));
      }
    });
  }

  function replaceURLFromCurrentSlide($card) {
    if (!check.exists('history.pushState')) {
      return;
    }

    var $photoCardContent = $card,
        assetURL = $photoCardContent.data('assetUrl') || '',
        socialShare = $photoCardContent.find('[social-share]').length !== 0,
        assetURLMatch = assetURL.match(/^https?:\/\/[^\/]*/),
        assetURLOrigin = '';

    if (assetURLMatch) {
      assetURLOrigin = assetURLMatch[0];
    }

    if (document.location.origin === assetURLOrigin || assetURL.indexOf('//') === -1) {
      if (!socialShare) {
        if (config.isT3) {
          assetURL = config.routingService.getPreviousURL();
        }
      }

      config.cardScrollOffset = $card.position().top;

      var timestamp = new Date().getTime(),
          slideID = config.cardScrollOffset;

      var sObj = { sID: slideID, gallery: timestamp, href: assetURL };

      if (window.location.href.indexOf(assetURL) === -1) {
        debug.log('replaceURLFromCurrentSlide: assetURL: ', assetURL);
        if (typeof window.history !== 'undefined' && assetURL) {
          window.history.pushState({}, '', assetURL);
        }
        context.broadcast('stateChanged', sObj);
      }
    }
  }

  function refreshAds() {
    handleInterstitial();
  }

  function handleInterstitial() {
    if (!adLibLoaded) {
      return false;
    }

    if (!config.currentCard.is(config.previousCard) && config.watchScroll) {
      config.interstitialScrollOffset = config.currentCard.position().top;
      SniAds.Gallery.next();
    }
  }

  function getInterstitial() {
    return $('#site').closest('.interstitial-show');
  }

  function handleProductTracking(mdString) {
    var mdmData = JSON.parse(mdString);

    if (mdmData.products && mdmData.shopping === 'shopping') {
      context.broadcast('product.displayed', {
        products: mdmData.products
      });
    }
  }

  function updateMetrics($card) {

    var mdmData = $card.data('galleryMdm') || false,
        galleryOgData = $card.data('galleryOg'),
        mdmObj = JSON.parse(mdmData),
        updatedUID = void 0,
        behavioralInteraction = void 0;

    updatedUID = metadata.updateConsecutiveViewCount(mdmObj);
    behavioralInteraction = metadata.getMediaStreamNumber(mdmData, 1);

    debug.log('updateMetrics: $card: ', $card);

    if (mdmData) {
      metadata.updateFromString(mdmData);
      if (updatedUID) {
        metadata.updateFromString({ Overlay_UniqueId: updatedUID });
      }
      if (behavioralInteraction) {
        metadata.updateFromString({ behavioralInteraction: behavioralInteraction });
      }
    } else {
      debug.error('photo-scroll.js: updateMetrics(): mdmData missing');
    }

    debug.log('PSUD: ', galleryOgData);

    if (galleryOgData) {
      var ogDesc = galleryOgData.ogdesc || false,
          ogTitle = galleryOgData.ogtitle || false,
          ogUrl = galleryOgData.ogurl || false,
          ogImg = galleryOgData.ogimg || false;

      debug.log('PSUD: ', ogDesc, ogTitle, ogUrl, ogImg);

      if (ogDesc) {
        $('meta[property="og:description"]').attr('content', ogDesc);
      }
      if (ogTitle) {
        $('meta[property="og:title"]').attr('content', ogTitle);
      }
      if (ogUrl) {
        $('meta[property="og:url"]').attr('content', ogUrl);
      }
      if (ogImg) {
        $('meta[property="og:image"]').attr('content', ogImg);
      }
    }
  }

  function processCardMetadata($card) {
    var mdmData = JSON.parse($card.attr('data-mdm')) || false,
        behavioralInteraction = void 0,
        uniqueIDPrime = void 0;

    if (check.exists('mdManager')) {
      mdManager.setParameter('CurrentRoom', $card.find(config.headlineSelector).text());
    }

    if (config.galleryType === 'curated') {
      uniqueIDPrime = metadata.updateConsecutiveViewCount(mdmData);
      behavioralInteraction = metadata.getMediaStreamNumber(mdmData, 0);
    }

    if (mdmData) {
      metadata.updateFromString(mdmData);
      if (config.galleryType === 'curated' && uniqueIDPrime) {
        metadata.updateFromString({ Overlay_UniqueId: uniqueIDPrime });
        if (behavioralInteraction) {
          metadata.updateFromString({ behavioralInteraction: behavioralInteraction });
        }
        metadata.updateFromString({ Type: 'verticalPhotoGallery' });
      }
    } else {
      debug.log('Slide MDM data missing');
    }

    analytics.callDynamicPageview();
  }

  function fullMonty(data) {
    var $photoCard = data.card;
    replaceURLFromCurrentSlide(data.card);
    refreshAds();
    // getHotspotInstance(context, $photoCard.data(config.hotspotUrlName), $photoCard.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, false);
    updateShopElement(context, $photoCard);
    context.broadcast('gallery.ImageUpdate', {
      imageURL: $photoCard.find('img.m-MediaBlock__a-Image').attr('src'),
      element: $($photoCard)
    });
    if (config.currentCard.index() > 0) {
      config.secondPass = true;
    } else if (config.currentCard.index() === 0) {
      handleProductTracking($photoCard.attr('data-mdm'));
    }

    if (config.secondPass && config.watchScroll) {
      if (config.galleryType === 'curated') {
        if ($(data.card).data('galleryOg')) {
          setTimeout(function () {
            updateMetrics($(data.card));
            context.broadcast('socialShare.updateShareBar');
          }, 300);
        }
      }
      if (typeof $(data.card).data('metadataProcessed') === 'undefined') {
        processCardMetadata(data.card);
        ++config.originalGallery;
        metadata.setGalleryData({
          originalGallery: config.originalGallery,
          consecutiveGallery: config.consecutiveGallery
        });
        $(data.card).data('metadataProcessed', true);
      }
    }
  }

  function setupModalHandlers() {
    function gigyaDisplaceScroll() {
      $(window).scrollTop(config.modalScrollOffset);
    }

    var gigya = check.exists('gigya.socialize') ? context.getGlobal('gigya') : false;
    if (gigya) {
      gigya.socialize.addEventHandlers({
        onLogin: gigyaDisplaceScroll
      });
    }

    $('#photo_interstitial_mobile_close').click(function () {
      $(window).scrollTop(config.interstitialScrollOffset);
    });
  }

  function onScreen($element) {
    var viewport = {
      top: $(window).scrollTop(),
      bottom: $(window).scrollTop() + $(window).height()
    },
        bounds = {
      top: $element.offset().top,
      bottom: $element.offset().top + $element.outerHeight()
    };

    return bounds.top > viewport.top && bounds.top < viewport.bottom;
  }

  function checkScrollDirection() {
    var currentScrollPosition = $(window).scrollTop(),
        direction = void 0;
    if (currentScrollPosition > config.previousScrollPosition) {
      direction = 'down';
    } else {
      direction = 'up';
    }
    config.previousScrollPosition = currentScrollPosition;
    return direction;
  }

  function setupScrollHandler() {
    var $window = $(window),
        scrollEvent = 'scroll',
        resizeEvent = 'resize';

    $window.on(scrollEvent + ' ' + resizeEvent, function (event) {
      $(config.cardSelector).each(function () {
        var $photoCard = $(this),
            textElem = $photoCard.find(config.cardTextSelector),
            visibleElem = config.newTemplate ? $photoCard : textElem,
            visibleCheck = config.newTemplate ? 'partial' : 'full',
            isInFullView = !config.newTemplate,
            // check full view separately for new template (true for old template)
        aside = void 0,
            bigmarker = void 0;

        if (event.type === resizeEvent) {
          context.broadcast('viewportUpdated', {
            element: $photoCard.find(config.hotspotElement)
          });
        }

        if (modUtil.isInViewport(visibleElem[0], visibleCheck)) {
          $photoCard.addClass('currentCard');
          config.currentCard = $photoCard;
          if (config.newTemplate) {
            isInFullView = modUtil.isInViewport(textElem[0], 'full');
          }
          if (!config.currentCard.is(config.previousCard) && config.watchScroll && isInFullView) {
            context.broadcast('photoScroll.imgFullViewport', {
              card: $photoCard
            });
            config.previousCard = config.currentCard;
          }
        } else {
          $photoCard.removeClass('currentCard');
        }

        if (config.galleryType === 'curated' && config.device === 'desktop') {
          aside = $photoCard.find('.card-aside');
          if (adLibLoaded && modUtil.isInViewport(aside[0]) && !$(aside).hasClass('loaded')) {
            bigmarker = 'big-' + config.bigCounter;
            $(aside).addClass(bigmarker);
            SniAds.appendSlot(bigmarker, 'dfp_bigbox', {}, true);
            SniAds.refreshSlot('dfp_bigbox_' + config.bigCounter);
            $(aside).addClass('loaded');
            config.bigCounter++;
            bigmarker = 'big-' + config.bigCounter;
          }
        }
      });
      if (config.galleryType === 'curated') {
        var topContainer = config.isMobile ? config.topClass : config.desktopTopHolder;
        if ($(this).scrollTop() >= config.topScrollOffset) {
          $(topContainer).removeClass('smooth-hide').addClass('smooth-move');
        } else {
          $(topContainer).removeClass('smooth-move').addClass('smooth-hide');
        }
        if ($('.gallery-end').length > 0) {
          $('.gallery-end').each(function () {
            if (modUtil.isInViewport($(this)[0])) {
              $(this).remove();
              if (typeof config !== 'undefined' && typeof config.consecutiveGallery !== 'undefined' && typeof config.originalGallery !== 'undefined') {
                ++config.consecutiveGallery;
                metadata.setGalleryData({
                  originalGallery: config.originalGallery,
                  consecutiveGallery: config.consecutiveGallery
                });
              }
            }
          });
        }
        if ($('.loadmore-fallback').length > 0 && modUtil.isInViewport($('.loadmore-fallback')[0])) {
          context.broadcast('loadMore.triggered', {
            type: 'loadMore.triggered',
            ajaxUrl: mediaStream.getNextSS().url
          });
        }
        if (!config.isMobile) {
          $(config.separatorClass).each(function () {
            if ($(this).find('.next-up-wrapper .media .label-next').length < 1) {
              $(this).find('.next-up-wrapper .media').prepend('<div class="label label-default label-next">Next Up</div>');
            }
            if (onScreen($(this))) {
              if (!$(this).hasClass(config.animatedClass)) {
                $(this).addClass(config.animatedClass);
              }
            } else {
              $(this).removeClass(config.animatedClass);
            }
          });
          $(config.animatedSelector).each(function () {
            if (!$(this).hasClass('measured')) {
              config.originalTopOffset = $(this).find('.next-up-wrapper').offset().top;
              $(this).addClass('measured');
            }
            if (!$(this).hasClass('locked')) {
              var $gallerySeperator = $(this),
                  $nextUp = $gallerySeperator.find(config.nextUpWrapper),
                  $weRec = $gallerySeperator.find(config.weRecWrapper),
                  nextUpBottomOffset = $nextUp.offset().top + $nextUp.outerHeight(),
                  viewportBottom = $(window).scrollTop() + $(window).height();
              config.scrollDirection = checkScrollDirection();
              if ($nextUp.find('.next-up').length > 0 && $weRec.find('.we-recommend').length > 0) {
                if (config.scrollDirection === 'down') {
                  if (nextUpBottomOffset < viewportBottom + 5) {
                    $nextUp.addClass('fixer');
                    if (typeof config.newTopOffset !== 'undefined') {
                      $nextUp.css('bottom', viewportBottom - nextUpBottomOffset + 'px');
                    }
                    $weRec.addClass('lefty');
                  }
                  if (Math.floor($nextUp.find('img').first().offset().top) >= Math.floor($weRec.find('img').first().offset().top)) {
                    $nextUp.removeClass('fixer');
                    $weRec.removeClass('lefty');
                    $nextUp.css('bottom', '0');
                    $weRec.css('padding-left', '0');
                    $nextUp.offset({ top: $weRec.offset().top, left: $nextUp.offset().left });
                    $gallerySeperator.addClass('locked');
                  }
                } else {
                  if ($nextUp.hasClass('fixer')) {
                    if ($nextUp.offset().top > config.originalTopOffset && $nextUp.offset().top - config.originalTopOffset < 180) {
                      config.newTopOffset = 180 - ($nextUp.offset().top - config.originalTopOffset);
                      $nextUp.css('bottom', 180 - ($nextUp.offset().top - config.originalTopOffset) + 'px');
                    }
                    $nextUp.removeClass('fixer');
                    $weRec.removeClass('lefty');
                  }
                }
              } else if ($nextUp.find('.next-up').length > 0 && $weRec.find('.we-recommend').length < 1) {
                $gallerySeperator.css('text-align', 'left');
                $nextUp.css({ bottom: '40px', left: '3rem' });
              }
            }
          });
        } else {
          if (adLibLoaded) {
            $('.bigbox-trigger').each(function () {
              if (modUtil.isInViewport($(this)[0])) {
                $(this).addClass('currentBigBox');
                var bigboxID = SniAds.appendSlot('currentBigBox', 'dfp_bigbox', {}, true);
                SniAds.refreshSlot(bigboxID);
                $(this).removeClass('currentBigBox');
                $(this).removeClass('bigbox-trigger');

                //smooth the ad load experience...
                var $bb = $('#' + bigboxID);
                $bb.after(template.loadingHTML('is-Subtle'));
                $bb.closest('.bigbox-ad').addClass('bigbox-height-enforced');
              }
            });
          }
        }
      }
    });
  }

  function setupFilterHandlers() {
    var filterModal = void 0;

    $('.filter-control').click(function () {
      if (config.isWoz) {
        config.watchScroll = false;
        config.modalScrollOffset = $(window).scrollTop();
        filterModal = modal.open('filter-overlay', $($('.filters').html()));
        config.currentModal = filterModal;
        $('#filter-overlay').find('.filter-control').html('Hide Filters <i class="icon icon-times"></i>');
        $('#filter-overlay').find('.filter-control').on('click.photoScroll.modal', function () {
          config.currentModal.hide();
        });
      } else {
        if (!$('.filters').hasClass('sticky')) {
          $(window).scrollTop($('.filters').offset().top + 1);
        }
        $('.filter-shade').slideToggle();
      }
    });

    if (window.location.href.indexOf('photos/viewer') === -1) {
      $(window).scroll(function () {
        if (!isInterstitialShown()) {

          if ($(this).scrollTop() > $('.header').outerHeight() + $('.dataDrivenTitle').outerHeight() + 28) {
            $('.filters').addClass('sticky');
            $('#site').before($('.filters'));
            $(config.cardSelector).first().css('padding-top', $('.filters').outerHeight() + parseInt($('.filters').css('marginBottom').replace(/[^-\d\.]/g, '')));
          } else {
            $('.filters').removeClass('sticky');
            $('.dataDrivenTitle').after($('.filters'));
            $(config.cardSelector).first().css('padding-top', 0);
          }
        } else {
          debug.log('setupFilterHandlers: isInterstitialShown: true');
        }
      });
    }
  }

  function getHotspotInstance(currentContext, currentUrl, currentImg, hotspotElement, defaultUrl, single) {
    var img = void 0,
        hotspotUrl = void 0,
        elementUrl = void 0,
        deferredHotspots = void 0;

    img = $(currentImg);
    if (!img.data(hotspotElement)) {
      hotspotUrl = currentUrl;
      deferredHotspots = $.Deferred();
      img.data(hotspotElement, deferredHotspots.promise());
      elementUrl = img.attr('src') || '';
      elementUrl = elementUrl.replace(/\.rend.*/, '');
      currentContext.broadcast('elementUpdated', {
        element: img,
        url: hotspotUrl || defaultUrl,
        imageUrl: elementUrl,
        hotspotShowAll: !single,
        initDeferred: deferredHotspots
      });
    }
  }

  function updateShopElement(currentContext, currentCard) {
    currentContext.broadcast('shopElementChanged', {
      newElement: currentCard,
      type: config.galleryType
    });
  }

  function pinOnStart() {
    var $card = $('[data-card-index="1"]');
    if ($card.length > 0) {
      context.broadcast('gallery.directPin', { element: $card });
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  module = {
    behaviors: ['shop-this-look', 'social-pinterest', 'hotspot', 'product-list', 'lazy-load'],
    messages: ['loadMore.triggered', 'ajax.areaContentLoaded', 'photoScroll.contentSet', 'photoScroll.imgFullViewport', 'modal.shown', 'modal.hidden'],
    init: function init() {
      SniAds = context.getGlobal('SniAds');
      mdManager = context.getGlobal('mdManager');
      adLibLoaded = check.exists('SniAds.Gallery');
      element = context.getElement();

      if (element) {

        config = Object.assign({}, defaults, context.getConfig());
        config.isMobile = deviceType.isMobile;

        if (window.location.href.indexOf('photos/viewer') > -1) {
          $('.filters').hide();
        }

        if (adLibLoaded) {
          if (!coldLoad) {
            SniAds.Gallery.reset();
          }
          coldLoad = false;
        }
        if (config.pinOnStart) {
          pinOnStart();
        }

        config.hotspotUrl = window.location.pathname;

        if (config.galleryType === 'curated') {
          var carryoverMeta = void 0;
          config.galleryAdsContainer = '.photoGalleryPage';
          setDeepLink();
          modUtil.setCounter(config.adFreq);
          config.originalGallery = 2;
          config.consecutiveGallery = 1;
          metadata.setGalleryData({
            originalGallery: config.originalGallery,
            consecutiveGallery: config.consecutiveGallery
          });
          if (!config.isMobile) {
            getSite(config.collapsibleFooterContent);
            loadCollapsibleFooter(config.currentSite);
            resizeImageHeight();
          }
          config.galleryTitle = $(element).data('galleryTitle');
          config.galleryUrl = $(element).data('galleryUrl');
          config.mediaStream = $(element).data('mediaStream');
          config.triggerOK = true;
          config.waitingForContent = true;
          carryoverMeta = metadata.getGalleryData();
          if (typeof carryoverMeta.originalGallery !== 'undefined') {
            config.originalGallery = carryoverMeta.originalGallery;
          }
          if (typeof carryoverMeta.consecutiveGallery !== 'undefined') {
            config.consecutiveGallery = carryoverMeta.consecutiveGallery;
          }
        }

        if (!$('body').hasClass('lazy') && config.galleryType === 'curated') {
          setTimeout(function () {
            addBackToTop();
            setStickyFooterHandlers();
          }, 500);
        }

        var $loadMoreTrigger = config.loadMoreCheck,
            loaderSel = config.loadSelector,
            moduleContainer = $(config.modContainer),
            cqWCMDisabled = context.getGlobal('cqWCMDisabled') || false;

        cacheElements(element);

        if (!$('body').hasClass('lazy')) {
          if (adLibLoaded) {
            SniAds.Event.subscribe('_pageTargetingUpdated', function (e) {
              if (typeof e.int_type !== 'undefined' && config.galleryType === 'curated' && config.device === 'desktop') {
                placeDesktopInterstitials();
              }
            });
          }
        }

        if (cqWCMDisabled) {
          if (config.autoLoadMore) {
            $loadMoreTrigger = initLoadMoreTrigger($('.loadmore-trigger'));
            if (typeof $loadMoreTrigger === 'undefined' && config.isMobile) {
              $(loaderSel).remove();
            }
          }
        }

        if (config.isMobile && !moduleContainer.data('loaderDots') && typeof $loadMoreTrigger !== 'undefined') {
          moduleContainer.data('loaderDots', true).after(template.loadingHTML());
        }
      }

      if (!$('body').hasClass('lazy')) {
        setupModalHandlers();
        if (config.galleryType === 'dynamic') {
          setupFilterHandlers();
        }
        setupScrollHandler();
        context.broadcast('photoScroll.contentSet');
      }
    },
    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'loadMore.triggered':
          loadEmUp(data);
          break;
        case 'ajax.areaContentLoaded':
          if (config.waitingForContent) {
            $(config.loadSelector).remove();
            if (data.target === 'photoScroll') {
              context.broadcast('photoScroll.contentSet');
            }
            config.waitingForContent = false;
          }
          break;
        case 'photoScroll.contentSet':
          setItUp();
          break;
        case 'photoScroll.imgFullViewport':
          fullMonty(data);
          break;
        case 'modal.shown':
          $('#site').addClass('no-scroll');
          break;
        case 'modal.hidden':
          if (config.galleryType === 'dynamic' && config.isWoz) {
            $('#filter-overlay').find('.filter-control').off('click.photoScroll.modal');
          }
          $('#site').removeClass('no-scroll');
          $(window).scrollTop(config.modalScrollOffset);
          config.watchScroll = true;
          break;
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'product-link':
          var dynamicSTL = config['shop-this-look'].dynamicSTL,
              partner = config['shop-this-look'].vendor,
              productTitle = $(element).closest('div[data-product-title]').data('product-title');

          // Format data for tracking
          var _metadata = dynamicSTL ? {
            partner: partner,
            title: partner + '|' + productTitle,
            imagecount: 'n/a',
            productcount: 'n/a'
          } : {
            title: productTitle
          };

          context.broadcast('product.clicked', _metadata);

          // go nuclear and STOP THE CLICK
          event.stopPropagation();
          break;
        default:
          break;
      }
    }
  };

  return module;
});
// CONCATENATED MODULE: ./src/app/modules/video-embed.js



/**
 * This module is used on pages which have embeded video playlists
 */
SNI.Application.addModule('video-embed', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var util = context.getService('utility');
  var debug = context.getService('logger').create('module.video-embed');
  var $element = $(context.getElement());
  var $embedWrapper = $element.closest('.o-VideoPlaylistEmbed');
  var $slides = void 0;
  var player = null;
  var $parentContainer = $element.parent();
  var elementId = $element.attr('id');

  var defaults = {
    recipe: false,
    syncAdSelector: '#bigbox',
    blockMetaUpdt: false,
    selectors: {
      metaData: {
        title: '[data-title]',
        description: '[data-description]',
        duration: '[data-duration]'
      },
      carousel: '[data-video-carousel]'
    }
  };
  var config = $.extend(true, {}, defaults, context.getConfig());

  var messageHandlers = {

    'video.hide': function videoHide(_ref) {
      var id = _ref.id;

      if (id === elementId) {
        player.pause();
        player.$container.detach();
      }
    },

    'video.pause': function videoPause(_ref2) {
      var id = _ref2.id;

      if (id === elementId) {
        player.pause();
      }
    },

    'video.show': function videoShow() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          id = _ref3.id,
          _ref3$videoNum = _ref3.videoNum,
          videoNum = _ref3$videoNum === undefined ? 0 : _ref3$videoNum,
          _ref3$play = _ref3.play,
          play = _ref3$play === undefined ? true : _ref3$play;

      debug.log('VIDEO SHOW: id ' + id + ', videoNum ' + videoNum);
      if (id === elementId) {
        player = SNI.Video.Players[config.player.containerId];
        $parentContainer.append(player.$container);
        if (play) {
          setTimeout(function () {
            player.play(videoNum);
          }, 1000);
        }
      }
    },

    'video.play': function videoPlay(_ref4) {
      var id = _ref4.id,
          _ref4$videoNum = _ref4.videoNum,
          videoNum = _ref4$videoNum === undefined ? 0 : _ref4$videoNum,
          _ref4$play = _ref4.play,
          play = _ref4$play === undefined ? true : _ref4$play;

      debug.log('received video.play', id, videoNum, play);
      if (id === elementId && config.player.containerId in SNI.Video.Players) {
        debug.log('playing...');
        player = SNI.Video.Players[config.player.containerId];
        if (play) {
          setTimeout(function () {
            player.play(videoNum, true);
          }, 1000);
        }
      }
    },

    'lightbox.watchHowPause': function lightboxWatchHowPause(_ref5) {
      var id = _ref5.id;

      debug.log('watchHowPause fired');
      if (id === elementId && config.player.containerId in SNI.Video.Players) {
        player = SNI.Video.Players[config.player.containerId];
        player.pause(false);
      }
    }

  };

  function addSyncAdListener(containerId) {
    var $syncAd = $(config.syncAdSelector); // related to advertisement for single video embed

    if ($syncAd.length) {
      SNI.Video.Events.addEventListener('OnMediaStart', function (ev) {
        setTimeout(function () {
          $syncAd.css('max-height', '300px');
        }, 1000);
      }, containerId);
    }
  }

  function updateMetaData(videoIndex) {
    var currentVideoData = config.channels[0].videos[videoIndex];
    var metaData = config.selectors.metaData;


    Object.keys(metaData).forEach(function (key) {
      $parentContainer.find(metaData[key]).text(currentVideoData[key]);
    });
  }

  function updateMetaposition() {
    //update position of metadata parent
    var header = $parentContainer.find('header');
    if (header) {
      $parentContainer.find('header').show().insertAfter($element);
    }
  }
  /**
   * @depreciated
   **/
  function updateVideoMetadata(videoIndex) {

    var $currentVideo = $slides.eq(videoIndex);

    $slides.removeClass('active').eq(videoIndex).addClass('active');

    if (config.blockMetaUpdt) {
      // meta block for video overlay case - not using this (yet)
      $embedWrapper.find('.m-VideoMeta').html($currentVideo.find('script.video-metadata').html());
    } else {
      // just title & desc for inline case:
      $embedWrapper.find('.m-VideoMeta .m-VideoPlayer__a-HeadlineText').text($currentVideo.find('.m-MediaBlock__a-HeadlineText').text());
      $embedWrapper.find('.m-VideoMeta .m-VideoPlayer__a-Description').text($currentVideo.find('.m-MediaBlock__a-Description').text());
      $embedWrapper.find('.m-VideoMeta .m-VideoPlayer__a-Button').remove();
      if ($currentVideo.find('.m-MediaBlock__a-Button').length > 0) $embedWrapper.find('.m-VideoPlayer__m-TextWrap').prepend('<a class="m-VideoPlayer__a-Button" \n                                                href="' + $currentVideo.find('.m-MediaBlock__a-Button').attr('href') + '">\n                                                ' + $currentVideo.find('.m-MediaBlock__a-Button').text() + '</a>');
    }

    context.broadcast('update.metadata', videoIndex);
  }

  function bindVideoPlayerPlaylist(player) {
    $slides = $embedWrapper.find('.m-Carousel .m-MediaBlock');
    $slides.on('click', function (e) {
      e.preventDefault();
      var activeVid = parseInt($(this).attr('data-vid-num'));
      debug.log('attempting to play video ' + activeVid);
      player.play(activeVid, true, true);
    });
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {

    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },
    init: function init() {

      if (window.location.search.match(/[?|&]novideo(&|$)/)) {
        debug.warn('Video player disabled by query string param');
        return;
      }

      var containerId = void 0;

      debug.log('initializing video-embed', $element);

      containerId = $element.attr('id');

      if (config.recipe) {
        $embedWrapper = $element.closest('.recipe-lead');
      }

      config.freewheel = {
        enabled: !window.location.href.match(/[?|&]nopreroll/)
      };
      if (config.syncAdSelector) {
        //get just the id name without additional pieces of the selector or hash symbols
        config.freewheel.adContainerId = util.getIdFromSelector(config.syncAdSelector);
      }

      if ($element.data('video-num-override')) {
        config.channels[0].start = parseInt($element.data('video-num-override'));
      }

      player = new SNI.Video.Player(config);

      debug.log('player config', player);

      bindVideoPlayerPlaylist(player);

      /** When video starts update video metadata below player */
      addSyncAdListener(containerId);

      SNI.Video.Events.addEventListener('OnMediaStart', function (ev) {
        /** update video metadata */
        updateMetaData(player.currentVideoIdx);
        updateVideoMetadata(player.currentVideoIdx);
        updateMetaposition();
      }, containerId);
    }
  };
});
// EXTERNAL MODULE: ./src/app/modules/video-launcher.js
var video_launcher = __webpack_require__(387);
var video_launcher_default = /*#__PURE__*/__webpack_require__.n(video_launcher);

// EXTERNAL MODULE: ./src/app/modules/video.js
var video = __webpack_require__(388);
var video_default = /*#__PURE__*/__webpack_require__.n(video);

// EXTERNAL MODULE: ./src/app/modules/view-more.js
var view_more = __webpack_require__(389);
var view_more_default = /*#__PURE__*/__webpack_require__.n(view_more);

// EXTERNAL MODULE: ./src/app/modules/vine-embed.js
var vine_embed = __webpack_require__(390);
var vine_embed_default = /*#__PURE__*/__webpack_require__.n(vine_embed);

// CONCATENATED MODULE: ./src/app/modules/virtual-tour.js


var _this = this;

SNI.Application.addModule('virtual-tour', function (context) {

  var ads = void 0,
      side_check = void 0,
      side_check_touch = void 0,
      $element = $(context.getElement()),
      bodySel = '.header, .footer, #site, .container-site',
      deviceType = context.getService('device-type'),
      debug = context.getService('logger').create('virtual-tour'),
      check = context.getService('check').new(debug),
      analytics = context.getService('analytics'),
      modal = context.getService('modal'),
      metadata = context.getService('metadata'),
      template = context.getService('template'),
      productHS = context.getService('product-hotspots'),
      mdManager = check.exists('mdManager') ? context.getGlobal('mdManager') : false,
      modUtil = context.getService('utility');

  var defaults = {
    roomName: 'default',
    tourWrapSelector: '.virtual-tour-outer-wrapper',
    tourLaunchSelector: '.virtual-tour-handler',
    overlayBigboxName: '',
    basePageType: ''
  };
  var settings = Object.assign({}, defaults, context.getConfig());

  var messageHandlers = {
    'modal.hidden': function modalHidden() {}
  };

  var createTour = function createTour(embedpano) {
    var VirtualTour = function VirtualTour(element) {
      //overlayMarkup contains what should go into the modal to serve as the container for both the tour and ad-wrapper
      var self = this;
      settings.roomName = settings.roomName.replace(/\\/gi, '');
      settings.basePageType = mdManager && mdManager.getPageType ? mdManager.getPageType() : 'articlepage';
      self.bindTourHandler($element);
    };

    VirtualTour.prototype.launchTour = function (clickElement) {
      var tourModal,
          self = this,
          seamRefresh = true;

      //To avoid any positioning issues with the modal by scrolling to top before launching the overlay.
      //Afterwards, hide all other content on the page that is not the virtual tour module.
      self.scrollTop = $(window).scrollTop() || 0;
      $(bodySel).hide();

      //content string used to be wrapped in $($.parseHTML()) .. was that needed?
      tourModal = modal.open('tour-overlay', template.tourOverlay({
        roomName: settings.roomName
      }));

      function _refreshBigBox() {
        if (!deviceType.isMobile && ads) {
          // only need to append the overlay bb slot once, but will refresh each time
          if (settings.overlayBigboxName === '') {
            // can't depend on the name of the slot, so... this returns the slot name
            settings.overlayBigboxName = ads.appendSlot('dfp_overlay_bigbox', 'dfp_bigbox');
            // tell adserver which slot to sync with
            ads.Gallery.setSyncSlot(settings.overlayBigboxName);
          } else {
            /*  closing the overlay then opening it again w/o reloading page results in no ad
            * detangling this looks complex since the overlay isn't destroyed, but OVERWRITTEN
            * the next time the overlay promo is clicked to launch the overlay */
            ads.refreshSlot(settings.overlayBigboxName);
          }
        }
      }

      if (!deviceType.isMobile && ads) {
        settings.overlayBigboxName = ads.appendSlot('dfp_overlay_bigbox', 'dfp_bigbox');
        ads.Gallery.setSyncSlot(settings.overlayBigboxName);
      }

      //Create krpano object inside of the modal
      embedpano({
        swf: '/etc/clientlibs/assets/tour/tour.swf',
        xml: settings.componentUrl.replace('jcr:content', '_jcr_content') + '.tourConfig.xml',
        target: 'virtual-tour-embed-container',
        html5: 'prefer',
        passQueryParameters: true
      });

      productHS.init(settings);

      self.setLevelSix();

      var krpano = document.getElementById('krpanoSWFObject');

      var lookat_interval, touch_interval, last_side, last_side_touch;

      side_check = mdManager.getParameterString('TourPosition'), side_check_touch = mdManager.getParameterString('TourPosition');

      //left: -90
      //front: 0/-0
      //right: 90
      //back: 180/-180
      //top: -45
      //bottom: 45

      $(krpano).mousedown(function () {
        clearInterval(lookat_interval);
        lookat_interval = setInterval(function () {
          if (krpano && krpano.get && seamRefresh) {
            krpano.call('screentosphere(mouse.x, mouse.y, mouseath, mouseatv)');
            var mouseHorizontal = krpano.get('mouseath'),
                mouseVertical = krpano.get('mouseatv'),
                roundedH = Math.round(mouseHorizontal),
                roundedV = Math.round(mouseVertical);
            if (Math.round(mouseHorizontal) % 90 === 0 || Math.round(mouseVertical) % 45 === 0 && Math.round(mouseVertical) !== 0) {
              if (roundedV <= -45) {
                if (last_side !== 'top') {
                  //self.seamAnalyticsRefresh('top');
                  //debug.log('top');
                  last_side = 'top';
                }
              } else if (roundedV >= 45) {
                if (last_side !== 'bottom') {
                  //self.seamAnalyticsRefresh('bottom');
                  //debug.log('bottom');
                  last_side = 'bottom';
                }
              } else if (roundedH === -90) {
                if (last_side !== 'left') {
                  //self.seamAnalyticsRefresh('left');
                  //debug.log('left');
                  last_side = 'left';
                }
              } else if (roundedH === 0) {
                if (last_side !== 'front') {
                  //self.seamAnalyticsRefresh('front');
                  //debug.log('front');
                  last_side = 'front';
                }
              } else if (roundedH === 90) {
                if (last_side !== 'right') {
                  //self.seamAnalyticsRefresh('right');
                  //debug.log('right');
                  last_side = 'right';
                }
              } else if (roundedH === 180 || roundedH === -180) {
                if (last_side !== 'back') {
                  //self.seamAnalyticsRefresh('back');
                  //debug.log('back');
                  last_side = 'back';
                }
              }
              //clearInterval(lookat_interval);
              //_refreshBigBox();
            }
          }
        }, 20);
      }).mouseup(function () {
        clearInterval(lookat_interval);
        if (last_side !== side_check && typeof last_side !== 'undefined') {
          self.seamAnalyticsRefresh(last_side);
          _refreshBigBox();
        }
        side_check = last_side;
      });

      $(krpano).on('touchstart', function () {
        clearInterval(touch_interval);
        touch_interval = setInterval(function () {
          if (krpano && krpano.get && seamRefresh) {
            var touchHorizontal = krpano.get('view.hlookat'),
                touchVertical = krpano.get('view.vlookat'),
                roundedHo = Math.round(touchHorizontal),
                roundedVe = Math.round(touchVertical);
            if (Math.round(touchHorizontal) % 90 === 0 || Math.round(touchVertical) % 45 === 0 && Math.round(touchVertical) !== 0) {
              if (roundedVe <= -45) {
                if (last_side_touch !== 'top') {
                  //self.seamAnalyticsRefresh('top');
                  //debug.log('top');
                  last_side_touch = 'top';
                }
              } else if (roundedVe >= 45) {
                if (last_side_touch !== 'bottom') {
                  //self.seamAnalyticsRefresh('bottom');
                  //debug.log('bottom');
                  last_side_touch = 'bottom';
                }
              } else if (roundedHo > -135 && roundedHo <= -45) {
                if (last_side_touch !== 'left') {
                  //self.seamAnalyticsRefresh('left');
                  //debug.log('left');
                  last_side_touch = 'left';
                }
              } else if (roundedHo > -45 && roundedHo <= 45) {
                if (last_side_touch !== 'front') {
                  //self.seamAnalyticsRefresh('front');
                  //debug.log('front');
                  last_side_touch = 'front';
                }
              } else if (roundedHo > 45 && roundedHo <= 135) {
                if (last_side_touch !== 'right') {
                  //self.seamAnalyticsRefresh('right');
                  //debug.log('right');
                  last_side_touch = 'right';
                }
              } else if (roundedHo > 135 && roundedHo <= -135) {
                if (last_side_touch !== 'back') {
                  //self.seamAnalyticsRefresh('back');
                  //debug.log('back');
                  last_side_touch = 'back';
                }
              }
              //debug.log(roundedHo, roundedVe);
              //clearInterval(touch_interval);
              //_refreshBigBox();
            }
          }
        }, 20);
      }).on('touchend', function () {
        clearInterval(touch_interval);
        if (last_side_touch !== side_check_touch && typeof last_side !== 'undefined') {
          self.seamAnalyticsRefresh(last_side_touch);
          _refreshBigBox();
        }
        side_check_touch = last_side_touch;
      });

      $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function (e) {
        seamRefresh = !seamRefresh;
        if (seamRefresh) {
          setTimeout(function () {
            $('body').on('keyup.modaldismiss', $.proxy(function (e) {
              e.which === 27 && context.broadcast('modal.hidden', { modal: tourModal });
            }, self));
          }, 1000);
        } else {
          $('body').off('keyup.modaldismiss');
        }
      });

      function closeTour(obj) {
        var modalsExist = check.exists('modal.$container', obj) && check.exists('$container', tourModal);
        if (modalsExist && obj.modal.$container.attr('id') === tourModal.$container.attr('id')) {
          analytics.setProp(2, '');
          analytics.setProp(46, '');
          analytics.setProp(47, '');
          analytics.setProp(48, '');
          analytics.setValue('events', '');

          if (check.exists('mdManager.setParameter')) {
            metadata.updateFromString({ Type: settings.basePageType });
          }

          $('#product-overlay, #tooltip').remove();
          $(krpano).remove();
          $(bodySel).show();
          debug.log('hiding/removing tour elements, including: #' + obj.modal.$container.attr('id'));

          if (self.scrollTop) {
            scrollTo(0, self.scrollTop);
          }
          messageHandlers['modal.hidden'] = function () {};
        }
      }

      messageHandlers['modal.hidden'] = closeTour;

      return false;
    };

    //Wiring for seam refresh analytics
    VirtualTour.prototype.seamAnalyticsRefresh = function (side) {
      var levelSixNode, nodePattern;
      if (check.exists(['s', 'mdManager'])) {
        if (side === undefined) {
          side = mdManager.getParameterString('TourPosition');
        }
        analytics.setValue('events', 'event1');
        nodePattern = /(front|left|back|right|top|bottom)/gi;

        //debug.log('Pre-refreshCall ' + mdManager.getParameterString('TourPosition'));
        levelSixNode = mdManager.getParameterString('TourPosition');
        levelSixNode = levelSixNode.replace(nodePattern, side);
        levelSixNode = levelSixNode.trim();
        //debug.log('levelSixNode' + levelSixNode);
        mdManager.setParameter('TourPosition', levelSixNode);
        analytics.setProp(68, levelSixNode);
        //debug.log('Post-refreshCall ' + mdManager.getParameterString('TourPosition'));
        analytics.legacyPV();
        analytics.setValue('events', '');
        //analytics.callDynamicPageview();
      }
    };

    //Wiring for initial tour load analytics
    VirtualTour.prototype.setLevelSix = function () {
      //var levelSixNode;

      function setAnalyticsEvents() {
        if (check.exists('mdManager.setParameter')) {
          metadata.updateFromString({ Type: 'virtualtour' });
        }
        analytics.setProp(68, analytics.getProp(68).trim());
        analytics.setValue('events', 'event1');
        analytics.callDynamicPageview();
        analytics.setValue('events', '');
      }

      if (check.exists(['s', 'mdManager'])) {
        //levelSixNode = mdManager.getParameterString('SubSctnL2');
        //levelSixNode += 'front';
        setTimeout(function () {
          var panocake = document.getElementById('krpanoSWFObject');
          if (panocake && panocake.get) {
            var touchHorizontal2 = panocake.get('view.hlookat'),
                touchVertical2 = panocake.get('view.vlookat'),
                roundedHot = Math.round(touchHorizontal2),
                roundedVet = Math.round(touchVertical2);
            mdManager.setParameter('TourPosition', '');

            var prop68 = '';
            analytics.setProp(68, prop68);
            if (roundedVet <= -45) {
              mdManager.addParameter('TourPosition', 'top');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'top';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else if (roundedVet >= 45) {
              mdManager.addParameter('TourPosition', 'bottom');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'bottom';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else if (roundedHot > -135 && roundedHot <= -45) {
              mdManager.addParameter('TourPosition', 'left');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'left';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else if (roundedHot > -45 && roundedHot <= 45) {
              mdManager.addParameter('TourPosition', 'front');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'front';
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else if (roundedHot > 45 && roundedHot <= 135) {
              mdManager.addParameter('TourPosition', 'right');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'right';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else if (roundedHot > 135 && roundedHot <= -135) {
              mdManager.addParameter('TourPosition', 'back');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'back';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log(mdManager.getParameterString('TourPosition'));
            } else {
              mdManager.addParameter('TourPosition', 'front');
              side_check = mdManager.getParameterString('TourPosition');
              side_check_touch = mdManager.getParameterString('TourPosition');
              prop68 += 'front';
              analytics.setProp(68, prop68);
              setAnalyticsEvents();
              //debug.log('set analytics default');
              //debug.log(mdManager.getParameterString('TourPosition'));
            }
          }
        }, 500);
      }
    };

    VirtualTour.prototype.bindTourHandler = function ($element) {
      var self = this;

      $element.closest(settings.tourWrapSelector).find(settings.tourLaunchSelector).on('click', function (e) {
        e.preventDefault();
        return self.launchTour(this);
      });
    };

    return VirtualTour;
  };

  return {
    init: function () {
      var _ref = asyncToGenerator_default()(regeneratorRuntime.mark(function _callee() {
        var embedpano, VirtualTour;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 454));

              case 2:
                embedpano = context.getGlobal('embedpano');
                VirtualTour = createTour(embedpano);


                ads = check.exists('SniAds.Gallery') ? context.getGlobal('SniAds') : false;
                modUtil.registerjQueryPlugin('virtualTour', VirtualTour);
                $element.virtualTour();

              case 7:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      function init() {
        return _ref.apply(this, arguments);
      }

      return init;
    }(),

    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    }
  };
});
// EXTERNAL MODULE: ./src/app/modules/vote.js
var vote = __webpack_require__(391);
var vote_default = /*#__PURE__*/__webpack_require__.n(vote);

// EXTERNAL MODULE: ./src/app/modules/we-recommend.js
var we_recommend = __webpack_require__(392);
var we_recommend_default = /*#__PURE__*/__webpack_require__.n(we_recommend);

// CONCATENATED MODULE: ./src/app/modules/index.js
/** AUTO GENERATED FILE, DO NOT EDIT **/























































































// EXTERNAL MODULE: ./src/app/behaviors/affix.js
var affix = __webpack_require__(393);
var affix_default = /*#__PURE__*/__webpack_require__.n(affix);

// EXTERNAL MODULE: ./src/app/behaviors/call-protocol.js
var call_protocol = __webpack_require__(394);
var call_protocol_default = /*#__PURE__*/__webpack_require__.n(call_protocol);

// EXTERNAL MODULE: ./src/app/behaviors/collapse-dynamic-ads.js
var collapse_dynamic_ads = __webpack_require__(395);
var collapse_dynamic_ads_default = /*#__PURE__*/__webpack_require__.n(collapse_dynamic_ads);

// EXTERNAL MODULE: ./src/app/behaviors/customer-service.js
var customer_service = __webpack_require__(396);
var customer_service_default = /*#__PURE__*/__webpack_require__.n(customer_service);

// EXTERNAL MODULE: ./src/app/behaviors/deferred-loader.js
var deferred_loader = __webpack_require__(397);
var deferred_loader_default = /*#__PURE__*/__webpack_require__.n(deferred_loader);

// EXTERNAL MODULE: ./src/app/behaviors/dropdown-menu.js
var dropdown_menu = __webpack_require__(398);
var dropdown_menu_default = /*#__PURE__*/__webpack_require__.n(dropdown_menu);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/handle-login.js
var handle_login = __webpack_require__(399);
var handle_login_default = /*#__PURE__*/__webpack_require__.n(handle_login);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/init.js
var gigya_init = __webpack_require__(400);
var gigya_init_default = /*#__PURE__*/__webpack_require__.n(gigya_init);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/login.js
var login = __webpack_require__(401);
var login_default = /*#__PURE__*/__webpack_require__.n(login);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/profile.js
var gigya_profile = __webpack_require__(402);
var gigya_profile_default = /*#__PURE__*/__webpack_require__.n(gigya_profile);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/remove-inline-styles.js
var remove_inline_styles = __webpack_require__(403);
var remove_inline_styles_default = /*#__PURE__*/__webpack_require__.n(remove_inline_styles);

// EXTERNAL MODULE: ./src/app/behaviors/gigya/screens.js
var screens = __webpack_require__(404);
var screens_default = /*#__PURE__*/__webpack_require__.n(screens);

// EXTERNAL MODULE: ./src/app/behaviors/hotspot.js
var hotspot = __webpack_require__(405);
var hotspot_default = /*#__PURE__*/__webpack_require__.n(hotspot);

// CONCATENATED MODULE: ./src/app/behaviors/hover-intent.js

/**
 * hover-intent
 *
 * This behavior listens for click events on a data-type of menu-action. It prevents
 * the first click from passing through, but allows a subsequent click.
 */

SNI.Application.addBehavior('hover-intent', function (context) {

  var debug = context.getService('logger').create('behavior.hover-intent');
  var check = context.getService('check').new(debug);
  var utils = context.getService('utility');

  utils.addJavaScriptCssClass();

  if (!check.jqueryPlugin('hoverIntent')) return {};

  var defaults = [{
    dataType: 'sub-menu-action',
    timeout: 350,
    reverse: {
      dropdown: false,
      flyout: false
    }
  }, {
    dataType: 'menu-action',
    reverse: {
      dropdown: false,
      flyout: true
    }
  }];

  var config = context.getConfig('hoverIntent') || defaults;

  if (!Array.isArray(config)) {
    debug.error('Expected context to be an array but got type ' + (typeof config === 'undefined' ? 'undefined' : helpers_typeof_default()(config)));
    return {};
  }

  var hoverTypes = config.map(function (_ref) {
    var dataType = _ref.dataType;
    return dataType;
  });

  var lastElement = null;
  var $currentEl = $(context.getElement());

  function openMenu() {
    debug.log('openMenu');
    $(this).addClass('is-Expanded');
  }

  function isOpen() {
    return $(this).hasClass('is-Expanded');
  }

  var openTouchMenu = function openTouchMenu(el) {
    closeMenu.call(lastElement);
    openMenu.call(el);
    debug.log('openTouchMenu');
    utils.bindClickOutside($(el), 'hover-intent.clickOutside', function () {
      lastElement = null;
      closeMenu.call(el);
      utils.unbindClickOutside('hover-intent.clickOutside');
    });
    lastElement = el;
  };

  function closeMenu() {
    debug.log('closeMenu');
    $(this).removeClass('is-Expanded');
  }

  function adjustOffScreenDropdowns(selector, container, reverse) {
    var hoverElements = container.find(selector);
    hoverElements.each(function (index, element) {
      var dropdownEl = $(element).find('[data-type="dropdown-menu"]');
      if (!dropdownEl || !dropdownEl.length) {
        return;
      }

      // make dropdown element rendered on the page in hidden mode
      // to get proper width and make calculations
      dropdownEl.css({ visibility: 'hidden', display: 'block' });

      var flyouts = dropdownEl.find('.is-Flyout');

      var documentWidth = $('body').outerWidth(true);
      var dropdownEnd = $(element).offset().left + dropdownEl.outerWidth();

      // if dropdown ends off the screen just make dropdown and its flyouts
      // reversed, so it will be displayed from right to left
      if (documentWidth <= dropdownEnd) {
        if (reverse.dropdown) {
          $(element).addClass('is-Reversed');
        }
        if (reverse.flyout) {
          dropdownEl.addClass('is-ReversedFlyout');
        }

        // otherwise, remove reversed state from dropdown and calculate
        // whether flyouts should be displayed in normal mode or from right to left
      } else {
        $(element).removeClass('is-Reversed');

        if (reverse.flyout) {
          // check each dropdown item with flyout
          var isFlyoutReversed = false;
          flyouts.each(function (index, element) {
            if (isFlyoutReversed) {
              return;
            }

            var flyoutEl = $(element);
            flyoutEl.css({ visibility: 'hidden', display: 'block' });

            var flyoutEnd = flyoutEl.outerWidth();
            flyoutEl.css({ visibility: '', display: '' });

            isFlyoutReversed = documentWidth <= dropdownEnd + flyoutEnd;
          });

          // All flyouts will be reversed if any flyout ends off screen
          if (isFlyoutReversed) {
            dropdownEl.addClass('is-ReversedFlyout');

            // otherwise remove possibly added classes from previous resize
          } else {
            dropdownEl.removeClass('is-ReversedFlyout');
          }
        }
      }

      // return dropdown to hidden state after all calculations performed
      dropdownEl.css({ visibility: '', display: '' });
    });
  }

  var navigateAway = function navigateAway(el, event) {
    // always close menu; handles new "Recipe Box" drop-down where menu-action is not a live link
    closeMenu.call($(el));
    var isLink = event && event.target && event.target.tagName.toLowerCase() === 'a';
    if (isLink && event.target.href && event.type === 'touchstart') {
      window.location = event.target.href;
    }
  };

  return {
    init: function init() {
      config.forEach(function (_ref2) {
        var timeout = _ref2.timeout,
            dataType = _ref2.dataType,
            reverse = _ref2.reverse;

        var selector = '[data-type=' + dataType + ']';
        $currentEl.hoverIntent({
          over: openMenu,
          out: closeMenu,
          timeout: timeout,
          selector: selector
        });

        if (reverse.dropdown || reverse.flyout) {
          adjustOffScreenDropdowns(selector, $currentEl, reverse);
          $(window).on('resize', function () {
            adjustOffScreenDropdowns(selector, $currentEl, reverse);
          });
        }
      });
    },
    ontouchstart: function ontouchstart(event, element, elementType) {
      debug.log('ontouchstart');
      if (hoverTypes.includes(elementType)) {
        event.stopPropagation();
        event.preventDefault();

        !isOpen.call($(event.target).closest('LI[data-type="menu-action"]')) ? openTouchMenu(element) : navigateAway(element, event);
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/behaviors/lazy-load.js
var lazy_load = __webpack_require__(406);
var lazy_load_default = /*#__PURE__*/__webpack_require__.n(lazy_load);

// EXTERNAL MODULE: ./src/app/behaviors/lightbox.js
var lightbox = __webpack_require__(407);
var lightbox_default = /*#__PURE__*/__webpack_require__.n(lightbox);

// EXTERNAL MODULE: ./src/app/behaviors/load-more.js
var behaviors_load_more = __webpack_require__(408);
var behaviors_load_more_default = /*#__PURE__*/__webpack_require__.n(behaviors_load_more);

// EXTERNAL MODULE: ./src/app/behaviors/maps.js
var maps = __webpack_require__(409);
var maps_default = /*#__PURE__*/__webpack_require__.n(maps);

// EXTERNAL MODULE: ./src/app/behaviors/media-stream.js
var media_stream = __webpack_require__(410);
var media_stream_default = /*#__PURE__*/__webpack_require__.n(media_stream);

// EXTERNAL MODULE: ./src/app/behaviors/multi-component-ad.js
var multi_component_ad = __webpack_require__(411);
var multi_component_ad_default = /*#__PURE__*/__webpack_require__.n(multi_component_ad);

// EXTERNAL MODULE: ./src/app/behaviors/popover.js
var behaviors_popover = __webpack_require__(412);
var behaviors_popover_default = /*#__PURE__*/__webpack_require__.n(behaviors_popover);

// EXTERNAL MODULE: ./src/app/behaviors/popup.js
var popup = __webpack_require__(413);
var popup_default = /*#__PURE__*/__webpack_require__.n(popup);

// EXTERNAL MODULE: ./src/app/behaviors/product-list.js
var product_list = __webpack_require__(414);
var product_list_default = /*#__PURE__*/__webpack_require__.n(product_list);

// CONCATENATED MODULE: ./src/app/services/read-more.js




SNI.Application.addService('read-more', function (application) {

  var config = void 0,
      readMoreConfig = void 0;
  var check = application.getService('check');
  var SniAds = application.getGlobal('SniAds');
  var device = application.getService('device-type');
  var debug = application.getService('logger').create('service.read-more');

  function adLibLoaded() {
    return check.exists(['SniAds.River', 'SniAds.Event']);
  }

  function setConfig(moduleConfig) {
    config = moduleConfig;
  }

  function setReadMoreConfig(config) {
    readMoreConfig = config;
    debug.log('Read more config', readMoreConfig);
  }

  /**
   * Calculate the initial height of the content when its hidden
   * @param {number} parentTop Offset top for the parent element
   * @param {number} childTop Offset top for the child element
   * @param {number} childHeight Initial height of the child element
   * @returns {number} Difference between the two values plus the initial height of the child element
   * @private
   */
  function calcInitialHeight(parentTop, childTop, childHeight) {
    return childTop - parentTop + childHeight;
  }

  function handleReadMore() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var containerClass = data && data.containerClass || '',
        $container = $('.' + containerClass),
        readMoreRemoved = $container.data('expanded');
    if (!device.isMobile && !readMoreRemoved) {
      $container.data('expanded', true);
      if (adLibLoaded()) {
        SniAds.River.repeatBigbox({
          adClass: 'rr-ad bigbox-ad module text-center',
          target: '.' + containerClass + '-aside',
          base: config.adInterval,
          disable: false,
          mobile: {
            disable: true
          }
        });
      }
    }
  }

  /**
   * Adjusts height of contents container to calculated one.
   */
  function setHeight($targetModule) {
    var $revealTarget = $targetModule.find('[data-read-more-target]');
    var divHeight = 310;
    var $element = $targetModule;
    var elementOffset = $element.offset();
    var revealTargetOffset = $revealTarget.offset();
    var height = readMoreConfig.stream && !readMoreConfig.disableStream ? readMoreConfig.itemHeight : calcInitialHeight(elementOffset.top, revealTargetOffset.top, divHeight);

    debug.log('Setting height to', height);

    $element.height(height).css({
      'width': readMoreConfig.stream && !readMoreConfig.disableStream ? 'auto' : '100%',
      'overflow': 'hidden',
      'position': 'relative'
    });

    if (readMoreConfig.collapsed) {
      $element.addClass(readMoreConfig.collapsed);
    }
  }

  /**
   * Skip read more if the article is short
   * Perform 2 checks to bail out of adding the readmore button: 
   * 1) if a shopping element is detected then exit
   * 2) If article height is less than a threshold then skip
   * @param {object} $element 
   */
  function skipReadMore($element) {
    /*  If there are shopping elements present then skip  */
    var shoppingModules = ['shopping', 'shopping-embed', 'shopping-promo'];
    var shoppingSelectors = shoppingModules.map(function (name) {
      return '[data-module="' + name + '"]';
    }).join(',');
    var $shoppingElements = $element.find(shoppingSelectors);
    if ($shoppingElements.length > 0) {
      debug.log('Shopping elements are present');
      return true;
    }
    /* Otherwise check for the length of the article to make sure it needs a button */
    var result = void 0;
    var desiredHeight = readMoreConfig.readMoreThreshold; // A pixel height that will be a minimum length before we add the read more button.  In other words, we won't add it to a short article
    var moduleHeight = $element.get(0) && $element.get(0).scrollHeight;
    var imageHeights = 0; // Images that are not loaded will need to be accounted for, otherwise the article will appear to be shorter than it is
    var debugMsg = 'Adding read more';
    $element.find('.a-Image').each(function (i, e) {
      if (e.naturalHeight === 0) {
        // If image height is zero then assume 400px image height.   The image might be lazy loaded and we need a default height value
        imageHeights += 400;
      }
    });

    if (desiredHeight && moduleHeight) {
      result = moduleHeight + imageHeights < desiredHeight;
      debugMsg = result ? 'Skipping read more' : debugMsg;
    }
    debug.log(debugMsg);
    return result;
  }

  function removeSection($element) {
    $element.find('[data-read-more-section]').remove();
    $element.height('auto');
    if (readMoreConfig.collapsed) {
      $element.removeClass(readMoreConfig.collapsed);
    }
  }

  function removeReadMore($element, containerClass) {
    removeSection($element);
    handleReadMore({ containerClass: containerClass });
  }
  return {
    handleReadMore: handleReadMore,
    setConfig: setConfig,
    setReadMoreConfig: setReadMoreConfig,
    skipReadMore: skipReadMore,
    removeSection: removeSection,
    removeReadMore: removeReadMore,
    calcInitialHeight: calcInitialHeight,
    setHeight: setHeight
  };
});
// CONCATENATED MODULE: ./src/app/behaviors/read-more.js
/**
 * @fileoverview Read More Behavior
 * @author Jonathan Kemp
 */

/*
 * For when you want to "Read more", but you don't need to see it all on load.
 */



SNI.Application.addBehavior('read-more', function (context) {
  'use strict';

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var config = Object.assign({}, context.getConfig('read-more'));
  var SniAds = context.getGlobal('SniAds');
  var debug = context.getService('logger').create('behavior.read-more');
  var check = context.getService('check').new(debug);
  var readMoreSvc = context.getService('read-more');
  var setHeight = readMoreSvc.setHeight;
  readMoreSvc.setReadMoreConfig(config);

  var $module = config.stream && !config.disableStream ? $(config.targetModule) : $(context.getElement());

  function adjustHeight() {
    // behaviors can use the current module as target
    setHeight($module);
  }

  function windowResizeCallback() {
    adjustHeight();
  }

  function slotRenderCallback(slot) {
    if (slot.slot.getSlotElementId().indexOf('dfp_native_ingredient') > -1 && !slot.isEmpty) {
      adjustHeight();
    }
  }

  function readMore(element, isSkipReadMore) {
    debug.log('readMore: element: ', element);
    // Remove window resize callback to prevent further height adjustments.
    $(window).off('resize', windowResizeCallback);
    var $elem = $(element),
        containerClass = $elem.data('container-class');
    // Remove advertisements callback to prevent further height adjustments.
    if (check.exists('SniAds.Event')) {
      SniAds.Event.unsubscribe('slotRenderComplete', slotRenderCallback);
    }
    // show the hidden content
    if (config.stream && !config.disableStream) {
      $elem.closest(config.targetModule).css({
        'overflow': 'visible',
        'height': 'auto'
      });
      $('[role=contentWell]').css({
        'float': 'none'
      });
    } else {
      $module.css({
        'overflow': 'visible',
        'height': 'auto'
      });
    }

    if (config.collapsed) {
      if (config.stream && !config.disableStream) {
        $elem.closest(config.targetModule).removeClass(config.collapsed);
      } else {
        $module.removeClass(config.collapsed);
      }
    }

    // remove the container from the DOM
    // Make sure to remove the container after the class has been removed,
    // so that the styles can go back to normal. See CCN-1676.
    $(element).closest('[data-read-more-section]').remove();
    readMoreSvc.handleReadMore({ containerClass: containerClass });
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'read-more':
          debug.log('read-more: click');
          readMore(element);
          break;

        default:
          break;
      }
    },
    init: function init() {
      var $revealTarget = $('[data-read-more-target]');
      var skipRM = void 0;

      skipRM = readMoreSvc.skipReadMore($module);

      if ($revealTarget.length === 0 || skipRM === true) {
        // Remove 'read-more' button and collapsed state.
        readMoreSvc.removeSection($module);
      } else {
        adjustHeight();
        $(window).on('resize', windowResizeCallback);
      }

      // CCN-1067
      // Force it to recalculate module height after native ingredient ad slot is loaded to account for
      // variable height slots that previously pushed the contents below the visible area.
      if (check.exists('SniAds.Event')) {
        SniAds.Event.subscribe('slotRenderComplete', slotRenderCallback);
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/behaviors/router.js
var behaviors_router = __webpack_require__(415);
var behaviors_router_default = /*#__PURE__*/__webpack_require__.n(behaviors_router);

// EXTERNAL MODULE: ./src/app/behaviors/shop-this-look.js
var shop_this_look = __webpack_require__(416);
var shop_this_look_default = /*#__PURE__*/__webpack_require__.n(shop_this_look);

// EXTERNAL MODULE: ./src/app/behaviors/social-pinterest.js
var social_pinterest = __webpack_require__(417);
var social_pinterest_default = /*#__PURE__*/__webpack_require__.n(social_pinterest);

// EXTERNAL MODULE: ./src/app/services/social/social.js
var social = __webpack_require__(153);
var social_default = /*#__PURE__*/__webpack_require__.n(social);

// CONCATENATED MODULE: ./src/app/behaviors/social-share.js





SNI.Application.addBehavior('social-share', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var debug = context.getService('logger').create('behavior.social-share');
  var social = context.getService('social');
  var templates = context.getService('template');
  var deviceType = context.getService('device-type');
  var element = context.getElement();
  var $element = $(element);

  var defaults = {
    modalId: 'social-modal',
    containerPrefix: 'socialShare',
    deviceType: 'desktop',
    layout: 'horizontal',
    facebookDialogType: 'share',
    showCounts: 'none',
    useEmailCaptcha: true,
    noButtonBorders: true,
    emailBody: '$userMsg$<br/><br/>$title$: $URL$<br/><br/>From,<br/>$sender$',
    blackAndWhite: '', // set to black-and-white, for gray sharebar
    addWhere: 'prepend',
    mobileIcons: deviceType.isMobile,
    mobileLayout: 'horizontal',
    mobileEmail: {
      shareSubject: 'Check out this page on HGTV',
      shareBody: 'I thought you would be interested in the page on HGTV: '
    }
  };
  var config = Object.assign({}, defaults, context.getConfig('socialShare'));
  var shareBarInstanceCount = 0;
  var $shareBar = void 0;
  var sharebarClass = 'o-SocialShare';

  function appendSocialShareTemplate($el) {
    var shareBarId = void 0;
    var $shareElement = $el.find('.m-GigyaShareWrap');
    shareBarInstanceCount++;
    if ($el.attr('id')) {
      shareBarId = $el.attr('id') + '-' + config.containerPrefix + '-' + shareBarInstanceCount;
    } else {
      $el.attr('id', shareBarId = 'dynamicSharebar');
    }
    if ($shareElement.length === 0) {
      //add client-side template if not already done on the server
      config.addWhere === 'append' ? $shareElement.append(templates.socialShare(shareBarId)) : $shareElement.prepend(templates.socialShare(shareBarId));
    } else {
      // Keep server side template, but add unique id for gigya
      $shareElement.attr('id', shareBarId);
      if ($el.attr('id') === shareBarId) {
        $el.removeAttr('id');
      }
    }
    return '#' + shareBarId;
  }
  /**
   * @function getMetaData - returns object containing social share values obtained from the og: meta tags
   *
   * @returns {object} with description, title, url, image and appid
   */
  function getMetaData() {
    return {
      description: $('meta[property="og:description"]').attr('content'),
      title: $('meta[property="og:title"]').attr('content'),
      url: $('meta[property="og:url"]').attr('content'),
      image: $('meta[property="og:image"]').attr('content')
    };
  }

  function initBar($el, cfg) {
    debug.log('social-share behavior initBar()');
    if ($el && $el.length) {
      $element = $el;
    }
    if (cfg) {
      config = cfg;
    }
    var shareBarId = appendSocialShareTemplate($element);
    debug.log('shareBarId:', shareBarId);
    $shareBar = $(shareBarId);

    debug.log('config.blackAndWhite:', config.blackAndWhite);
    // TODO: Determine if overrides ever set blackAndWhite
    if (config.blackAndWhite) {
      $shareBar.addClass(config.blackAndWhite);
    }

    // Get metadata and build the buttons
    if (config.shareValues) {
      debug.log('config.shareValues:', config.shareValues);
      config = Object.assign({}, config, { metadata: config.shareValues });
    } else {
      config = Object.assign({}, config, { metaData: getMetaData() });
      debug.log('config.metaData:', config.metaData);
    }
    social.sharebar.show($shareBar, config);
  }

  function insertDynamicBar(name, data) {
    if (data && data.data) {
      config = Object.assign({}, config, { metaData: data.data });
    } else {
      config = Object.assign({}, config, { metaData: getMetaData() });
    }
    config.shareSource = data.source;
    config = Object.assign({}, config, data.config);
    data.target.addClass(sharebarClass);
    initBar(data.target, config);
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    messages: ['socialShare.updateShareBar', 'socialShare.remove', 'socialShare.requested', 'socialShare.resetSource'],

    onmessage: function onmessage(name, data) {
      debug.log(name + ' T3 event was fired', data);
      switch (name) {
        case 'socialShare.remove':
          //does not do anything currently, since vertical-gallery and photo-scroll do not currently contain any share bars
          $('.' + sharebarClass).remove();
          break;
        case 'socialShare.requested':
          insertDynamicBar(name, data);
          break;
        case 'socialShare.resetSource':
          config.shareSource = '';
          break;
        case 'socialShare.updateShareBar':
          // metaData passed, use it.
          if (data) {
            config = Object.assign({}, config, { metaData: data });
          } else {
            config = Object.assign({}, config, { metaData: getMetaData() });
          }
          // call social service to show the sharebar
          social.sharebar.show($shareBar, config);
          break;
      }
    },

    /**
     * @function init - init function binds on-click events for sharing
     *
     * @param {DOMElement} -
     *          passes in the DOM object/element containing the social share buttons/icons
     */
    init: initBar

  };
});
// EXTERNAL MODULE: ./src/app/behaviors/tab.js
var tab = __webpack_require__(418);
var tab_default = /*#__PURE__*/__webpack_require__.n(tab);

// EXTERNAL MODULE: ./src/app/behaviors/theme-selector.js
var behaviors_theme_selector = __webpack_require__(419);
var behaviors_theme_selector_default = /*#__PURE__*/__webpack_require__.n(behaviors_theme_selector);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(420);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// CONCATENATED MODULE: ./src/app/behaviors/toggle-on-message.js


SNI.Application.addBehavior('toggle-on-message', function (context) {

  var el = context.getElement();
  var $el = $(el);
  var debug = context.getService('logger').create('behavior.toggle-on-message');

  var _context$getService = context.getService('utility'),
      deepMerge = _context$getService.deepMerge;

  var defaults = {
    targetEl: $el,
    targetGlobal: false,
    hideOn: '',
    showOn: ''
  };

  var configCollection = context.getConfig('toggle-on-message');

  if (configCollection === null) {
    debug.warn('toggle-on-message was included as a behavior for ' + el.id + ', but no config was given');
    return {};
  }

  if (!Array.isArray(configCollection)) {
    debug.error('toggle-on-message config expected to be array got type of ' + (typeof configCollection === 'undefined' ? 'undefined' : helpers_typeof_default()(configCollection)), $el, configCollection);
    return {};
  }

  // config is an array of toggleable targets that match the defaults object
  var config = configCollection.map(function (item) {
    return Object.assign({}, defaults, item);
  })
  // if the targetEl is a string, map it to an element, otherwise leave it
  .map(function (item) {
    return typeof item.targetEl === 'string' ? Object.assign({}, item, { targetEl: item.targetGlobal ? $(item.targetEl) : $el.find(item.targetEl) }) : item;
  });

  var collectMessages = function collectMessages(config, key) {
    return config.map(function (item) {
      return defineProperty_default()({}, item[key], [item.targetEl]);
    }).reduce(function (msgs, msg) {
      return msgs.concat(msg);
    }, []).reduce(function (msgMap, msg) {
      return deepMerge(msgMap, msg);
    }, {});
  };

  var hideMessages = collectMessages(config, 'hideOn');
  var showMessages = collectMessages(config, 'showOn');

  var messages = [].concat(hideMessages, showMessages).map(function (msgMap) {
    return Object.keys(msgMap);
  }).reduce(function (msgs, msg) {
    return msgs.concat(msg);
  }, []).filter(function (msg, pos, msgs) {
    return msgs.indexOf(msg) === pos;
  });

  return {
    messages: messages,

    onmessage: function onmessage(name, data) {

      if (hideMessages.hasOwnProperty(name)) {
        hideMessages[name].forEach(function (el) {
          debug.log('hiding', el, 'due to', name);
          el.hide();
        });
      }

      if (showMessages.hasOwnProperty(name)) {
        showMessages[name].forEach(function (el) {
          debug.log('showing', el, 'due to', name);
          el.show();
        });
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/behaviors/toggle-proxy.js
var toggle_proxy = __webpack_require__(421);
var toggle_proxy_default = /*#__PURE__*/__webpack_require__.n(toggle_proxy);

// EXTERNAL MODULE: ./src/app/behaviors/track-shopping.js
var track_shopping = __webpack_require__(422);
var track_shopping_default = /*#__PURE__*/__webpack_require__.n(track_shopping);

// EXTERNAL MODULE: ./src/app/services/truncate.js
var truncate = __webpack_require__(154);
var truncate_default = /*#__PURE__*/__webpack_require__.n(truncate);

// CONCATENATED MODULE: ./src/app/behaviors/truncate.js



SNI.Application.addBehavior('truncate', function (context) {

  var truncate = context.getService('truncate');

  var $element = $(context.getElement()),
      debug = context.getService('logger').create('behavior.truncate');

  var defaults = {
    attribName: 'truncate',
    suffixString: '...',
    suffixStringLess: ' ...Less',
    moreLessLinks: false,
    dotsWithLinks: '... ',
    truncateLength: 190,
    classMoreLink: 'more',
    classLessLink: 'less',
    classOriginalText: 'originalText',
    classTruncatedText: 'truncatedText'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  function bindLinkBehavior($el) {
    var $links = $el.find('.' + config.classMoreLink + ', .' + config.classLessLink);
    $links.off('click').on('click', function () {
      $el.find('.' + config.classTruncatedText + ', .' + config.classOriginalText).toggle();
      var isTruncated = $el.find('.' + config.classTruncatedText).is(':visible');
      var newLink = '<a href="#" class="' + (isTruncated ? config.classMoreLink : config.classLessLink) + '">' + (isTruncated ? config.suffixString : config.suffixStringLess) + '</a>';
      $links.replaceWith(newLink);
      bindLinkBehavior($el);
      return false;
    });
  }

  return {

    config: config,

    init: function init() {
      var sel = '[data-' + config.attribName + ']';
      debug.log('config', config);

      $element.find(sel).each(function () {
        var $this = $(this);
        var $nested = $this.find(sel);
        if ($nested.length) {
          debug.warn('nested truncation not supported', $nested);
          return;
        }
        var maxLength = $this.data(config.attribName) ? $this.data(config.attribName) : config.truncateLength;
        var originalString = $this.html().trim();
        var dots = config.moreLessLinks ? (config.dotsWithLinks ? config.dotsWithLinks : '') + '<a href="#" class="' + config.classMoreLink + '">' + config.suffixString + '</a>' : config.suffixString;
        var truncatedString = truncate.html(originalString, maxLength, dots.length ? ' ' + dots : '');

        if (originalString !== truncatedString) {
          var truncatedHTML = '<span class="' + config.classTruncatedText + '">' + truncatedString + '</span>';
          if (config.moreLessLinks) {
            $this.html('<span class="' + config.classOriginalText + '">' + originalString + ' ' + dots + '</span>' + truncatedHTML);
            $this.find('.' + config.classOriginalText).hide();
            bindLinkBehavior($this);
          } else {
            $this.html(truncatedHTML);
          }
        }
      });
    }

  };
});
// EXTERNAL MODULE: ./node_modules/kefir/dist/kefir.js
var kefir = __webpack_require__(423);
var kefir_default = /*#__PURE__*/__webpack_require__.n(kefir);

// CONCATENATED MODULE: ./src/app/behaviors/typeahead/resultTemplates.js
/**
 * This fuction returns the HTML template of a single hint.
 * Not to be used alone.
 * 
 * @param {string} result A typeahead hint entry
 * @param {string} searchText The text currently entered into the search box
 */
var resultItem = function resultItem(result, searchText) {
  return '\n  <li data-type="typeahead-hint">\n    <a href="javascript:;">\n      <span class="typeahead-display">\n        ' + result.replace(searchText, '<strong>' + searchText + '</strong>') + '\n      </span>\n    </a>\n  </li>\n';
};

/**
 * A function that returns the HTML template of the hints dropdown
 * 
 * @param {string[]} results An array of typeahead hints
 * @param {string} searchText The text currently entered into the search box
 */
var resultsList = function resultsList(parentMoleculeClass, results, searchText) {
  return '\n  <div class="' + parentMoleculeClass + '__m-TypeAheadMenu">\n    <ul class="typeahead-list">\n      ' + results.map(function (result) {
    return resultItem(result, searchText);
  }).join('\n') + '\n    </ul>\n  </div>';
};
// CONCATENATED MODULE: ./src/app/behaviors/typeahead/resultFilter.js
/**
 * Returns a function taking searchText and an array of typeahead hints.
 * This function iterates over the given array of hints, finds up to
 * maxResults, and appends those to a new array. It then returns an
 * object with the passed in searchText and the new array of hints.
 * 
 * @param {number} maxResults Max number of hints to return from the filter
 * @param {number} searchTermLength Minimum amount of characters a search term must be to return a result
 */
var resultFilter = function resultFilter(maxResults, searchTermLength) {
  return function (searchText, results) {
    var hints = [];

    // Escape valve for search terms too short
    if (searchText.length < searchTermLength) {
      return {
        searchText: searchText,
        hints: hints
      };
    }

    for (var i = 0; i < results.length; ++i) {
      if (results[i].includes(searchText)) {
        hints.push(results[i]);
      }
      if (hints.length === maxResults) {
        break;
      }
    }

    return {
      searchText: searchText,
      hints: hints
    };
  };
};

/* harmony default export */ var typeahead_resultFilter = (resultFilter);
// CONCATENATED MODULE: ./src/app/behaviors/typeahead/fetchResults.js
var buildURL = function buildURL(brand, term) {
  return '/apps/sni-foundation/servlets/typeAhead?searchTerm=' + term + '&site=' + brand;
};

var fetchBrandResults = function fetchBrandResults(brand) {
  return function (emitter, _ref) {
    var type = _ref.type,
        value = _ref.value;

    if (type === 'value') {
      $.ajax(buildURL(brand, value)).done(function (data) {
        emitter.emit(data);
      });
    }
  };
};

/* harmony default export */ var fetchResults = (fetchBrandResults(SNI.Config.brand));
// CONCATENATED MODULE: ./src/app/behaviors/typeahead/index.js






var MAX_TYPEAHEAD_SUGGESTIONS = 8;
var SEARCH_TERM_LENGTH = 3;

/**
 * @param {JQueryElement} $element The jquery wrapper element for the associated module
 * @param {HTMLElement} hintsContainerEl The element that contains the rendered hints
 * @param {Array<stream>} clearStreams A group of streams that on value should clear the typeahead hints
 */
var typeahead_clearHints = function clearHints($element, clearStreams) {
  var hide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : hints_hideHints;
  return Object(kefir["merge"])(clearStreams).onValue(function () {
    hints_hideHints($element);
  });
};

/**
 * @param {JQueryElement} $element The jquery wrapper element for the associated module
 * @param {string} parentModuleClass
 * @param {stream} searchTextStream A stream emitting the text for the current searched phrase
 * @param {stream} typeAheadServiceStream A stream emitting all the results matching the current search term
 * @param {function} resultsFilter A filter fed to kefirs combine that filters down the typeahead results into a small hints list
 * @param {function} show alias to showHints for easier testing
 */
var typeahead_typeAhead = function typeAhead($element, parentMoleculeClass, searchTextStream, typeAheadServiceStream, resultsFilter) {
  var show = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : hints_showHints;

  Object(kefir["combine"])([searchTextStream, typeAheadServiceStream], resultsFilter).map(function (_ref) {
    var searchText = _ref.searchText,
        hints = _ref.hints;
    return hints.length > 0 && searchText.length >= SEARCH_TERM_LENGTH ? resultsList(parentMoleculeClass, hints, searchText) : '';
  }).onValue(function (hints) {
    return show($element, hints);
  });
};

/**
 * @param {stream} searchStream A stream emitting strings to search for
 * @param {SEARCH_TERM_LENGTH} len The length of the search term to be sent to the server
 * @param {function} fetch Makes a request to the typeahead search service
 */
var typeahead_typeAheadServiceStream = function typeAheadServiceStream(searchStream) {
  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SEARCH_TERM_LENGTH;
  var fetch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fetchResults;
  return searchStream.filter(function (searchText) {
    return searchText.length >= len;
  }) // Only accept strings of valid length
  .map(function (searchText) {
    return searchText.slice(0, len);
  }) // Get the first len characters to be used as search term
  .skipDuplicates() // Only fetch results for the term once
  .withHandler(fetch);
}; // Do the fetch to the search service

SNI.Application.addBehavior('typeahead', function (context) {
  return {
    onmousedown: function onmousedown(event, element, elementType) {
      // Ensure focusout isn't fired
      if (elementType === 'typeahead-hint') {
        event.preventDefault();
      }
    },
    onclick: function onclick(event, element, elementType) {
      var input = context.getElement().querySelector('input');
      switch (elementType) {
        case 'typeahead-hint':
          input.value = element.innerText;
          $(input).submit();
      }
    },
    init: function init() {
      var element = context.getElement();
      var $element = $(element);
      var input = element.querySelector('input');
      var parentMoleculeClass = context.getConfig('selectorPrefix') || 'm-SearchBox';

      // Activation streams. These are the source for typeahead results.
      var inputStream = Object(kefir["fromEvents"])(input, 'input', function (e) {
        return e.target.value.toLowerCase();
      });
      var focusStream = Object(kefir["fromEvents"])(input, 'focus', function (e) {
        return e.target.value;
      });

      // Search streams. These power the typeahead functionality.
      var searchStream = Object(kefir["merge"])([inputStream, focusStream]);
      var searchTextStream = searchStream.debounce(300);

      // Deactivation streams. Should result in typeahead hint menu going away.
      var belowMinLengthTextStream = inputStream.filter(function (text) {
        return text.length < SEARCH_TERM_LENGTH;
      });
      var losesFocusStream = Object(kefir["fromEvents"])(element, 'focusout', function (e) {
        return !element.contains(e.relativeTarget);
      });

      typeahead_clearHints($element, [belowMinLengthTextStream, losesFocusStream]);

      typeahead_typeAhead($element, parentMoleculeClass, searchTextStream, typeahead_typeAheadServiceStream(searchStream), typeahead_resultFilter(MAX_TYPEAHEAD_SUGGESTIONS, SEARCH_TERM_LENGTH));
    }
  };
});
// CONCATENATED MODULE: ./src/app/behaviors/index.js
/** AUTO GENERATED FILE, DO NOT EDIT **/




































// EXTERNAL MODULE: ./src/app/services/ads.js
var services_ads = __webpack_require__(424);
var services_ads_default = /*#__PURE__*/__webpack_require__.n(services_ads);

// CONCATENATED MODULE: ./src/app/services/ajax.js

SNI.Application.addService('ajax', function (application) {
  'use strict';

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var service = void 0;
  var debug = application.getService('logger').create('service.ajax');
  var check = application.getService('check').new(debug);
  var metadata = application.getService('metadata');
  var analytics = application.getService('analytics');
  var template = application.getService('template');

  function initializeModules(currentContext) {
    var $currentContext = $(currentContext);

    application.startAll($currentContext);
    application.broadcast('ajax.modulesInitialized', {
      context: currentContext
    });
  }

  function loadAreaContent(data) {
    var target = data.target || '',
        $target = $(document).find('[data-sni-area=' + target + ']'),
        href = data.href || '',
        targetType = $target.attr('data-sni-area-type') || 'replace',
        suppressLoadAnim = data.suppressLoadAnim ? data.suppressLoadAnim : false,
        $savingOldContent = '',
        ajaxURL = '';

    if (!href || !target) {
      debug.warn('href and target not provided correctly, aborting...');
      return false;
    }

    if (!$target.length) {
      $target = $(template.targetArea(target)).appendTo('body');
    }

    $target.removeClass('loaded').addClass('loading');

    if (targetType === 'replace') {
      scrollTo(0, 0);
      if (!suppressLoadAnim) {
        $target.html(template.loadingHTML());
      }
      $savingOldContent = $target;
    } else {
      if (!suppressLoadAnim) {
        $target.append(template.loadingHTML());
      }
    }

    application.broadcast('ajax.areaContentLoading', {
      target: target
    });

    ajaxURL = cleanURLForCQ(href, target);

    if (check.isLocalhost() || check.isAuthor()) {
      if (ajaxURL.indexOf('wcmmode=disabled') === -1) {
        ajaxURL += '?wcmmode=disabled';
      }
    }

    $.ajax({
      'cache': false,
      'url': ajaxURL,
      'complete': function complete(data) {
        areaContentLoaded({
          target: target,
          suppressLoadAnim: suppressLoadAnim,
          href: href,
          content: data.responseText
        });
      },
      'error': function error() {
        if (targetType === 'replace') {
          areaContentError({
            target: target,
            href: href,
            content: $savingOldContent
          });
        }
      }
    });
  }

  function cleanURLForCQ(url, target) {
    var cleanURL = void 0,
        relativeCqBasePage = void 0;

    if (!check.exists('cqBasePage')) {
      debug.error('cqBasePage is not defined! this is no bueno!');
      return;
    }

    if (window.location.host.indexOf('.mobile.') > -1) {
      target += '.mobile';
    }

    url = url.replace(/^https?:\/\/[^\/]*/, '');
    relativeCqBasePage = application.getGlobal('cqBasePage').replace(/^https?:\/\/[^\/]*/, '');

    if (url.lastIndexOf(relativeCqBasePage) === -1) {
      if (url.indexOf('.html') > -1) {
        cleanURL = url.replace('.html', '.' + target + '.html');
      } else {
        if (window.location.href.indexOf('.html') > -1) {
          cleanURL = url + '.' + target + '.html';
        } else {
          cleanURL = url + '.' + target;
        }
      }
    } else {
      if ($('body').hasClass('photoLibraryViewerPage')) {
        cleanURL = relativeCqBasePage;
      } else {
        if (relativeCqBasePage.indexOf('.html') > -1) {
          cleanURL = relativeCqBasePage.replace('.html', '.' + target + '.html');
        } else {
          if (window.location.href.indexOf('.html') > -1) {
            cleanURL = relativeCqBasePage + '.' + target + '.html';
          } else {
            cleanURL = relativeCqBasePage + '.' + target;
          }
        }
      }
      cleanURL = url.replace(relativeCqBasePage, cleanURL);
    }

    return cleanURL;
  }

  function areaContentError(data) {
    application.broadcast('ajax.areaContentError', data);
    window.location = data.href;
    debug.warn('Error with the ajax on: ', data.target);
  }

  function areaContentLoaded(data) {
    if (data.content) {
      insertAreaContentIntoDOM(data);
      application.broadcast('ajax.areaContentLoaded', data);
    } else {
      debug.warn('Error. Ajax came through but no data for: ', data.target);
    }
  }

  function insertAreaContentIntoDOM(data) {
    var $target = void 0,
        content = void 0,
        $context = void 0,
        targetType = void 0;

    content = $('<div>').html(data.content);
    content = $(content).find('[data-sni-area=' + data.target + ']').html();
    $target = $(document).find('[data-sni-area=' + data.target + ']');
    targetType = $target.attr('data-sni-area-type') || 'replace';
    $target.removeClass('loading').addClass('loaded');

    if (!data.suppressLoadAnim) {
      $target.find('[data-ui-loader]').remove();
    }

    if (targetType === 'append') {
      $context = $target.append(content);
    } else {
      $context = $target.html(content);
      updateMetrics(data.content, data.target);
    }

    initializeModules($context);
  }

  function getShoppingMetadata(data) {
    var shoppingMetadata = {},
        firstSlideMetadata = void 0;

    if (data) {
      firstSlideMetadata = (typeof data === 'undefined' ? 'undefined' : helpers_typeof_default()(data)) === 'object' ? data : JSON.parse(data);

      shoppingMetadata = {
        shopping: firstSlideMetadata.shopping,
        products: firstSlideMetadata.products,
        partner: firstSlideMetadata.partner
      };
    }
    return shoppingMetadata;
  }

  function updateMetrics(content, target) {
    var $sanitizedContent = $('<div>').html(content),
        mdmData = $($sanitizedContent).find('[data-sni-area=' + target + ']').data('mdm') || false,
        mdmObj = JSON.parse(mdmData),
        $firstSlide = $($sanitizedContent).find('.pv-slide').first(),
        isShopThisLook = $firstSlide.data('productEnabled'),
        partnerTag = 'partner;wayfair/shop_this_look',
        taggroup = void 0,
        behavioralInteraction = void 0,
        updatedUID = void 0,
        shoppingMetadata = void 0;

    mdmData = JSON.parse(mdmData.trim());

    if (isShopThisLook) {
      taggroup = mdmData.TagGroup1 ? mdmData.TagGroup1 : mdmData.Overlay_TagGroup1;

      if (typeof taggroup !== 'undefined' && taggroup.indexOf(partnerTag) === -1) {
        taggroup = partnerTag + ',' + taggroup;
        mdmData.TagGroup1 = taggroup;
        mdmData.Overlay_TagGroup1 = '';
      } else {
        debug.warn('updateMetrics: STL might not be tracked, taggroup is undefined or index of partnerTag is not -1, here is the MDM object: ', mdmData);
      }
    }

    updatedUID = metadata.updateConsecutiveViewCount(mdmObj);
    behavioralInteraction = metadata.getMediaStreamNumber(mdmData, 1, 1);

    if (mdmData) {
      shoppingMetadata = getShoppingMetadata($firstSlide.data('mdm'));
      mdmData = Object.assign({}, mdmData, shoppingMetadata);
      metadata.updateFromString(mdmData);
      if (updatedUID) {
        metadata.updateFromString({ Overlay_UniqueId: updatedUID });
      }
      if (behavioralInteraction) {
        metadata.updateFromString({ behavioralInteraction: behavioralInteraction });
      }
    } else {
      debug.error('updateMetrics: Hijax MDM data missing');
    }

    if ($('body').hasClass('photoGalleryPage')) {
      var ogDesc = $($sanitizedContent).find('[data-sni-area=' + target + ']').data('ogdesc') || false,
          ogTitle = $($sanitizedContent).find('[data-sni-area=' + target + ']').data('ogtitle') || false,
          ogUrl = $($sanitizedContent).find('[data-sni-area=' + target + ']').data('ogurl') || false,
          ogImg = $($sanitizedContent).find('[data-sni-area=' + target + ']').data('ogimg') || false;

      if (ogDesc) {
        $('meta[property="og:description"]').attr('content', ogDesc);
      }
      if (ogTitle) {
        $('meta[property="og:title"]').attr('content', ogTitle);
      }
      if (ogUrl) {
        $('meta[property="og:url"]').attr('content', ogUrl);
      }
      if (ogImg) {
        $('meta[property="og:image"]').attr('content', ogImg);
      }
    }

    analytics.callDynamicPageview();
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  service = {
    initializeModules: initializeModules,
    loadAreaContent: loadAreaContent,
    cleanURLForCQ: cleanURLForCQ,
    areaContentError: areaContentError,
    areaContentLoaded: areaContentLoaded,
    insertAreaContentIntoDOM: insertAreaContentIntoDOM,
    updateMetrics: updateMetrics
  };

  return service;
});
// EXTERNAL MODULE: ./src/app/services/common-handlers.js
var common_handlers = __webpack_require__(425);
var common_handlers_default = /*#__PURE__*/__webpack_require__.n(common_handlers);

// EXTERNAL MODULE: ./src/app/services/cookie.js
var cookie = __webpack_require__(426);
var cookie_default = /*#__PURE__*/__webpack_require__.n(cookie);

// EXTERNAL MODULE: ./src/app/services/debug.js
var services_debug = __webpack_require__(427);
var services_debug_default = /*#__PURE__*/__webpack_require__.n(services_debug);

// EXTERNAL MODULE: ./src/app/services/dependency-loader.js
var dependency_loader = __webpack_require__(428);
var dependency_loader_default = /*#__PURE__*/__webpack_require__.n(dependency_loader);

// EXTERNAL MODULE: ./src/app/services/gigya/comments.js
var gigya_comments = __webpack_require__(429);
var gigya_comments_default = /*#__PURE__*/__webpack_require__.n(gigya_comments);

// EXTERNAL MODULE: ./src/app/services/gigya/getBrand.js
var getBrand = __webpack_require__(430);
var getBrand_default = /*#__PURE__*/__webpack_require__.n(getBrand);

// EXTERNAL MODULE: ./src/app/services/gigya/getSession.js
var getSession = __webpack_require__(431);
var getSession_default = /*#__PURE__*/__webpack_require__.n(getSession);

// EXTERNAL MODULE: ./src/app/services/gigya/gigya.js
var gigya = __webpack_require__(432);
var gigya_default = /*#__PURE__*/__webpack_require__.n(gigya);

// EXTERNAL MODULE: ./src/app/services/gigya/moderation.js
var moderation = __webpack_require__(433);
var moderation_default = /*#__PURE__*/__webpack_require__.n(moderation);

// EXTERNAL MODULE: ./src/app/services/gigya/socialUpload.js
var socialUpload = __webpack_require__(434);
var socialUpload_default = /*#__PURE__*/__webpack_require__.n(socialUpload);

// EXTERNAL MODULE: ./src/app/services/gigya/templates.js
var templates = __webpack_require__(435);
var templates_default = /*#__PURE__*/__webpack_require__.n(templates);

// EXTERNAL MODULE: ./src/app/services/gigya/tracking.js
var tracking = __webpack_require__(436);
var tracking_default = /*#__PURE__*/__webpack_require__.n(tracking);

// EXTERNAL MODULE: ./src/app/services/hotspot.js
var services_hotspot = __webpack_require__(437);
var services_hotspot_default = /*#__PURE__*/__webpack_require__.n(services_hotspot);

// CONCATENATED MODULE: ./src/app/services/internationalDialog.js

SNI.Application.addService('internationalDialog', function (application) {
  // (author: Brandon Foster, date: 2016-12-08).

  var util = application.getService('utility');
  var cookieService = application.getService('cookie');
  var debug = application.getService('logger').create('service.internationalDialog');
  var check = application.getService('check').new(debug);
  var modal = application.getService('modal');
  var template = application.getService('template');
  var cookieName = 'supressInternationalModal';
  var modalId = 'internationalModal'; // this ID ends up on the .o-Modal div tag, used for styling.
  var dismissModalAttr = 'international-modal';
  var modalImageClass = 'o-InternationalDialog__a-BannerImage';
  var modalContentClass = 'o-Modal__m-Content';
  var dialogClass = 'o-InternationalDialog';

  // the AJAX success function: used once data has been returned to create the modal
  function initModal(receivedData) {
    var data;

    try {
      // expecting receivedData to URL like /content/internationalModal/food.html be JSON object with the data we need.
      if (typeof receivedData === 'string') {
        data = JSON.parse(receivedData);
        data.dismissModalAttr = dismissModalAttr;
      } else if ((typeof receivedData === 'undefined' ? 'undefined' : helpers_typeof_default()(receivedData)) === 'object') {
        data = receivedData; // we can also receive data from other sources that don't use the AJAX request and create their own JSON data for the modal.
      } else {
        debug.error('Not sure what to do with this data: ', receivedData);
        return false; // bailing on the function since we can't make a modal without the data!
      }
    } catch (error) {
      debug.error('Failed to parse HTTP Response into JSON. receivedData: ', receivedData);
      return false; // bailing on the function since we can't make a modal without the data!
    }

    if (!data.title) {
      debug.warn('Title is not received over the data, so the country code may not be registered with a region.');
      return false; // no title is suspect, so we want to suppress the modal because the data probably isn't populated.
    }

    // We pass HTML to the modal service, which it then drops into the body of the modal.
    //  This allows us to use the default modal service (and not have to implement our own)
    //  and still achieve the custom functionality and content we want.
    modal.open(modalId, {
      header: {
        title: data.title,
        subtitle: data.description
      },
      body: {
        html: template.internationalModalBody(data)
      }
    }, false, {
      backdrop: 'static',
      keyboard: false,
      show: true
    });

    // The user needs to be able to close the modal with the Dismissal CTA (the a-Button--Text)
    //  which, for example, says something like "Continue to Foodnetwork.com"
    $('[data-dismiss="' + dismissModalAttr + '"]').on('click', function () {
      modal.close(modalId);
    });

    // create cookie to suppress future modals
    cookieService.set(cookieName, true, 30, false, true); // cookie lasts for 30 days and is domain specific but not path specific.

    //move the bannerImage and logo to the top of the international modal, add the dialog class to the modal
    $('.o-InternationalDialog__a-Logo').prependTo('#' + modalId + ' .' + modalContentClass);
    $('.' + modalImageClass).prependTo('#' + modalId + ' .' + modalContentClass);
    $('#' + modalId).addClass(dialogClass);
  }

  return {
    // named "modal" because internationalDialog may include other methods for creating different kinds of
    // international redirects that we don't know about currently. Modal, then, is just one possible instance of the International Dialog.
    modal: function modal(overrideData) {
      // parameter allows passing your own JSON object in, without having to use the AJAX request.

      var countryCode = sessionStorage.getItem('countryCode'),
          suppressInternationalModal = cookieService.get(cookieName),
          countryCodeQueryParam = util.getUrlParam(window.location.href, 'countryCode').toString(),
          modalDataPath = '/content/internationalModal/';

      // offer a way to override the country code for testing
      if (typeof countryCodeQueryParam !== 'undefined' && countryCodeQueryParam !== '') {
        // This allows for easy testing when Akamai's geolocation services aren't available, e.g. on author or publish nodes.
        countryCode = countryCodeQueryParam;
      }

      // if the cookie exists, the modal has already been seen - don't init the modal
      if (suppressInternationalModal && !util.getUrlParam(window.location.href, 'ignoreModalCookie')) {
        // you can bypass this suppression with a query param, for testing purposes
        debug.log('International Modal suppressed by cookie.');
        return false;
      } else if (typeof countryCode === 'undefined' || countryCode === '$(GEO{\'country_code\'})' || countryCode === '' || countryCode === 'null') {
        debug.warn('Country Code is missing, suppressing International Modal.');
        return false;
      } else if (countryCode === 'US') {
        // if the country code is the US, the user is already at the correct website - no need for a modal to direct them to a native site.
        debug.log('Country Code is US, suppressing International Modal.');
        return false;
      } else if (!check.exists('SNI.Config.brand')) {
        // Just in case the global isn't defined...
        debug.warn('SNI.Config.brand was undefined, can\'t make a request to get the modal data, so the modal will not initialize.');
        return false;
      } else if (typeof overrideData !== 'undefined') {
        // assuming a JSON object was passed in to be used instead of the AJAX request.
        initModal(overrideData);
        return true; // necessary to let unit test know the modal was created.
      } else {
        // otherwise, we are good to move forward with creating the modal
        // First we make an AJAX call to a node, e.g. for FoodNetwork.com /content/internationalModal/food.html is requested.
        // The country code is passed as a query parameter.
        $.ajax({
          type: 'GET',
          url: modalDataPath + SNI.Config.brand + '.' + countryCode + '.html', // pass country code as an path selector so that Java Model can pull it out of the Request and return the proper region's data. For more on Selectors, see: https://sling.apache.org/apidocs/sling7/org/apache/sling/api/request/RequestPathInfo.html
          success: initModal,
          error: function error(xhr, textStatus, errorThrown) {
            debug.warn('AJAX request error:', '\nXHR: ', xhr, '\nText Status: ', textStatus, '\nError Thrown:', errorThrown, '\n', 'The request may have failed because the international Modal data for ' + SNI.Config.brand + ' may be missing.\n', 'Check ' + modalDataPath + SNI.Config.brand + ' in CRX and see that the sling:resourceType is set to the correct value, and that there are region nodes under the brand node that have the correct properties.');
          }
        });
        return true; // necessary to let unit test know the modal was created.
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/services/media-stream.js
var services_media_stream = __webpack_require__(438);
var services_media_stream_default = /*#__PURE__*/__webpack_require__.n(services_media_stream);

// CONCATENATED MODULE: ./src/app/services/metadata.js






/**
  * Metadata
  * Author: jpencola
  * A utility object for working with metadata. First use-case is
  * dealing with updates to the existing MDManager global that Scripps
  * exposes. It is assumed/expected that the MdManager object has already
  * been instantiated and is exposed on the window.
  * -------------------------------------------------------------
  */

SNI.Application.addService('metadata', function (application) {
  'use strict';

  var debug = application.getService('logger').create('service.metadata'),
      device = application.getService('device-type'),
      check = application.getService('check').new(debug);

  var galleryData = void 0;

  return {
    setGalleryData: function setGalleryData(data) {
      galleryData = data;
    },
    getGalleryData: function getGalleryData() {
      if (typeof galleryData !== 'undefined') {
        return galleryData;
      } else {
        return false;
      }
    },


    /**
     * Accepts a valid JSON object and maps the
     * key:value pairs into the mdManager.
     * setParameter() overwrites by default.
    */
    updateFromJSON: function updateFromJSON(json) {

      //debug.log('updateFromJSON() called');

      if (!check.exists('mdManager')) {
        debug.warn('updateFromJSON() mdManager doesn\'t exist');
        return;
      }

      if (typeof json === 'undefined') {
        debug.error('ERROR, No JSON!');
        return;
      }

      //debug.log('updateFromJSON(): Setting mdManager params', json);

      $.each(json, function (key, val) {
        application.getGlobal('mdManager').setParameter(key, val);
      });
    },


    /**
     * Accepts a string, parses and updates mdManager
     */
    updateFromString: function updateFromString(string) {

      var mdmJSON = '';

      //debug.log('updateFromString: string: ', string);

      if (typeof string === 'undefined') {
        debug.error('ERROR, No String!');
        return;
      }

      if ((typeof string === 'undefined' ? 'undefined' : helpers_typeof_default()(string)) === 'object') {
        mdmJSON = string;
      } else {
        mdmJSON = JSON.parse(string);
      }

      try {
        this.updateFromJSON(mdmJSON);
      } catch (e) {
        debug.error('invalid mdM json string');
        return false;
      }
    },


    /**
     * Accepts a mdmData object.
     * Returns a string if required properties exist in mData, else returns false.
     */
    updateConsecutiveViewCount: function updateConsecutiveViewCount(mData) {
      var meeData = JSON.parse(JSON.stringify(mData));
      var isInline = $('.container-site').hasClass('inline-horizontal') && !device.isMobile || $('body').hasClass('photoLibraryViewerPage'),

      // check to see if we're dealing with an inline gallery. This is an ugly way of checking - would be nice to have a centralized, agreed-upon way to check for this that isn't so fragile.
      pageNumber = void 0,
          uniqueId = void 0; // variable to handle inline vs overlay options

      if (meeData && galleryData) {
        if (meeData.PageNumber && (meeData.Overlay_UniqueId || meeData.UniqueID) && galleryData.consecutiveGallery && typeof galleryData.originalGallery !== 'undefined') {
          // if desktop inline or viewer, use uniqueId. otherwise use overlay_uniqueId
          if (isInline) {
            if (typeof meeData.UniqueId !== 'undefined') {
              // metadata's UniqueId exists
              uniqueId = meeData.UniqueId;
            } else if (typeof meeData.UniqueID !== 'undefined') {
              // Perhaps UniqueID exists?
              uniqueId = meeData.UniqueID;
            } else if (typeof meeData.Overlay_UniqueId !== 'undefined') {
              // hmm, no inline ID? fall back to Overlay_UniqueId
              uniqueId = meeData.Overlay_UniqueId;
            } else if (typeof meeData.Overlay_UniqueID !== 'undefined') {
              // try ID instead of Id
              uniqueId = meeData.Overlay_UniqueID;
            } else {
              debug.error('Inline gallery recognized, but no UniqueId, UniqueID, Overlay_UniqueId, or Overlay_UniqueID are found!');
            }
          } else {
            // assume Overlay if not inline
            if (typeof meeData.Overlay_UniqueId !== 'undefined') {
              // Try Overlay_UniqueId first
              uniqueId = meeData.Overlay_UniqueId;
            } else if (typeof meeData.Overlay_UniqueID !== 'undefined') {
              // Try ID instead of Id
              uniqueId = meeData.Overlay_UniqueID;
            } else if (typeof meeData.UniqueId !== 'undefined') {
              // No overlay UniqueId? Try just regular UniqueId!
              uniqueId = meeData.UniqueId;
            } else if (typeof meeData.UniqueID !== 'undefined') {
              // Try ID instead of Id
              uniqueId = meeData.UniqueID;
            } else {
              debug.error('Overlay gallery recognized, but no UniqueId, UniqueID, Overlay_UniqueId, or Overlay_UniqueID are found!');
            }
          }
          pageNumber = meeData.PageNumber;
          return uniqueId.replace(/^(.+\|)([0-9\-])+$/m, '$1' + pageNumber);
        }
      } else {
        return false;
      }
    },
    // end of updateConsecutiveViewCount function
    /**
     * Accepts a mdmData object and an offset.
     * Returns a string of galleryNumber-slideNumber-totalSlideNumber
     */
    getMediaStreamNumber: function getMediaStreamNumber(mData, offset, consec) {
      if (galleryData) {
        var originalGallery = galleryData.originalGallery,
            iterate = consec || 0,
            consecutiveGallery = galleryData.consecutiveGallery,
            pageNumber = typeof mData !== 'undefined' && JSON.parse(JSON.stringify(mData)).PageNumber ? JSON.parse(JSON.stringify(mData)).PageNumber : 1;

        if (typeof galleryData.consecutiveGallery !== 'undefined') {
          galleryData.consecutiveGallery = consecutiveGallery + iterate;
        }

        if (typeof galleryData.originalGallery !== 'undefined') {
          galleryData.originalGallery = originalGallery + iterate;
        }

        if (typeof consecutiveGallery !== 'undefined' && typeof originalGallery !== 'undefined' && typeof pageNumber !== 'undefined') {
          return consecutiveGallery + iterate + '-' + pageNumber + '-' + (originalGallery + offset + iterate);
        } else {
          debug.error('getMediaStreamNumber(): failed to form media stream number for metdata\'s behavioralInteraction.\n' + ' consecutiveGallery: ' + consecutiveGallery + ', originalGallery: ' + originalGallery + ', pageNumber: ' + pageNumber);
          return false;
        }
      }
    }
  };
});
// EXTERNAL MODULE: ./src/app/services/modal.js
var services_modal = __webpack_require__(439);
var services_modal_default = /*#__PURE__*/__webpack_require__.n(services_modal);

// EXTERNAL MODULE: ./src/app/services/model.js
var model = __webpack_require__(440);
var model_default = /*#__PURE__*/__webpack_require__.n(model);

// EXTERNAL MODULE: ./src/app/services/module-loader.js
var module_loader = __webpack_require__(441);
var module_loader_default = /*#__PURE__*/__webpack_require__.n(module_loader);

// EXTERNAL MODULE: ./src/app/services/newsletter-subscribe.js
var newsletter_subscribe = __webpack_require__(442);
var newsletter_subscribe_default = /*#__PURE__*/__webpack_require__.n(newsletter_subscribe);

// EXTERNAL MODULE: ./src/app/services/product-hotspots.js
var product_hotspots = __webpack_require__(443);
var product_hotspots_default = /*#__PURE__*/__webpack_require__.n(product_hotspots);

// EXTERNAL MODULE: ./src/app/services/product-manager.js
var product_manager = __webpack_require__(444);
var product_manager_default = /*#__PURE__*/__webpack_require__.n(product_manager);

// EXTERNAL MODULE: ./src/app/services/remove-inline-styles.js
var services_remove_inline_styles = __webpack_require__(445);
var services_remove_inline_styles_default = /*#__PURE__*/__webpack_require__.n(services_remove_inline_styles);

// EXTERNAL MODULE: ./src/app/services/router.js
var services_router = __webpack_require__(446);
var services_router_default = /*#__PURE__*/__webpack_require__.n(services_router);

// EXTERNAL MODULE: ./src/app/services/schedule.js
var schedule = __webpack_require__(447);
var schedule_default = /*#__PURE__*/__webpack_require__.n(schedule);

// EXTERNAL MODULE: ./src/app/services/scroll-tracker.js
var scroll_tracker = __webpack_require__(448);
var scroll_tracker_default = /*#__PURE__*/__webpack_require__.n(scroll_tracker);

// EXTERNAL MODULE: ./src/app/services/social/sharebar.js
var sharebar = __webpack_require__(449);
var sharebar_default = /*#__PURE__*/__webpack_require__.n(sharebar);

// CONCATENATED MODULE: ./src/app/services/state.js

SNI.Application.addService('state', function (application) {

  var state = {};

  var triggerWatchers = function triggerWatchers(store, key, newValue) {
    var config = store.__config;
    var oldValue = config.data[key];
    // Only update value if it wasn't the same as the previous value
    if (newValue !== oldValue) {
      config.data[key] = newValue;
      if (config.watch && config.watch[key]) {
        config.watch[key](newValue);
      }
      if (config.watchAll) {
        config.watchAll(key, newValue);
      }
    }
  };

  var configureData = function configureData(store, _ref) {
    var _ref$data = _ref.data,
        data = _ref$data === undefined ? {} : _ref$data;

    Object.keys(data).forEach(function (key) {
      if (store.hasOwnProperty(key)) {
        store[key] = data[key];
      } else {
        store.__config.data[key] = data[key];
        Object.defineProperty(store, key, {
          get: function get() {
            return store.__config.data[key];
          },
          set: function set(val) {
            triggerWatchers(store, key, val);
          },

          enumberable: true,
          configurable: true
        });
      }
    });
  };

  var configureWatchers = function configureWatchers(store, _ref2) {
    var _ref2$watch = _ref2.watch,
        watch = _ref2$watch === undefined ? {} : _ref2$watch,
        watchAll = _ref2.watchAll;

    Object.assign(store.__config, { watch: watch, watchAll: watchAll });
  };

  var configureMethods = function configureMethods(store, _ref3) {
    var _ref3$methods = _ref3.methods,
        methods = _ref3$methods === undefined ? {} : _ref3$methods;

    Object.assign(store.__config, { methods: methods });
    Object.assign(store, methods);
  };

  var configureComputed = function configureComputed(store, _ref4) {
    var _ref4$computed = _ref4.computed,
        computed = _ref4$computed === undefined ? {} : _ref4$computed;

    Object.assign(store.__config, { computed: computed });
    Object.keys(computed).forEach(function (key) {
      if (!store.hasOwnProperty(key)) {
        Object.defineProperty(store, key, {
          get: computed[key]
        });
      }
    });
  };

  var observe = function observe(store, storeConfig) {

    configureData(store, storeConfig);
    configureWatchers(store, storeConfig);
    configureMethods(store, storeConfig);
    configureComputed(store, storeConfig);
  };

  return {
    getStateTree: function getStateTree() {
      return state;
    },
    createStore: function createStore(id, storeConfig) {
      if ((typeof id === 'undefined' ? 'undefined' : helpers_typeof_default()(id)) === 'object' || storeConfig === undefined) {
        throw new Error('create should be given an id, only passed in a config');
      }
      storeConfig.data = storeConfig.data || {};

      var store = {
        data: {},
        watch: {},
        watchAll: {},
        methods: {}
      };

      Object.defineProperty(store, '__id', {
        value: id,
        enumberable: false,
        writable: false,
        configurable: false
      });

      Object.defineProperty(store, '__config', {
        value: storeConfig,
        enumberable: false,
        writable: false,
        configurable: true
      });

      observe(store, storeConfig);

      state[id] = store;
      return store;
    },


    updateStore: observe

  };
});
// EXTERNAL MODULE: ./src/app/services/stream-manager.js
var stream_manager = __webpack_require__(450);
var stream_manager_default = /*#__PURE__*/__webpack_require__.n(stream_manager);

// EXTERNAL MODULE: ./src/app/services/track-shopping.js
var services_track_shopping = __webpack_require__(451);
var services_track_shopping_default = /*#__PURE__*/__webpack_require__.n(services_track_shopping);

// CONCATENATED MODULE: ./src/app/services/video.js

SNI.Application.addService('video', function (application) {

  var debug = application.getService('logger').create('service.video');
  var nextVideo = 0;

  return {
    setNext: function setNext(videoNumber) {
      nextVideo = parseInt(videoNumber);
      debug.log('videoNumber: ', videoNumber, 'type: ', typeof nextVideo === 'undefined' ? 'undefined' : helpers_typeof_default()(nextVideo));
    },
    getNext: function getNext(player) {
      return nextVideo;
    }
  };
});
// CONCATENATED MODULE: ./src/app/services/index.js
/** AUTO GENERATED FILE, DO NOT EDIT **/















































// CONCATENATED MODULE: ./src/app/init.js






























































































var init_util = SNI.Application.getService('utility');
var init_debug = init_util.isDebug();

var eventTypes = ['click', 'mouseover', 'mouseout', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'keydown', 'keyup', 'submit', 'change', 'contextmenu', 'dblclick', 'input', 'focusin', 'focusout', 'touchstart', 'touch'];

SNI.Application.setErrorHandler(function errorHandler(exception) {
  if (init_debug) {
    console.error(exception); // eslint-disable-line
  } else {
    SNI.Application.fire('error', {
      exception: exception
    });
  }
});

$(function () {
  return SNI.Application.init({ debug: init_debug, eventTypes: eventTypes });
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $typed = __webpack_require__(57);
var buffer = __webpack_require__(71);
var anObject = __webpack_require__(2);
var toAbsoluteIndex = __webpack_require__(39);
var toLength = __webpack_require__(7);
var isObject = __webpack_require__(3);
var ArrayBuffer = __webpack_require__(1).ArrayBuffer;
var speciesConstructor = __webpack_require__(78);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(5)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(58)(ARRAY_BUFFER);


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(57).ABV, {
  DataView: __webpack_require__(71).DataView
});


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(2);
var getKeys = __webpack_require__(42);

module.exports = __webpack_require__(10) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(161);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var isArray = __webpack_require__(109);
var SPECIES = __webpack_require__(4)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(49);
var descriptor = __webpack_require__(25);
var setToStringTag = __webpack_require__(40);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(13)(IteratorPrototype, __webpack_require__(4)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(113);
var validate = __webpack_require__(44);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(61)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var setPrototypeOf = __webpack_require__(83).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(113);
var validate = __webpack_require__(44);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(61)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(51)(0);
var redefine = __webpack_require__(19);
var meta = __webpack_require__(53);
var assign = __webpack_require__(115);
var weak = __webpack_require__(116);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(5);
var validate = __webpack_require__(44);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(61)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(116);
var validate = __webpack_require__(44);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(61)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(27);
var anObject = __webpack_require__(2);
var rApply = (__webpack_require__(1).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(5)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(49);
var aFunction = __webpack_require__(27);
var anObject = __webpack_require__(2);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(5);
var bind = __webpack_require__(178);
var rConstruct = (__webpack_require__(1).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(27);
var isObject = __webpack_require__(3);
var invoke = __webpack_require__(117);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(6);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(2);
var toPrimitive = __webpack_require__(47);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(5)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(20).f;
var anObject = __webpack_require__(2);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(20);
var getPrototypeOf = __webpack_require__(50);
var has = __webpack_require__(11);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(2);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(20);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(2);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(50);
var anObject = __webpack_require__(2);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(2);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(118) });


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(2);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(6);
var gOPD = __webpack_require__(20);
var getPrototypeOf = __webpack_require__(50);
var has = __webpack_require__(11);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(25);
var anObject = __webpack_require__(2);
var isObject = __webpack_require__(3);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(83);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(35);
var global = __webpack_require__(1);
var ctx = __webpack_require__(15);
var classof = __webpack_require__(79);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(3);
var aFunction = __webpack_require__(27);
var anInstance = __webpack_require__(37);
var forOf = __webpack_require__(60);
var speciesConstructor = __webpack_require__(78);
var task = __webpack_require__(84).set;
var microtask = __webpack_require__(191)();
var newPromiseCapabilityModule = __webpack_require__(119);
var perform = __webpack_require__(192);
var promiseResolve = __webpack_require__(193);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(4)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(36)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(40)($Promise, PROMISE);
__webpack_require__(58)(PROMISE);
Wrapper = __webpack_require__(46)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(59)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var macrotask = __webpack_require__(84).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(38)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(2);
var isObject = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(119);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(1);
var has = __webpack_require__(11);
var DESCRIPTORS = __webpack_require__(10);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(19);
var META = __webpack_require__(53).KEY;
var $fails = __webpack_require__(5);
var shared = __webpack_require__(75);
var setToStringTag = __webpack_require__(40);
var uid = __webpack_require__(26);
var wks = __webpack_require__(4);
var wksExt = __webpack_require__(120);
var wksDefine = __webpack_require__(195);
var enumKeys = __webpack_require__(196);
var isArray = __webpack_require__(109);
var anObject = __webpack_require__(2);
var isObject = __webpack_require__(3);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(47);
var createDesc = __webpack_require__(25);
var _create = __webpack_require__(49);
var gOPNExt = __webpack_require__(197);
var $GOPD = __webpack_require__(20);
var $DP = __webpack_require__(6);
var $keys = __webpack_require__(42);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(48).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(52).f = $propertyIsEnumerable;
  __webpack_require__(62).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(35)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(1);
var core = __webpack_require__(46);
var LIBRARY = __webpack_require__(35);
var wksExt = __webpack_require__(120);
var defineProperty = __webpack_require__(6).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(42);
var gOPS = __webpack_require__(62);
var pIE = __webpack_require__(52);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(16);
var gOPN = __webpack_require__(48).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(115) });


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(200) });


/***/ }),
/* 200 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(83).set });


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(10) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(16);
var toLength = __webpack_require__(7);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(39);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(206)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(28);
var defined = __webpack_require__(29);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(121)
});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(7);
var context = __webpack_require__(85);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(86)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(7);
var context = __webpack_require__(85);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(86)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(85);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(86)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(10) && /./g.flags != 'g') __webpack_require__(6).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(212)
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(2);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(63)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(63)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(63)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(122);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(63)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(15);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(30);
var call = __webpack_require__(114);
var isArrayIter = __webpack_require__(80);
var toLength = __webpack_require__(7);
var createProperty = __webpack_require__(87);
var getIterFn = __webpack_require__(81);

$export($export.S + $export.F * !__webpack_require__(59)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var createProperty = __webpack_require__(87);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(5)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(112) });

__webpack_require__(43)('copyWithin');


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(51)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(43)(KEY);


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(51)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(43)(KEY);


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(77) });

__webpack_require__(43)('fill');


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(1).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(123) });


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(123);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(124);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(88);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(89);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(238) });


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(88);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(5)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(124) });


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(88) });


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(89);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(5)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(89);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(73)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(43)('includes');


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(125)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(125)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(118);
var toIObject = __webpack_require__(16);
var gOPD = __webpack_require__(20);
var createProperty = __webpack_require__(87);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(126);
var userAgent = __webpack_require__(90);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(126);
var userAgent = __webpack_require__(90);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(1);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(90);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(84);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(82);
var getKeys = __webpack_require__(42);
var redefine = __webpack_require__(19);
var global = __webpack_require__(1);
var hide = __webpack_require__(13);
var Iterators = __webpack_require__(41);
var wks = __webpack_require__(4);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(127)))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This file uses a special webpack variable to dynamically set webpack's public
 * path at run time. The reason this is necessary is because our resources
 * currently serve from two paths:
 * 
 * http://food.fnr.sndimg.com
 * http://hgtvhome.sndimg.com
 * 
 * The SNI.JS_RESOURCE_PATH variable is defined on the page with with
 * the correct domain and public path which webpack uses for any
 * dynamic requests it issues. Go here for more info about public
 * paths in webpack:
 * 
 * https://webpack.js.org/configuration/output/#output-publicpath
 */

__webpack_require__.p = SNI.JS_RESOURCE_PATH; // eslint-disable-line

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//this file is required by vendor/tooltip.js

/* ========================================================================
 * Bootstrap: transition.js v3.1.1
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


// wrapping with an AMD module definition if AMD modules are in use, otherwise, just exposing global
(function (factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(91)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      'WebkitTransition' : 'webkitTransitionEnd',
      'MozTransition'    : 'transitionend',
      'OTransition'      : 'oTransitionEnd otransitionend',
      'transition'       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this
    $(this).one($.support.transition.end, function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()
  })

// end of AMD module wrap
}));


/***/ }),
/* 260 */
/***/ (function(module, exports) {

(function() {

  'use strict';

    var Tooltip = function (element, options) {
      this.type       =
      this.options    =
      this.enabled    =
      this.timeout    =
      this.hoverState =
      this.$element   = null

      this.init('tooltip', element, options)
    }

    Tooltip.DEFAULTS = {
      animation: false,
      placement: 'top',
      selector: false,
      template: '<div class="tooltip"><div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: false,
      container: false
    }

    Tooltip.prototype.init = function (type, element, options) {
      this.enabled  = true
      this.type     = type
      this.$element = $(element)
      this.options  = this.getOptions(options)

      var triggers = this.options.trigger.split(' ')

      for (var i = triggers.length; i--;) {
        var trigger = triggers[i]

        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
          var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

          this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

    Tooltip.prototype.getDefaults = function () {
      return Tooltip.DEFAULTS
    }

    Tooltip.prototype.getOptions = function (options) {
      options = $.extend({}, this.getDefaults(), this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay,
          hide: options.delay
        }
      }

      return options
    }

    Tooltip.prototype.getDelegateOptions = function () {
      var options  = {}
      var defaults = this.getDefaults()

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      })

      return options
    }

    Tooltip.prototype.enter = function (obj) {
      var self = obj instanceof this.constructor ?
        obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

      clearTimeout(self.timeout)

      self.hoverState = 'in'

      if (!self.options.delay || !self.options.delay.show) return self.show()

      self.timeout = setTimeout(function () {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

    Tooltip.prototype.leave = function (obj) {
      var self = obj instanceof this.constructor ?
        obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

      clearTimeout(self.timeout)

      self.hoverState = 'out'

      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.timeout = setTimeout(function () {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

    Tooltip.prototype.show = function () {
      var e = $.Event('show.bs.' + this.type)

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)

        if (e.isDefaultPrevented()) return
        var that = this;

        var $tip = this.tip()

        this.setContent()

        if (this.options.animation) $tip.addClass('fade')

        var placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        var autoToken = /\s?auto?\s?/i
        var autoPlace = autoToken.test(placement)
        if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })
          .addClass(placement)

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        var pos          = this.getPosition()
        var actualWidth  = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight

        if (autoPlace) {
          var $parent = this.$element.parent()

          var orgPlacement = placement
          var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
          var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
          var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
          var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

          placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
                      placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
                      placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
                      placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
                      placement

          $tip
            .removeClass(orgPlacement)
            .addClass(placement)
        }

        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

        this.applyPlacement(calculatedOffset, placement)
        this.hoverState = null

        var complete = function() {
          that.$element.trigger('shown.bs.' + that.type)
        }

        $.support.transition && this.$tip.hasClass('fade') ?
          $tip
            .one($.support.transition.end, complete)
            .emulateTransitionEnd(150) :
          complete()
      }
    }

    Tooltip.prototype.applyPlacement = function (offset, placement) {
      var replace
      var $tip   = this.tip()
      var width  = $tip[0].offsetWidth
      var height = $tip[0].offsetHeight

      // manually read margins because getBoundingClientRect includes difference
      var marginTop = parseInt($tip.css('margin-top'), 10)
      var marginLeft = parseInt($tip.css('margin-left'), 10)

      // we must check for NaN for ie 8/9
      if (isNaN(marginTop))  marginTop  = 0
      if (isNaN(marginLeft)) marginLeft = 0

      offset.top  = offset.top  + marginTop
      offset.left = offset.left + marginLeft

      // $.fn.offset doesn't round pixel values
      // so we use setOffset directly with our own function B-0
      $.offset.setOffset($tip[0], $.extend({
        using: function (props) {
          $tip.css({
            top: Math.round(props.top),
            left: Math.round(props.left)
          })
        }
      }, offset), 0)

      $tip.addClass('in')

      // check to see if placing tip in new offset caused the tip to resize itself
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        replace = true
        offset.top = offset.top + height - actualHeight
      }

      if (/bottom|top/.test(placement)) {
        var delta = 0

        if (offset.left < 0) {
          delta       = offset.left * -2
          offset.left = 0

          $tip.offset(offset)

          actualWidth  = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

    Tooltip.prototype.replaceArrow = function (delta, dimension, position) {
      this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + '%') : '')
    }

    Tooltip.prototype.setContent = function () {
      var $tip  = this.tip()
      var title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

    Tooltip.prototype.hide = function () {
      var that = this
      var $tip = this.tip()
      var e    = $.Event('hide.bs.' + this.type)

      function complete() {
        if (that.hoverState != 'in') $tip.detach()
        that.$element.trigger('hidden.bs.' + that.type)
      }

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one($.support.transition.end, complete)
          .emulateTransitionEnd(150) :
        complete()

      this.hoverState = null

      return this
    }

    Tooltip.prototype.fixTitle = function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

    Tooltip.prototype.hasContent = function () {
      return this.getTitle()
    }

    Tooltip.prototype.getPosition = function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth,
        height: el.offsetHeight
      }, this.$element.offset())
    }

    Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
      return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
             placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
             placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
          /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
    }

    Tooltip.prototype.getTitle = function () {
      var title
      var $e = this.$element
      var o  = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

    Tooltip.prototype.tip = function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

    Tooltip.prototype.arrow = function () {
      return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
    }

    Tooltip.prototype.validate = function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options  = null
      }
    }

    Tooltip.prototype.enable = function () {
      this.enabled = true
    }

    Tooltip.prototype.disable = function () {
      this.enabled = false
    }

    Tooltip.prototype.toggleEnabled = function () {
      this.enabled = !this.enabled
    }

    Tooltip.prototype.toggle = function (e) {
      var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }

    Tooltip.prototype.destroy = function () {
      clearTimeout(this.timeout)
      this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
    }


    // TOOLTIP PLUGIN DEFINITION
    // =========================

    var old = $.fn.tooltip

    $.fn.tooltip = function (option) {
      return this.each(function () {
        var $this   = $(this)
        var data    = $this.data('bs.tooltip')
        var options = typeof option == 'object' && option

        if (!data && option == 'destroy') return
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
        if (typeof option == 'string') data[option]()
      })
    }

    $.fn.tooltip.Constructor = Tooltip


    // TOOLTIP NO CONFLICT
    // ===================

    $.fn.tooltip.noConflict = function () {
      $.fn.tooltip = old
      return this
    }

}());


/***/ }),
/* 261 */
/***/ (function(module, exports) {

+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION = '3.3.6'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip = this.tip()
    var title = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
      ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
        o.content.call($e[0]) :
        o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* "Stock" RoyalSlider has been UPDATED - it now has an additional config property - "preloaderHTML".
 *  It allows us to override the HTML for the rsPreLoader div so we can use HTML&CSS for
 *  the loading state instead of only relaying on background images
 *
 * If UPDATING royal slider please ensure that modification is preserved.
 */

// wrapping with an AMD module definition if AMD modules are in use, otherwise, just exposing global
// edits to core royal slider functionality
// 1) Added "rsAfterSizeSet" event. This is an event that is triggered after the image/slide resizes itself. RS only had "rsBeforeSizeSet".
// 2) Added "rsTryingToAdvancePastLastSlide" event. This event is used for Media Stream when the user tries to go past the last slide
// 3) Removed back and forth animation when you are first or last slide and you try to advance where you cannot

(function (royalslider) {
  if (true) {
    // AMD. Register as anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(91)], __WEBPACK_AMD_DEFINE_FACTORY__ = (royalslider),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    // Browser globals.
    royalslider(jQuery);
  }
}(function (jQuery) {

/*
 * RoyalSlider
 *
 * @version 9.5.1:
 *
 * Copyright 2011-2013, Dmitry Semenov
 *
 */
(function($) {

  "use strict";

  if(!$.rsModules) {
    $.rsModules = {uid:0};
  }

  function RoyalSlider(element, options) {
    var i,
      self = this,
      navigator = window.navigator,
      ua = navigator.userAgent.toLowerCase();

    self.uid = $.rsModules.uid++;
    self.ns = '.rs' + self.uid; // unique namespace for events

    // feature detection, some ideas taken from Modernizr
    var tempStyle = document.createElement('div').style,
      vendors = ['webkit','Moz','ms','O'],
      vendor = '',
      lastTime = 0,
      tempV;

    for (i = 0; i < vendors.length; i++ ) {
      tempV = vendors[i];
      if (!vendor && (tempV + 'Transform') in tempStyle ) {
        vendor = tempV;
      }
      tempV = tempV.toLowerCase();

      if(!window.requestAnimationFrame) {
        window.requestAnimationFrame = window[tempV+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[tempV+'CancelAnimationFrame'] || window[tempV+'CancelRequestAnimationFrame'];
      }
    }

    // requestAnimationFrame polyfill by Erik Mller
    // fixes from Paul Irish and Tino Zijdel
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
          lastTime = currTime + timeToCall;
        return id;
      };
    }

    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) { clearTimeout(id); };
    }


    self.isIPAD = ua.match(/(ipad)/);
    self.isIOS = self.isIPAD || ua.match(/(iphone|ipod)/);


    // browser UA sniffing, sadly still required
    var uaMatch = function( ua ) {
      var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
        /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
        /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
        [];

      return {
        browser: match[ 1 ] || "",
        version: match[ 2 ] || "0"
      };
    };
    var matched = uaMatch( ua );
    var br = {};
    if ( matched.browser ) {
      br[ matched.browser ] = true;
      br.version = matched.version;
    }

    if(br.chrome) {
      br.webkit = true;
    }

    self._browser = br;
    self.isAndroid = ua.indexOf("android") > -1;



    self.slider = $(element); // DOM reference
    self.ev = $(self); // event object
    self._doc = $(document);
    self.st = $.extend({}, $.fn.royalSlider.defaults, options);
    self._currAnimSpeed = self.st.transitionSpeed;
    self._minPosOffset = 0;
    if(self.st.allowCSS3) {
      if((!br.webkit || self.st.allowCSS3OnWebkit) ) {
        var bT = vendor + (vendor ? 'T' : 't' );
        self._useCSS3Transitions = ( (bT + 'ransform') in tempStyle ) && ( (bT + 'ransition') in tempStyle );
        if(self._useCSS3Transitions) {
          self._use3dTransform = (vendor + (vendor ? 'P' : 'p'  ) + 'erspective') in tempStyle;
        }
      }
    }

    vendor = vendor.toLowerCase();
    self._vendorPref = '-'+vendor+'-';

    self._slidesHorizontal = (self.st.slidesOrientation === 'vertical') ? false : true;
    self._reorderProp = self._slidesHorizontal ? 'left' : 'top';
    self._sizeProp = self._slidesHorizontal ? 'width' : 'height';
    self._prevNavItemId = -1;
    self._isMove = (self.st.transitionType === 'fade') ? false : true;
    if(!self._isMove) {
      self.st.sliderDrag = false;
      self._fadeZIndex = 10;
    }
    self._opacityCSS = 'z-index:0; display:none; opacity:0;';

    self._newSlideId = 0;
    self._sPosition = 0;
    self._nextSlidePos = 0;

    // init modules
    $.each($.rsModules, function (helper, opts) {
      if(helper !== 'uid')
        opts.call(self);
    });

    // parse all slides
    self.slides = [];
    self._idCount = 0;
    var returnVal;
    var ts = self.st.slides ? $(self.st.slides) : self.slider.children().detach();

    ts.each(function() {
      self._parseNode(this, true);
    });

    if(self.st.randomizeSlides) {
      self.slides.sort(function() { return 0.5 - Math.random(); });
    }
    self.numSlides = self.slides.length;
    self._refreshNumPreloadImages();

    if(!self.st.startSlideId) {
      self.st.startSlideId = 0;
    } else if(self.st.startSlideId > self.numSlides - 1) {
      self.st.startSlideId = self.numSlides - 1;
    }

    self._newSlideId = self.staticSlideId = self.currSlideId = self._realId =  self.st.startSlideId;
    self.currSlide = self.slides[self.currSlideId];

    self._accelerationPos = 0;
    self.pointerMultitouch = false;
    self.slider.addClass( (self._slidesHorizontal ? 'rsHor' : 'rsVer') + (self._isMove ? '' : ' rsFade') );

    var sliderHTML = '<div class="rsOverflow"><div class="rsContainer">';
    self.slidesSpacing = self.st.slidesSpacing;
    self._slideSize = ( self._slidesHorizontal ? self.slider.width() : self.slider.height() ) + self.st.slidesSpacing;

    self._preload = Boolean(self._numPreloadImages > 0);

    if(self.numSlides <= 1) {
      self._loop = false;
    }
    var loopHelpers = (self._loop && self._isMove) ? ( self.numSlides === 2 ? 1 : 2) : 0;
    self._loopHelpers = loopHelpers;

    self._maxImages = self.numSlides < 6 ? self.numSlides : 6;
    self._currBlockIndex = 0;


    self._idOffset = 0;
    self.slidesJQ = [];

    for(i =0; i < self.numSlides; i++) {
      self.slidesJQ.push( $(createItemHTML(i)) );
    }
    self._sliderOverflow = sliderHTML = $(sliderHTML + '</div></div>');


    var addCursors = function() {
      if(self.st.sliderDrag) {
        self._hasDrag = true;
        if (br.msie || br.opera) {
          self._grabCursor = self._grabbingCursor = "move";
        } else if(br.mozilla) {
          self._grabCursor = "-moz-grab";
          self._grabbingCursor = "-moz-grabbing";
        } else if(br.webkit && (navigator.platform.indexOf("Mac")!=-1)) {
          self._grabCursor = "-webkit-grab";
          self._grabbingCursor = "-webkit-grabbing";
        }
        self._setGrabCursor();
      }
    };
    var rsNS = self.ns;
    var addEventNames = function(pref, down, move, up, cancel) {
      self._downEvent = pref + down + rsNS;
      self._moveEvent = pref + move + rsNS;
      self._upEvent = pref + up + rsNS;
      if(cancel)
        self._cancelEvent = pref + cancel + rsNS;
    };


    // Pointer events support
    var nPointerEnabled = navigator.pointerEnabled;
    self.pointerEnabled = nPointerEnabled || navigator.msPointerEnabled;

    if(self.pointerEnabled) {
      self.hasTouch = false;
      self._lastItemFriction = 0.2;
      // Hardware supports multitouch
      self.pointerMultitouch = Boolean(navigator[ (nPointerEnabled ? 'm' : 'msM') + 'axTouchPoints' ] > 1);
      if(nPointerEnabled) {
        // >= IE11 & other devices that support pointer events
        addEventNames('pointer', 'down', 'move', 'up', 'cancel');
      } else {
        // IE10
        addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
      }
    } else {

      // IOS can't handle both touch and mouse events at once
      if(!self.isIOS) {
        addEventNames('mouse', 'down', 'move', 'up');
      } else {
        self._downEvent = self._moveEvent = self._upEvent = self._cancelEvent = '';
      }

      if('ontouchstart' in window || 'createTouch' in document) {
        self.hasTouch = true;
        self._downEvent += ' touchstart' + rsNS;
        self._moveEvent += ' touchmove' + rsNS;
        self._upEvent += ' touchend' + rsNS;
        self._cancelEvent += ' touchcancel' + rsNS;
        self._lastItemFriction = 0.5;
        if(self.st.sliderTouch) {
          self._hasDrag = true;
        }
      } else {
        self.hasTouch = false;
        self._lastItemFriction = 0.2;
      }
    }
    addCursors();

    self.slider.html(sliderHTML);


    self._controlsContainer = self.st.controlsInside ? self._sliderOverflow : self.slider;

    self._slidesContainer = self._sliderOverflow.children('.rsContainer');
    if(self.pointerEnabled) {
      self._slidesContainer.css( (nPointerEnabled ? '' : '-ms-') + 'touch-action', self._slidesHorizontal ? 'pan-y' : 'pan-x');
    }
    self._preloader = $(self.st.preloaderHTML);
    var slides = self._slidesContainer.children('.rsSlide');

    self._currHolder = self.slidesJQ[self.currSlideId];
    self._selectedSlideHolder = 0;

    function createItemHTML(i, className) {
      return '<div style="'+ (self._isMove ? '' : (i !== self.currSlideId  ? self._opacityCSS : 'z-index:0;') ) +'" class="rsSlide '+ (className || '')+'"></div>';
    }

    if(self._useCSS3Transitions) {

      // some constants for CSS3
      self._TP = 'transition-property';
      self._TD = 'transition-duration';
      self._TTF = 'transition-timing-function';

      self._yProp = self._xProp = self._vendorPref +'transform';

      if(self._use3dTransform) {
        if(br.webkit && !br.chrome) {
          self.slider.addClass('rsWebkit3d');
        }

        self._tPref1 = 'translate3d(';
        self._tPref2 = 'px, ';
        self._tPref3 = 'px, 0px)';
      } else {
        self._tPref1 = 'translate(';
        self._tPref2 = 'px, ';
        self._tPref3 = 'px)';
      }
      if(!self._isMove) {
        var animObj = {};
        animObj[(self._vendorPref + self._TP)] = 'opacity';
        animObj[(self._vendorPref + self._TD)] = self.st.transitionSpeed + 'ms';
        animObj[(self._vendorPref + self._TTF)] = self.st.css3easeInOut;
        slides.css(animObj);
      } else {
        self._slidesContainer[(self._vendorPref + self._TP)] = (self._vendorPref + 'transform');
      }


    } else {
      self._xProp = 'left';
      self._yProp = 'top';
    }



    // window resize
    var resizeTimer;
    $(window).on('resize'+self.ns, function() {
      if(resizeTimer) {
        clearTimeout(resizeTimer);
      }
      resizeTimer = setTimeout(function() { self.updateSliderSize(); }, 4);
    });
    self.ev.trigger('rsAfterPropsSetup'); // navigation (bullets, thumbs...) are created here

    self.updateSliderSize();


    // keyboard nav
    if(self.st.keyboardNavEnabled) {
      self._bindKeyboardNav();
    }

    if(self.st.arrowsNavHideOnTouch && (self.hasTouch || self.pointerMultitouch) ) {
      self.st.arrowsNav = false;
    }

    //Direction navigation (arrows)
    if(self.st.arrowsNav) {
      var rArr = 'rsArrow',
        container = self._controlsContainer;
      $('<div class="'+rArr+' '+rArr+'Left"><div class="'+rArr+'Icn"></div></div><div class="'+rArr+' '+rArr+'Right"><div class="'+rArr+'Icn"></div></div>').appendTo(container);

      self._arrowLeft = container.children('.'+rArr+'Left').click(function(e) {
        e.preventDefault();
        self.prev();
      });
      self._arrowRight = container.children('.'+rArr+'Right').click(function(e) {
        e.preventDefault();
        self.next();
      });

      if(self.st.arrowsNavAutoHide && !self.hasTouch) {
        self._arrowLeft.addClass('rsHidden');
        self._arrowRight.addClass('rsHidden');

        var hoverEl = container;
        hoverEl.one("mousemove.arrowshover",function() {
          self._arrowLeft.removeClass('rsHidden');
          self._arrowRight.removeClass('rsHidden');
        });


        hoverEl.hover(
          function() {
            if(!self._arrowsAutoHideLocked) {
              self._arrowLeft.removeClass('rsHidden');
              self._arrowRight.removeClass('rsHidden');
            }
          },
          function() {
            if(!self._arrowsAutoHideLocked) {
              self._arrowLeft.addClass('rsHidden');
              self._arrowRight.addClass('rsHidden');
            }
          }
        );
      }
      self.ev.on('rsOnUpdateNav', function() {
        self._updateArrowsNav();
      });
      self._updateArrowsNav();
    }



    if( self._hasDrag ) {
      self._slidesContainer.on(self._downEvent, function(e) { self._onDragStart(e); });
    } else {
      self.dragSuccess = false;
    }
    var videoClasses = ['rsPlayBtnIcon', 'rsPlayBtn', 'rsCloseVideoBtn', 'rsCloseVideoIcn'];
    self._slidesContainer.click(function(e) {
      if(!self.dragSuccess) {
        var t = $(e.target);
        var tClass = t.attr('class');
        if( $.inArray(tClass, videoClasses) !== -1) {
          if( self.toggleVideo() ) {
            return false;
          }
        }
        if(self.st.navigateByClick && !self._blockActions) {
          if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
            return true;
          }
          self._mouseNext(e);
        }
        self.ev.trigger('rsSlideClick', e);
      }
    }).on('click.rs', 'a', function(e) {
      if(self.dragSuccess) {
        return false;
      } else {
        self._blockActions = true;
        //e.stopPropagation();
        //e.stopImmediatePropagation();
        setTimeout(function() {
          self._blockActions = false;
        }, 3);
      }
    });
    self.ev.trigger('rsAfterInit');
  } /* RoyalSlider Constructor End */

  /**
   *
   * RoyalSlider Core Prototype
   *
   */
  RoyalSlider.prototype = {
    constructor: RoyalSlider,
    _mouseNext: function(e) {
      var self = this,
        relativePos = e[self._slidesHorizontal ? 'pageX' : 'pageY'] - self._sliderOffset;

      if(relativePos >= self._nextSlidePos) {
        self.next();
      } else if(relativePos < 0) {
        self.prev();
      }
    },
    _refreshNumPreloadImages: function() {
      var self = this,
        n;
      n = self.st.numImagesToPreload;
      self._loop = self.st.loop;

      if(self._loop) {
        if(self.numSlides === 2) {
          self._loop = false;
          self.st.loopRewind = true;
        } else if(self.numSlides < 2) {
          self.st.loopRewind = self._loop = false;
        }

      }
      if(self._loop && n > 0) {
        if(self.numSlides <= 4) {
          n = 1;
        } else {
          if(self.st.numImagesToPreload > (self.numSlides - 1) / 2 ) {
            n = Math.floor( (self.numSlides - 1) / 2 );
          }
        }
      }
      self._numPreloadImages = n;
    },
    _parseNode: function(content, pushToSlides) {
      var self = this,
        hasImg,
        isRoot,
        hasCover,
        obj = {},
        tempEl,
        first = true;
      content = $(content);
      self._currContent = content;
      self.ev.trigger('rsBeforeParseNode', [content, obj]);
      if(obj.stopParsing) {
        return;
      }
      content = self._currContent;
      obj.id = self._idCount;
      obj.contentAdded = false;
      self._idCount++;
      obj.images = [];
      obj.isBig = false;

      if(!obj.hasCover) {
        if(content.hasClass('rsImg')) {
          tempEl = content;
          hasImg = true;
        } else {
          tempEl = content.find('.rsImg');
          if(tempEl.length) {
            hasImg = true;
          }
        }

        if(hasImg) {
          obj.bigImage = tempEl.eq(0).attr('data-rsBigImg');
          tempEl.each(function() {
            var item = $(this);
            if(item.is('a')) {
              parseEl(item, 'href');
            } else if(item.is('img')) {
              parseEl(item, 'src');
            } else {
              parseEl(item);
            }
          });
        } else if(content.is('img')) {
          content.addClass('rsImg rsMainSlideImage');
          parseEl(content, 'src');
        }
      }
      tempEl = content.find('.rsCaption');
      if(tempEl.length) {
        obj.caption = tempEl.remove();
      }
      obj.content = content;

      self.ev.trigger('rsAfterParseNode', [content, obj]);
      function parseEl(el, s) {
        if(s) {
          obj.images.push( el.attr(s) );
        } else {
          obj.images.push( el.text() );
        }
        if(first) {
          first = false;
          obj.caption = (s === 'src') ? el.attr('alt') : el.contents();
          obj.image = obj.images[0];
          obj.videoURL = el.attr('data-rsVideo');


          var wAtt = el.attr('data-rsw'),
            hAtt = el.attr('data-rsh');
          if (typeof wAtt !== 'undefined' && wAtt !== false && typeof hAtt !== 'undefined' && hAtt !== false ) {
            obj.iW = parseInt(wAtt, 10);
            obj.iH = parseInt(hAtt, 10);
          } else if(self.st.imgWidth && self.st.imgHeight ) {
            obj.iW = self.st.imgWidth;
            obj.iH = self.st.imgHeight;
          }
        }
      }
      if(pushToSlides) {
        self.slides.push(obj);
      }
      if(obj.images.length === 0) {
        obj.isLoaded = true;
        obj.isRendered = false;
        obj.isLoading = false;
        obj.images = null;
      }
      return obj;
    },
    _bindKeyboardNav: function() {
      var self = this,
        interval,
        keyCode,
        onKeyboardAction = function (keyCode) {
          if(keyCode === 37) {
            self.prev();
          } else if (keyCode === 39) {
            self.next();
          }
        };

      self._doc.on('keydown' + self.ns, function(e) {
        if(!self._isDragging) {
          keyCode = e.keyCode;
          if(keyCode === 37 || keyCode === 39) {
            if(!interval) {
              onKeyboardAction(keyCode);
              interval = setInterval(function() {
                onKeyboardAction(keyCode);
              }, 700);
            }
          }
        }
      }).on('keyup' + self.ns, function(e) {
        if(interval) {
          clearInterval(interval);
          interval = null;
        }
      });



    },




    goTo: function(id, notUserAction) {
      var self = this;
      if(id !== self.currSlideId) {
        self._moveTo(id,self.st.transitionSpeed, true, !notUserAction);
      }
    },
    destroy: function(remove) {
      var self = this;
      self.ev.trigger('rsBeforeDestroy');
      self._doc.off('keydown' +self.ns+ ' keyup' + self.ns + ' ' + self._moveEvent +' '+ self._upEvent );
      self._slidesContainer.off(self._downEvent + ' click');
      self.slider.data('royalSlider', null);
      $.removeData(self.slider, 'royalSlider');
      $(window).off('resize' + self.ns);
      if(self.loadingTimeout) {
        clearTimeout(self.loadingTimeout);
      }
      if(remove) {
        self.slider.remove();
      }
      self.slides = null;
      self.slider = null;
      self.ev = null;
    },
    _updateBlocksContent: function(beforeTransition, getId) {
      var self = this,
        item,
        i,
        n,
        pref,
        group,
        groupId,
        slideCode,
        loop = self._loop,
        numSlides = self.numSlides;
      if(!isNaN(getId) ) {
        return getCorrectLoopedId(getId);
      }


      var id = self.currSlideId;
      var groupOffset;

      var itemsOnSide = beforeTransition ? (Math.abs(self._prevSlideId - self.currSlideId) >= self.numSlides - 1 ? 0 : 1) : self._numPreloadImages;
      var itemsToCheck = Math.min(2, itemsOnSide);

      var updateAfter = false;
      var updateBefore = false;
      var tempId;



      for(i = id; i < id + 1 + itemsToCheck; i++) {
        tempId = getCorrectLoopedId(i);
        item = self.slides[tempId];
        if(item && (!item.isAdded || !item.positionSet) ) {
          updateAfter = true;
          break;
        }
      }
      for(i = id - 1; i > id - 1 - itemsToCheck; i--) {
        tempId = getCorrectLoopedId(i);
        item = self.slides[tempId];
        if(item && (!item.isAdded || !item.positionSet) ) {
          updateBefore = true;
          break;
        }
      }
      if(updateAfter) {
        for(i = id; i < id + itemsOnSide + 1; i++) {
          tempId = getCorrectLoopedId(i);
          groupOffset = Math.floor( (self._realId - (id - i)) / self.numSlides) * self.numSlides;
          item = self.slides[tempId];
          if(item) {
            updateItem(item, tempId);
          }
        }
      }
      if(updateBefore) {
        for(i = id - 1; i > id - 1 - itemsOnSide; i--) {
          tempId = getCorrectLoopedId(i);
          groupOffset = Math.floor( (self._realId - (id - i) ) / numSlides) * numSlides;
          item = self.slides[tempId];
          if(item) {
            updateItem(item, tempId);
          }
        }
      }
      if(!beforeTransition) {
        var start = id;
        var distance = itemsOnSide;
        var min = getCorrectLoopedId(id - itemsOnSide);
        var max = getCorrectLoopedId(id + itemsOnSide);

        var nmin = min > max ? 0 : min;

        for (i = 0; i < numSlides; i++) {
          if(min > max) {
            if(i > min - 1) {
              continue;
            }
          }
          if(i < nmin || i > max) {
            item = self.slides[i];
            if(item && item.holder) {
              item.holder.detach();
              item.isAdded = false;
            }
          }
        }
      }





      function updateItem(item , i, slideCode) {

        if(!item.isAdded) {
          if(!slideCode)
            slideCode = self.slidesJQ[i];

          if(!item.holder) {
            slideCode = self.slidesJQ[i] = $(slideCode);
            item.holder = slideCode;
          } else {
            slideCode = item.holder;
          }

          item.appendOnLoaded = false;


          updatePos(i, item, slideCode);
          addContent(i, item);
          self._addBlockToContainer(item, slideCode, beforeTransition);
          item.isAdded = true;
        } else {
          addContent(i, item);
          updatePos(i, item);
        }
      }
      function addContent(i, item) {
        if(!item.contentAdded) {
          self.setItemHtml(item, beforeTransition);
          if(!beforeTransition) {
            item.contentAdded = true;
          }

        }
      }
      function updatePos(i, item, slideCode) {
        if(self._isMove) {
          if(!slideCode) {
            slideCode = self.slidesJQ[i];
          }

          slideCode.css(self._reorderProp, (i + self._idOffset + groupOffset) * self._slideSize);
        }
      }
      function getCorrectLoopedId(index) {
        var changed = false;
        if(loop) {
          if(index > numSlides - 1) {
            return getCorrectLoopedId(index - numSlides);
          } else  if(index < 0) {
            return getCorrectLoopedId(numSlides + index);
          }
        }
        return index;
      }

    },

    /**
     * Sets or loads HTML for specified slide
     * @param {Object} currSlideObject  holds data about curr slide (read about rsAfterParseNode for more info)
     * @param {Boolean} beforeTransition determines if setItemHTML method is called before or after transition
     */
    setItemHtml: function(currSlideObject, beforeTransition) {
      var self = this;

      var parseDataAndLoad = function() {
        if(!currSlideObject.images) {
          currSlideObject.isRendered = true;
          currSlideObject.isLoaded = true;
          currSlideObject.isLoading = false;
          appendContent(true);
          return;
        }
        if(currSlideObject.isLoading) {
          return;
        }

        var el,
          isRoot;
        if(currSlideObject.content.hasClass('rsImg') ) {
          el = currSlideObject.content;
          isRoot = true;
        } else {
          el = currSlideObject.content.find('.rsImg:not(img)');
        }
        if(el && !el.is('img')) {
          el.each(function() {
            var item = $(this),
              newEl = '<img class="rsImg" src="'+ ( item.is('a') ? item.attr('href') : item.text() ) +'" />';

            if(!isRoot) {
              item.replaceWith( newEl );
            } else {
              currSlideObject.content = $(newEl);
            }
          });
        }

        el = isRoot ? currSlideObject.content : currSlideObject.content.find('img.rsImg');
        setPreloader();

        el.eq(0).addClass('rsMainSlideImage');
        if(currSlideObject.iW && currSlideObject.iH) {
          if(!currSlideObject.isLoaded) {
            self._resizeImage( currSlideObject );
          }
          appendContent();
        }

        currSlideObject.isLoading = true;
        var newEl;

        var eNames = 'load.rs error.rs';
        if(currSlideObject.isBig) {
          $('<img />').on(eNames, function(e){
            $(this).off(eNames);
            onLoad( [this], true );
          }).attr('src', currSlideObject.image);
        } else {
          currSlideObject.loaded = [];
          currSlideObject.numStartedLoad = 0;
          var onLoaded = function(e) {
            $(this).off(eNames);
            currSlideObject.loaded.push( this );
            if(currSlideObject.loaded.length === currSlideObject.numStartedLoad) {
              onLoad( currSlideObject.loaded, false );
            }
          };
          for(var i = 0; i < currSlideObject.images.length; i++) {
            var image = $('<img />');
            currSlideObject.numStartedLoad++;
            image.on('load.rs error.rs', onLoaded).attr('src', currSlideObject.images[i]);
          }
        }
      };

      var onLoad = function($images, isBig) {
        if($images.length) {
          var img = $images[0],
          src = img.src;

          if(isBig !== currSlideObject.isBig) {
            var c = currSlideObject.holder.children();
            if(c && c.length > 1) {
              removePreloader();
            }
            return;
          }

          if(currSlideObject.iW && currSlideObject.iH) {
            imageLoadingComplete();
            return;
          }
          currSlideObject.iW = img.width;
          currSlideObject.iH = img.height;
          if(currSlideObject.iW && currSlideObject.iH) {
            imageLoadingComplete();
            return;
          } else {
            // if no size, try again
            var loader = new Image();
            loader.onload = function() {
              if(loader.width) {
                currSlideObject.iW = loader.width;
                currSlideObject.iH = loader.height;
                imageLoadingComplete();
              } else {
                setTimeout(function() {
                  if(loader.width) {
                    currSlideObject.iW = loader.width;
                    currSlideObject.iH = loader.height;
                  }

                  // failed to get size on last tier, just output image
                  imageLoadingComplete();
                }, 1000);
              }
            };
            loader.src = img.src;
          }
        } else {
          imageLoadingComplete();
        }
      };

      var imageLoadingComplete = function () {
        currSlideObject.isLoaded = true;
        currSlideObject.isLoading = false;

        appendContent();
        removePreloader();
        triggerLoaded();
      };

      var waitForTransition = function () {
        if(!self._isMove && currSlideObject.images && currSlideObject.iW && currSlideObject.iH) {
          parseDataAndLoad();
          return;
        }
        currSlideObject.holder.isWaiting = true;
        setPreloader();
        currSlideObject.holder.slideId = -99;
      };

      var appendContent = function() {
        if(!currSlideObject.isAppended && self.ev) {

          var visibleNearby = self.st.visibleNearby,
          bId = currSlideObject.id - self._newSlideId;
          if(!beforeTransition && !currSlideObject.appendOnLoaded && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
            var css = {
              visibility: 'visible',
              opacity: 0
            };
            css[self._vendorPref + 'transition'] = 'opacity 400ms ease-in-out';
            currSlideObject.content.css(css);

            setTimeout(function() {
              currSlideObject.content.css('opacity', 1);
            }, 16);
          }

          if(currSlideObject.holder.find('.rsPreloader').length) {
            currSlideObject.holder.append( currSlideObject.content );
          } else {
            currSlideObject.holder.html( currSlideObject.content );
          }


          currSlideObject.isAppended = true;
          if(currSlideObject.isLoaded) {
            self._resizeImage(currSlideObject);
            triggerLoaded();
          }
          if(!currSlideObject.sizeReady) {
            currSlideObject.sizeReady = true;
            setTimeout(function() {
              // triggers after content is added, usually is true when page is refreshed from cache
              self.ev.trigger('rsMaybeSizeReady', currSlideObject);
            }, 100);
          }

        }
      };
      var triggerLoaded = function () {
        if(!currSlideObject.loadedTriggered && self.ev) {
          currSlideObject.isLoaded = currSlideObject.loadedTriggered = true;
          currSlideObject.holder.trigger('rsAfterContentSet');
          self.ev.trigger('rsAfterContentSet', currSlideObject);
        }
      };
      var setPreloader = function () {
        if(self.st.usePreloader)
          currSlideObject.holder.html(self._preloader.clone());
      };
      var removePreloader = function (now) {
        if(self.st.usePreloader) {
          var preloader = currSlideObject.holder.find('.rsPreloader');
          if(preloader.length) {
            preloader.remove();
          }
        }
      };

      if(currSlideObject.isLoaded) {
        appendContent();
        return;
      } else {
        if(beforeTransition) {
          waitForTransition();
        } else {
          parseDataAndLoad();
        }
      }

    },
    _addBlockToContainer: function(slideObject, content, dontFade) {
      var self = this;
      var holder = slideObject.holder;
      var bId = slideObject.id - self._newSlideId;
      var visibleNearby = false;

      self._slidesContainer.append(holder);
      slideObject.appendOnLoaded = false;
    },

    _onDragStart:function(e, isThumbs) {
      var self = this,
        point,
        wasAnimating,
        isTouch = (e.type === 'touchstart');


      self._isTouchGesture = isTouch;

      self.ev.trigger('rsDragStart');
      if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
        self.dragSuccess = false;
        return true;
      }


      if(!isThumbs) {
        if(self._isAnimating) {
          self._wasAnimating = true;

          self._stopAnimation();
        }
      }
      self.dragSuccess = false;
      if(self._isDragging) {
        if(isTouch) {
          self._multipleTouches = true;
        }
        return;
      } else {
        if(isTouch) {
          self._multipleTouches = false;
        }
      }

      self._setGrabbingCursor();

      if(isTouch) {
        //parsing touch event
        var touches = e.originalEvent.touches;
        if(touches && touches.length > 0) {
          point = touches[0];
          if(touches.length > 1) {
            self._multipleTouches = true;
          }
        }
        else {
          return;
        }
      } else {
        e.preventDefault();
        point = e;
        if(self.pointerEnabled) point = point.originalEvent;
      }

      self._isDragging = true;
      self._doc.on(self._moveEvent, function(e) { self._onDragMove(e, isThumbs); })
            .on(self._upEvent, function(e) { self._onDragRelease(e, isThumbs); });

      self._currMoveAxis = '';
      self._hasMoved = false;
      self._pageX = point.pageX;
      self._pageY = point.pageY;
      self._startPagePos = self._accelerationPos = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal) ? point.pageX : point.pageY;

      self._horDir = 0;
      self._verDir = 0;

      self._currRenderPosition = !isThumbs ? self._sPosition : self._thumbsPosition;

      self._startTime = new Date().getTime();
      if(isTouch) {
        self._sliderOverflow.on(self._cancelEvent, function(e) { self._onDragRelease(e, isThumbs); });
      }
    },
    _renderMovement:function(point, isThumbs) {
      var self = this;
      if(self._checkedAxis) {

        var timeStamp = self._renderMoveTime,
          deltaX = point.pageX - self._pageX,
          deltaY = point.pageY - self._pageY,
          newX = self._currRenderPosition + deltaX,
          newY = self._currRenderPosition + deltaY,
          isHorizontal = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
          newPos = isHorizontal ? newX : newY,
          mAxis = self._currMoveAxis;

        self._hasMoved = true;
        self._pageX = point.pageX;
        self._pageY = point.pageY;

        if(mAxis === 'x' && deltaX !== 0) {
          self._horDir = deltaX > 0 ? 1 : -1;
        } else if(mAxis === 'y' && deltaY !== 0) {
          self._verDir = deltaY > 0 ? 1 : -1;
        }

        var pointPos = isHorizontal ? self._pageX : self._pageY,
          deltaPos = isHorizontal ? deltaX : deltaY;
        if(!isThumbs) {
          if(!self._loop) {
            if(self.currSlideId <= 0) {
              if(pointPos - self._startPagePos > 0) {
                newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
              }
            }
            if(self.currSlideId >= self.numSlides - 1) {
              if(pointPos - self._startPagePos < 0) {
                newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
              }
            }
          }
        } else {
          if(newPos > self._thumbsMinPosition) {
            newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
          } else if(newPos < self._thumbsMaxPosition) {
            newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
          }
        }

        self._currRenderPosition = newPos;

        if (timeStamp - self._startTime > 200) {
          self._startTime = timeStamp;
          self._accelerationPos = pointPos;
        }

        if(!isThumbs) {
          if(self._isMove) {
            self._setPosition(self._currRenderPosition);
          }
        } else {
          self._setThumbsPosition(self._currRenderPosition);
        }
      }

    },
    _onDragMove:function(e, isThumbs) {
      var self = this,
        point,
        isTouch = (e.type === 'touchmove');

      if(self._isTouchGesture && !isTouch) {
        return;
      }

      if(isTouch) {
        if(self._lockAxis) {
          return;
        }
        var touches = e.originalEvent.touches;
        if(touches) {
          if(touches.length > 1) {
            return;
          } else {
            point = touches[0];
          }
        } else {
          return;
        }
      } else {
        point = e;
        if(self.pointerEnabled) point = point.originalEvent;
      }


      if(!self._hasMoved) {
        if(self._useCSS3Transitions) {
          (!isThumbs ? self._slidesContainer : self._thumbsContainer).css((self._vendorPref + self._TD), '0s');
        }
        (function animloop(){
          if(self._isDragging) {
            self._animFrame = requestAnimationFrame(animloop);
            if(self._renderMoveEvent)
              self._renderMovement(self._renderMoveEvent, isThumbs);
          }

        })();
      }

      if(!self._checkedAxis) {

        var dir = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
          diff = (Math.abs(point.pageX - self._pageX) - Math.abs(point.pageY - self._pageY) ) - (dir ? -7 : 7);

        if(diff > 7) {
          // hor movement
          if(dir) {
            e.preventDefault();
            self._currMoveAxis = 'x';
          } else if(isTouch) {
            self._completeGesture(e);
            return;
          }
          self._checkedAxis = true;
        } else if(diff < -7) {
          // ver movement
          if(!dir) {
            e.preventDefault();
            self._currMoveAxis = 'y';
          } else if(isTouch) {
            self._completeGesture(e);
            return;
          }
          self._checkedAxis = true;
        }
        return;
      }

      e.preventDefault();
      self._renderMoveTime = new Date().getTime();
      self._renderMoveEvent = point;
    },
    _completeGesture: function(e, isThumbs) {
      var self = this;
      self._lockAxis = true;
      self._hasMoved = self._isDragging = false;
      self._onDragRelease(e);
    },
    _onDragRelease:function(e, isThumbs) {
      var self = this,
        totalMoveDist,
        accDist,
        duration,
        v0,
        newPos,
        newDist,
        newDuration,
        blockLink,
        isTouch = (e.type.indexOf('touch') > -1);




      if(self._isTouchGesture && !isTouch) {
        return;
      }

      self._isTouchGesture = false;
      self.ev.trigger('rsDragRelease');

      self._renderMoveEvent = null;
      self._isDragging = false;
      self._lockAxis = false;
      self._checkedAxis = false;
      self._renderMoveTime = 0;
      cancelAnimationFrame(self._animFrame);
      if(self._hasMoved) {
        if(!isThumbs) {
          if(self._isMove) {
            self._setPosition(self._currRenderPosition);
          }
        } else {
          self._setThumbsPosition(self._currRenderPosition);
        }
      }


      self._doc.off(self._moveEvent).off(self._upEvent);

      if(isTouch) {
        self._sliderOverflow.off(self._cancelEvent);
      }


      self._setGrabCursor();
      if (!self._hasMoved && !self._multipleTouches) {
        if(isThumbs && self._thumbsEnabled) {
          var item = $(e.target).closest('.rsNavItem');
          if(item.length) {

            self.goTo(item.index());
          }
          return;
        }
      }
      var orient = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal);
      if(!self._hasMoved || (self._currMoveAxis === 'y' && orient) || (self._currMoveAxis === 'x' && !orient) ) {
        if(!isThumbs && self._wasAnimating) {
          self._wasAnimating = false;
          if(!self.st.navigateByClick) {
            self.dragSuccess = true;
          } else {
            self._mouseNext( (self.pointerEnabled ? e.originalEvent : e) );
            self.dragSuccess = true;
            return;
          }
        } else {
          self._wasAnimating = false;
          self.dragSuccess = false;
          return;
        }

      } else {
        self.dragSuccess = true;
      }

      self._wasAnimating = false;


      self._currMoveAxis = '';


      function getCorrectSpeed(newSpeed) {
        if(newSpeed < 100) {
          return 100;
        } else if(newSpeed > 500) {
          return 500;
        }
        return newSpeed;
      }
      function returnToCurrent(isSlow, v0) {

        // we are on the last slide, and not letting it go through, fire event
        if((self.currSlideId+1) === self.numSlides) {
          self.ev.trigger('rsTryingToAdvancePastLastSlide');
        }

        if(self._isMove || isThumbs) {

          newPos = (-self._realId - self._idOffset) * self._slideSize;
          newDist = Math.abs(self._sPosition  - newPos);
          self._currAnimSpeed = newDist / v0;
          if(isSlow) {
            self._currAnimSpeed += 250;
          }
          self._currAnimSpeed = getCorrectSpeed(self._currAnimSpeed);

          self._animateTo(newPos, false);
        }
      }

      var snapDist = self.st.minSlideOffset,
        point = isTouch ? e.originalEvent.changedTouches[0] : (self.pointerEnabled ? e.originalEvent : e),
        pPos = orient ? point.pageX : point.pageY,
        sPos = self._startPagePos,
        axPos = self._accelerationPos,
        axCurrItem = self.currSlideId,
        axNumItems = self.numSlides,
        dir = orient ? self._horDir : self._verDir,
        loop = self._loop,
        changeHash = false,
        distOffset = 0;

      totalMoveDist = Math.abs(pPos - sPos);
      accDist = pPos - axPos;


      duration = (new Date().getTime()) - self._startTime;
      v0 = Math.abs(accDist) / duration;

      if(dir === 0 || axNumItems <= 1) {
        returnToCurrent(true, v0);
        return;
      }

      if(!loop && !isThumbs) {
        if(axCurrItem <= 0) {
          if(dir > 0) {
            returnToCurrent(true, v0);
            return;
          }
        } else if(axCurrItem >= axNumItems - 1) {
          if(dir < 0) {
            returnToCurrent(true, v0);
            return;
          }
        }
      }

      if(!isThumbs) {

        var getSwipedSlides = function(dist) {
          var numSwipedSlides = Math.floor(dist / self._slideSize);
                var nextSlideOffset = dist - (numSwipedSlides * self._slideSize);
                if (nextSlideOffset > snapDist) {
                    numSwipedSlides++;
                }
                return numSwipedSlides;
        };

        if(sPos + snapDist < pPos) {
          if(dir < 0) {
            returnToCurrent(false, v0);
            return;
          }
          var swipedSlides = getSwipedSlides(pPos - sPos);
          self._moveTo(self.currSlideId-swipedSlides, getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset + swipedSlides) * self._slideSize) / v0), changeHash, true, true);
        } else if(sPos - snapDist > pPos) {
          if(dir > 0) {
            returnToCurrent(false, v0);
            return;
          }

          var swipedSlides = getSwipedSlides(sPos - pPos);
                self._moveTo(self.currSlideId+swipedSlides, getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset - swipedSlides) * self._slideSize) / v0), changeHash, true, true);

        } else {
          returnToCurrent(false, v0);
        }
      } else {
        newPos = self._thumbsPosition;
        var transitionSpeed;

        if(newPos > self._thumbsMinPosition) {
          newPos = self._thumbsMinPosition;
        } else if(newPos < self._thumbsMaxPosition) {
          newPos = self._thumbsMaxPosition;
        } else {
          var friction = 0.003,
            S = (v0 * v0) / (friction * 2),
            minXDist = -self._thumbsPosition,
            maxXDist = self._thumbsContainerSize - self._thumbsViewportSize + self._thumbsPosition;

          if (accDist > 0 && S > minXDist) {
            minXDist = minXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
            v0 = v0 * minXDist / S;
            S = minXDist;
          } else if (accDist < 0 && S > maxXDist) {
            maxXDist = maxXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
            v0 = v0 * maxXDist / S;
            S = maxXDist;
          }




          transitionSpeed =  Math.max(Math.round(v0 / friction), 50);
          newPos = newPos + S * (accDist < 0 ? -1 : 1);


          if(newPos > self._thumbsMinPosition) {
            self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMinPosition, 200);
            return;
          } else if(newPos < self._thumbsMaxPosition) {
            self._animateThumbsTo( newPos, transitionSpeed, true, self._thumbsMaxPosition, 200);
            return;
          }
        }

        self._animateThumbsTo(newPos, transitionSpeed, true);

      }
    },



    _setPosition: function(pos) {
      var self = this;
      pos = self._sPosition = pos;
      if(self._useCSS3Transitions) {
        self._slidesContainer.css(self._xProp, self._tPref1 + ( self._slidesHorizontal ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 );
      } else {
        self._slidesContainer.css(self._slidesHorizontal ? self._xProp : self._yProp, pos);
      }
    },


    updateSliderSize: function(force) {
      var self = this,
        newWidth,
        newHeight;

      if(self.st.autoScaleSlider) {
        var asw = self.st.autoScaleSliderWidth,
          ash = self.st.autoScaleSliderHeight;

        if(self.st.autoScaleHeight) {
          newWidth = self.slider.width();
          if(newWidth != self.width) {
            self.slider.css("height", newWidth * (ash / asw) );
            newWidth = self.slider.width();
          }
          newHeight = self.slider.height();
        } else {
          newHeight = self.slider.height();
          if(newHeight != self.height) {
            self.slider.css("width", newHeight * (asw / ash));
            newHeight = self.slider.height();
          }
          newWidth = self.slider.width();
        }

      } else {
        newWidth = self.slider.width();
        newHeight = self.slider.height();
      }



      if(force || newWidth != self.width || newHeight != self.height) {
        self.width = newWidth;
        self.height = newHeight;

        self._wrapWidth = newWidth;
        self._wrapHeight = newHeight;

        self.ev.trigger('rsBeforeSizeSet');
        self.ev.trigger('rsAfterSizePropSet');

        self._sliderOverflow.css({
          width: self._wrapWidth,
          height: self._wrapHeight
        });


        self._slideSize = (self._slidesHorizontal ? self._wrapWidth : self._wrapHeight) + self.st.slidesSpacing;


        self._imagePadding = self.st.imageScalePadding;
        var item,
          slideItem,
          i,
          img;
        for(i = 0; i < self.slides.length; i++) {
          item = self.slides[i];
          item.positionSet = false;

          if(item && item.images && item.isLoaded) {
            item.isRendered = false;
            self._resizeImage(item);
          }
        }
        if(self._cloneHolders) {
          for(i = 0; i < self._cloneHolders.length; i++) {
            item = self._cloneHolders[i];
            item.holder.css(self._reorderProp, (item.id + self._idOffset) * self._slideSize);
          }
        }

        self._updateBlocksContent();

        if(self._isMove) {
          if(self._useCSS3Transitions) {
            self._slidesContainer.css(self._vendorPref + 'transition-duration', '0s');
          }
          self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
        }
        self.ev.trigger('rsOnUpdateNav');
        self.ev.trigger('rsAfterSizeSet');
      }
      self._sliderOffset = self._sliderOverflow.offset();
      self._sliderOffset = self._sliderOffset[self._reorderProp];


    },

    /**
     * Adds slide
     * @param  {jQuery object or raw HTML} htmltext
     * @param  {int} index    (optional) Index where item should be added (last item is removed of not specified)
     */
    appendSlide: function(htmltext, index) {
      var self = this,
        parsedSlide = self._parseNode(htmltext);

      if(isNaN(index) || index > self.numSlides) {
        index = self.numSlides;
      }
      self.slides.splice(index, 0, parsedSlide);
      self.slidesJQ.splice(index, 0, $('<div style="'+ (self._isMove ? 'position:absolute;' : self._opacityCSS ) +'" class="rsSlide"></div>') );

      if(index < self.currSlideId) {
        self.currSlideId++;
      }
      self.ev.trigger('rsOnAppendSlide', [parsedSlide, index]);

      self._refreshSlides(index);

      if(index === self.currSlideId) {
        self.ev.trigger('rsAfterSlideChange');
      }
    },

    /**
     * Removes slide
     * @param  {int} Index of item that should be removed
     */
    removeSlide: function(index) {
      var self = this,
        slideToRemove = self.slides[index];

      if(slideToRemove) {
        if(slideToRemove.holder) {
          slideToRemove.holder.remove();
        }
        if(index < self.currSlideId) {
          self.currSlideId--;
        }
        self.slides.splice(index, 1);
        self.slidesJQ.splice(index, 1);

        self.ev.trigger('rsOnRemoveSlide', [index]);
        self._refreshSlides(index);

        if(index === self.currSlideId) {
          self.ev.trigger('rsAfterSlideChange');
        }
      }
    },
    _refreshSlides: function(refreshIndex) {

      // todo: optimize this stuff
      var self = this;

      var oldNumSlides = self.numSlides;
      var numLoops = self._realId <= 0 ? 0 : Math.floor(self._realId / oldNumSlides);

      self.numSlides = self.slides.length;
      if(self.numSlides === 0) {
        self.currSlideId = self._idOffset = self._realId = 0;
        self.currSlide = self._oldHolder = null;
      } else {
        self._realId = numLoops * self.numSlides + self.currSlideId;
      }

      for(var i = 0; i < self.numSlides; i++) {
        self.slides[i].id = i;
      }

      self.currSlide = self.slides[self.currSlideId];
      self._currHolder = self.slidesJQ[self.currSlideId];

      if(self.currSlideId >= self.numSlides) {
        self.goTo(self.numSlides - 1);
      } else if(self.currSlideId < 0) {
        self.goTo(0);
      }

      self._refreshNumPreloadImages();

      if(self._isMove && self._loop) {
        self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
      }
      if(self._refreshSlidesTimeout) {
        clearTimeout(self._refreshSlidesTimeout);
      }


      self._refreshSlidesTimeout = setTimeout(function() {
        if(self._isMove) {
          self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
        }
        self._updateBlocksContent();
        if(!self._isMove) {
          self._currHolder.css({
            display: 'block',
            opacity: 1
          });
        }

      }, 14);
      self.ev.trigger('rsOnUpdateNav');
    },
    _setGrabCursor:function() {
      var self = this;
      if(self._hasDrag && self._isMove) {
        if(self._grabCursor) {
          self._sliderOverflow.css('cursor', self._grabCursor);
        } else {
          self._sliderOverflow.removeClass('grabbing-cursor');
          self._sliderOverflow.addClass('grab-cursor');
        }
      }
    },
    _setGrabbingCursor:function() {
      var self = this;
      if(self._hasDrag && self._isMove) {
        if(self._grabbingCursor) {
          self._sliderOverflow.css('cursor', self._grabbingCursor);
        } else {
          self._sliderOverflow.removeClass('grab-cursor');
          self._sliderOverflow.addClass('grabbing-cursor');
        }
      }
    },
    next: function(notUserAction) {
      var self = this;
      self._moveTo('next',  self.st.transitionSpeed, true, !notUserAction);
    },
    prev: function(notUserAction) {
      var self = this;
      self._moveTo('prev', self.st.transitionSpeed, true, !notUserAction);
    },
    _moveTo:function(type,  speed, inOutEasing, userAction, fromSwipe) {
      // If an interstitial ad is active and the disable timer is active cancel out
      if( $('#ad-gallery-control').length > 0 && $('#ad-gallery-control').attr('rel') === 'gallery-blocked' ){
        return false;
      }

      var self = this,
        newPos,
        difference,
        i,
        newItemId;


      self.ev.trigger('rsBeforeMove', [type, userAction]);
      if(type === 'next') {
        newItemId = self.currSlideId+1;
      } else if(type === 'prev') {
        newItemId = self.currSlideId-1;
      } else {
        newItemId = type = parseInt(type, 10);
      }

      if(!self._loop) {
        if(newItemId < 0) {
          //self._doBackAndForthAnim('left', !userAction);
          return;
        } else if(newItemId >= self.numSlides ) {
          self.ev.trigger('rsTryingToAdvancePastLastSlide', [type, userAction]);
          //self._doBackAndForthAnim('right', !userAction);
          return;
        }
      } else {

        if(newItemId < 0) {
          return;
        }

      }

      if(self._isAnimating) {
        self._stopAnimation(true);
        inOutEasing = false;
      }

      difference = newItemId - self.currSlideId;



      self._prevSlideId = self.currSlideId;
      var prevId = self.currSlideId;
      var id = self.currSlideId + difference;
      var realId = self._realId;
      var temp;
      var delayed;
      if(self._loop) {
        id = self._updateBlocksContent(false, id);
        realId += difference;
      } else {
        realId = id;
      }
      self._newSlideId = id;

      self._oldHolder = self.slidesJQ[self.currSlideId];


      self._realId = realId;
      self.currSlideId = self._newSlideId;

      self.currSlide = self.slides[self.currSlideId];
      self._currHolder = self.slidesJQ[self.currSlideId];


      var checkDist = self.st.slidesDiff;
      var next = Boolean(difference > 0);
      var absDiff = Math.abs(difference);
      var g1 = Math.floor( prevId / self._numPreloadImages);
      var g2 = Math.floor( ( prevId + (next ? checkDist : -checkDist  ) ) / self._numPreloadImages);
      var biggest = next ? Math.max(g1,g2) : Math.min(g1,g2);
      var biggestId = biggest * self._numPreloadImages +  ( next ? (self._numPreloadImages - 1) : 0 );
      if(biggestId > self.numSlides - 1) {
        biggestId = self.numSlides - 1;
      } else if(biggestId < 0) {
        biggestId = 0;
      }
      var toLast =  next ? (biggestId - prevId) :  (prevId - biggestId);
      if(toLast > self._numPreloadImages) {
        toLast = self._numPreloadImages;
      }
      if(absDiff > toLast + checkDist) {
        self._idOffset +=  ( absDiff - (toLast + checkDist) ) * ( next ? -1 : 1 );
        speed = speed * 1.4;
        for(i = 0; i < self.numSlides; i++) {
          self.slides[i].positionSet = false;
        }
      }
      self._currAnimSpeed = speed;

      self._updateBlocksContent(true);
      if(!fromSwipe) {
        delayed = true;
      }


      newPos = (-realId - self._idOffset) * self._slideSize;



      if(delayed) {
        setTimeout(function() {
          self._isWorking = false;
          self._animateTo(newPos, type, false, inOutEasing);
          self.ev.trigger('rsOnUpdateNav');
        }, 0);
      } else {
        self._animateTo(newPos, type, false, inOutEasing);
        self.ev.trigger('rsOnUpdateNav');
      }


      function isSetToCurrent(testId) {
        if(testId < 0) {
          testId = self.numSlides + testId;
        } else if(testId > self.numSlides - 1) {
          testId = testId - self.numSlides;
        }
        if(testId !== self.currSlideId) {
          return false;
        }
        return true;
      }

    },
    _updateArrowsNav: function() {
      var self = this,
        arrDisClass = 'rsArrowDisabled';
      if(self.st.arrowsNav) {
        if(self.numSlides <= 1) {
          self._arrowLeft.css('display', 'none');
          self._arrowRight.css('display', 'none');
          return;
        } else {
          self._arrowLeft.css('display', 'block');
          self._arrowRight.css('display', 'block');
        }
        if(!self._loop && !self.st.loopRewind) {
          if(self.currSlideId === 0) {
            self._arrowLeft.addClass(arrDisClass);
          } else {
            self._arrowLeft.removeClass(arrDisClass);
          }
          if(self.currSlideId === self.numSlides - 1) {
            self._arrowRight.addClass(arrDisClass);
          } else {
            self._arrowRight.removeClass(arrDisClass);
          }
        }
        else {
          if(self.currSlideId === 0) {
            self._arrowLeft.addClass(arrDisClass);
          } else {
            self._arrowLeft.removeClass(arrDisClass);
          }
        }
      }
    },
    _animateTo:function(pos, dir,  loadAll, inOutEasing, customComplete) {
      var self = this,
        moveProp,
        oldBlock,
        animBlock;

      var animObj = {};
      if(isNaN(self._currAnimSpeed)) {
        self._currAnimSpeed = 400;
      }



      self._sPosition = self._currRenderPosition = pos;

      self.ev.trigger('rsBeforeAnimStart');

      if(!self._useCSS3Transitions) {
        if(self._isMove) {
          animObj[self._slidesHorizontal ? self._xProp : self._yProp] = pos + 'px';


          self._slidesContainer.animate(animObj, self._currAnimSpeed, /*'easeOutQuart'*/ inOutEasing ? self.st.easeInOut : self.st.easeOut);
        } else {
          oldBlock = self._oldHolder;
          animBlock = self._currHolder;

          animBlock.stop(true, true).css({
            opacity: 0,
            display: 'block',
            zIndex: self._fadeZIndex
          });
          self._currAnimSpeed = self.st.transitionSpeed;
          animBlock.animate({opacity: 1}, self._currAnimSpeed, self.st.easeInOut);


          clearTimeouts();
          if(oldBlock) {
            oldBlock.data('rsTimeout', setTimeout(function() {
              oldBlock.stop(true, true).css({
                opacity: 0,
                display: 'none',
                zIndex: 0
              });
            }, self._currAnimSpeed + 60) );
          }
        }

      } else {
        if(self._isMove) {



            self._currAnimSpeed = parseInt(self._currAnimSpeed, 10);
            var td = self._vendorPref + self._TD;
            var ttf = self._vendorPref + self._TTF;

            animObj[td] = self._currAnimSpeed+'ms';
            animObj[ttf] = inOutEasing ? $.rsCSS3Easing[self.st.easeInOut] : $.rsCSS3Easing[self.st.easeOut];

            self._slidesContainer.css(animObj);
          if(inOutEasing || !self.hasTouch) {
            setTimeout(function() {
              self._setPosition(pos);
            }, 5);
          } else {
            self._setPosition(pos);
          }



        } else {
          //self._currAnimSpeed = 10
          self._currAnimSpeed = self.st.transitionSpeed;
          oldBlock = self._oldHolder;
          animBlock = self._currHolder;
          if(animBlock.data('rsTimeout')) {
            animBlock.css('opacity', 0);
          }
          clearTimeouts();
          if(oldBlock) {
            //if(oldBlock)
            oldBlock.data('rsTimeout', setTimeout(function() {
              animObj[self._vendorPref + self._TD] = '0ms';
              animObj.zIndex = 0;
              animObj.display = 'none';
              oldBlock.data('rsTimeout', '');
              oldBlock.css(animObj);
              setTimeout(function() {
                oldBlock.css('opacity', 0);
              }, 16);
            }, self._currAnimSpeed + 60) );
          }

          animObj.display = 'block';
          animObj.zIndex = self._fadeZIndex;
          animObj.opacity = 0;
          animObj[self._vendorPref + self._TD] = '0ms';
          animObj[self._vendorPref + self._TTF] = $.rsCSS3Easing[self.st.easeInOut];
          animBlock.css(animObj);
          animBlock.data('rsTimeout', setTimeout(function() {
            //animBlock.css('opacity', 0);
            animBlock.css(self._vendorPref + self._TD,  self._currAnimSpeed+'ms');

            //oldBlock.css(self._vendorPref + self._TD,  '0ms');
            animBlock.data('rsTimeout', setTimeout(function() {
              animBlock.css('opacity', 1);
              animBlock.data('rsTimeout', '');
            }, 20) );
          }, 20) );
        }
      }
      self._isAnimating = true;
      if(self.loadingTimeout) {
        clearTimeout(self.loadingTimeout);
      }
      if(customComplete) {
        self.loadingTimeout = setTimeout(function() {
          self.loadingTimeout = null;
          customComplete.call();

        }, self._currAnimSpeed + 60);
      } else {
        self.loadingTimeout = setTimeout(function() {
          self.loadingTimeout = null;
          self._animationComplete(dir);
        }, self._currAnimSpeed + 60);
      }

      function clearTimeouts() {
        var t;
        if(oldBlock) {
          t = oldBlock.data('rsTimeout');
          if(t) {
            if(oldBlock !== animBlock) {
              oldBlock.css({
                  opacity: 0,
                  display: 'none',
                  zIndex: 0
                });
            }
            clearTimeout(t);
            oldBlock.data('rsTimeout', '');
          }
        }

        t = animBlock.data('rsTimeout');
        if(t) {
          clearTimeout(t);
          animBlock.data('rsTimeout', '');
        }
      }
    },
    _stopAnimation: function(noCSS3) {
      var self = this;
      self._isAnimating = false;
      clearTimeout(self.loadingTimeout);
      if(self._isMove) {

        if(!self._useCSS3Transitions) {
          self._slidesContainer.stop(true);
          self._sPosition = parseInt(self._slidesContainer.css(self._xProp), 10);
        } else if (!noCSS3) {
          var oldPos = self._sPosition;
          var newPos =  self._currRenderPosition = self._getTransformProp();
          self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
          if(oldPos !==newPos) {
            self._setPosition(newPos);
          }
        }
      } else {
        // kung fu
        if(self._fadeZIndex > 20) {
          self._fadeZIndex = 10;
        } else {
          self._fadeZIndex++;
        }
      }


    },
    // Thanks to @benpbarnett
    _getTransformProp:function(){
      var self = this,
        transform = window.getComputedStyle(self._slidesContainer.get(0), null).getPropertyValue(self._vendorPref + 'transform'),
        explodedMatrix = transform.replace(/^matrix\(/i, '').split(/, |\)$/g),
        isMatrix3d = (explodedMatrix[0].indexOf('matrix3d') === 0);
      return parseInt(explodedMatrix[(self._slidesHorizontal ? (isMatrix3d ? 12 : 4) : (isMatrix3d ? 13 : 5) )], 10);
    },
    _getCSS3Prop: function(pos, hor) {
      var self = this;
      return self._useCSS3Transitions ? self._tPref1 + ( hor ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 : pos;
    },
    _animationComplete: function(dir) {
      var self = this;
      if(!self._isMove) {
        self._currHolder.css('z-index', 0);
        self._fadeZIndex = 10;
      }
      self._isAnimating = false;

      self.staticSlideId = self.currSlideId;
      self._updateBlocksContent();


      self._slidesMoved = false;

      self.ev.trigger('rsAfterSlideChange');
    },
    _doBackAndForthAnim:function(type, userAction) {
      var self = this,
        newPos = (-self._realId - self._idOffset) * self._slideSize;

      if(self.numSlides === 0 || self._isAnimating) {
        return;
      }
      if(self.st.loopRewind) {
        self.goTo(type === 'left' ? self.numSlides - 1 : 0, userAction);
        return;
      }

      if(self._isMove) {
        self._currAnimSpeed = 200;

        var allAnimComplete = function () {
          self._isAnimating = false;
        };
        var firstAnimComplete = function () {
          self._isAnimating = false;
          self._animateTo(newPos, '', false, true, allAnimComplete);
        };
        self._animateTo(newPos + (type === 'left' ? 30 : -30),'', false, true, firstAnimComplete);
      }

    },
    _resizeImage:function(slideObject, useClone) {

      var isRoot = true;
      if(slideObject.isRendered) {
        return;
      }
      var img = slideObject.content;
      var classToFind = 'rsMainSlideImage';
      var isVideo;
      var self = this,
        imgAlignCenter = self.st.imageAlignCenter,
        imgScaleMode = self.st.imageScaleMode,
        tempEl,
        bMargin;

      if(slideObject.videoURL) {
        classToFind = 'rsVideoContainer';
        if(imgScaleMode !== 'fill') {
          isVideo = true;
        } else {
          tempEl = img;
          if(!tempEl.hasClass(classToFind)) {
            tempEl = tempEl.find('.'+classToFind);
          }
          tempEl.css({width:'100%',height: '100%'});
          classToFind = 'rsMainSlideImage';
        }
      }
      if(!img.hasClass(classToFind)) {
        isRoot = false;
        img = img.find('.'+classToFind);
      }
      if(!img) {
        return;
      }

      var baseImageWidth = slideObject.iW,
        baseImageHeight = slideObject.iH;

      slideObject.isRendered = true;
      if(imgScaleMode === 'none' && !imgAlignCenter) {
        return;
      }
      if(imgScaleMode !== 'fill') {
        bMargin = self._imagePadding;
      } else {
        bMargin = 0;
      }
      //var block = img.parent('.block-inside').css('margin', bMargin);
      var containerWidth = self._wrapWidth - bMargin * 2,
        containerHeight = self._wrapHeight - bMargin * 2,
        hRatio,
        vRatio,
        ratio,
        nWidth,
        nHeight,
        cssObj = {};

      if(imgScaleMode === 'fit-if-smaller') {
        if(baseImageWidth > containerWidth || baseImageHeight > containerHeight) {
          imgScaleMode = 'fit';
        }
      }
      if(imgScaleMode === 'fill' || imgScaleMode === 'fit') {
        hRatio = containerWidth / baseImageWidth;
        vRatio = containerHeight / baseImageHeight;

        if (imgScaleMode  == "fill") {
          ratio = hRatio > vRatio ? hRatio : vRatio;
        } else if (imgScaleMode  == "fit") {
          ratio = hRatio < vRatio ? hRatio : vRatio;
        } else {
          ratio = 1;
        }

        nWidth = Math.ceil(baseImageWidth * ratio, 10);
        nHeight = Math.ceil(baseImageHeight * ratio, 10);
      } else {
        nWidth = baseImageWidth;
        nHeight = baseImageHeight;
      }
      if(imgScaleMode !== 'none') {
        cssObj.width = nWidth;
        cssObj.height = nHeight;
        if(isVideo) {
          img.find('.rsImg').css({width: '100%', height:'100%'});
        }
      }
      if (imgAlignCenter) {
        cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) +  bMargin;
        cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) +  bMargin;
      }
      img.css(cssObj);
    }
  }; /* RoyalSlider core prototype end */
  $.rsProto = RoyalSlider.prototype;

  $.fn.royalSlider = function(options) {
    var args = arguments;
    return this.each(function(){
      var self = $(this);
      if (typeof options === "object" ||  !options) {
        if( !self.data('royalSlider') ) {
          self.data('royalSlider', new RoyalSlider(self, options));
        }
      } else {
        var royalSlider = self.data('royalSlider');
        if (royalSlider && royalSlider[options]) {
          return royalSlider[options].apply(royalSlider, Array.prototype.slice.call(args, 1));
        }
      }
    });
  };

  $.fn.royalSlider.defaults = {
    slidesSpacing: 8,
    startSlideId: 0,
    loop: false,
    loopRewind: false,
    numImagesToPreload: 4,
    fadeinLoadedSlide: true,
    slidesOrientation: 'horizontal',
    transitionType: 'move',
    transitionSpeed: 600,
    controlNavigation: 'bullets',
    controlsInside: true,
    arrowsNav: true,
    arrowsNavAutoHide: true,
    navigateByClick: true,
    randomizeSlides: false,
    sliderDrag: true,
    sliderTouch: true,
    keyboardNavEnabled: false,
    fadeInAfterLoaded: true,

    allowCSS3: true,
    allowCSS3OnWebkit: true,


    addActiveClass: false,
    autoHeight: false,

    easeOut: 'easeOutSine',
    easeInOut: 'easeInOutSine',

    minSlideOffset: 10,

    imageScaleMode:"fit-if-smaller",
    imageAlignCenter:true,
    imageScalePadding: 4,
    usePreloader: true,

    autoScaleSlider: false,

    autoScaleSliderWidth: 800,
    autoScaleSliderHeight: 400,

    autoScaleHeight: true,

    arrowsNavHideOnTouch: false,
    globalCaption: false,

    slidesDiff: 2,
    preloaderHTML: '<div class="rsPreloader"></div>'
  }; /* default options end */

  if (navigator.userAgent.toLowerCase().match(/(ipad)/)) {
    $.rsCSS3Easing = {
      easeOutSine: 'cubic-bezier(0.000, 1.000, 0.000, 1.000)',
      easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
    };
  } else {
    $.rsCSS3Easing = {
      easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
      easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
    };
  }

  $.extend(jQuery.easing, {
    easeInOutSine: function (x, t, b, c, d) {
      return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
    },
    easeOutSine: function (x, t, b, c, d) {
      return c * Math.sin(t/d * (Math.PI/2)) + b;
    },
    easeOutCubic: function (x, t, b, c, d) {
      return c*((t=t/d-1)*t*t + 1) + b;
    }
  });


})(jQuery, window);

(function($) {

  "use strict";

  /**
   *
   * RoyalSlider active class module
   * @version 1.0.1:
   *
   * 1.0.1
   * - Simplified code
   * - Fixed bug when slide with activeClass is removed
   */
  $.rsProto._initActiveClass = function() {
    var updClassTimeout,
      self = this,
      aSlideClass = 'rsActiveSlide';
    if(self.st.addActiveClass) {

      self.ev.on('rsOnUpdateNav', function() {

        if(updClassTimeout) clearTimeout(updClassTimeout);
        updClassTimeout = setTimeout(function() {
          if(self._oldHolder) self._oldHolder.removeClass(aSlideClass);
          if(self._currHolder) self._currHolder.addClass(aSlideClass);
          updClassTimeout = null;
        }, 50);
      });

    }
  };
  $.rsModules.activeClass = $.rsProto._initActiveClass;
})(jQuery);


(function($) {

  "use strict";

  /**
   *
   * RoyalSlider animated blocks module
   * @version 1.0.7:
   *
   * 1.0.2:
   * - Fixed mistake from prev fix :/
   *
   * 1.0.3:
   * - Fixed animated block appearing in Firefox
   *
   * 1.0.4
   * - Fixed bug that could cause incorrect block when randomizeSlides is enabled
   *
   * 1.0.5
   * - moveEffect:none' bug
   *
   * 1.0.6
   * - Fixed issue that could cause incorrect position of blocks in IE
   *
   * 1.0.7
   * - Move offset fix
   */
  $.extend($.rsProto, {
    _initAnimatedBlocks: function() {
      var self = this,
        i;

      self._blockDefaults = {
        fadeEffect: true,
        moveEffect: 'top',
        moveOffset:20,
        speed:400,
        easing:'easeOutSine',
        delay:200
      };
      self.st.block = $.extend({}, self._blockDefaults, self.st.block);

      self._blockAnimProps = [];
      self._animatedBlockTimeouts = [];

      self.ev.on('rsAfterInit', function() {
        runBlocks();
      });

      self.ev.on('rsBeforeParseNode', function(e, content, obj) {
        content = $(content);

        obj.animBlocks = content.find('.rsABlock').css('display', 'none');
        if(!obj.animBlocks.length) {
          if(content.hasClass('rsABlock')) {
            obj.animBlocks = content.css('display', 'none');
          } else {
            obj.animBlocks = false;
          }
        }
      });
      self.ev.on('rsAfterContentSet', function(e, slideObject) {
        var currId = self.slides[self.currSlideId].id;
        if(slideObject.id === currId) {
          setTimeout(function() {
            runBlocks();
          }, self.st.fadeinLoadedSlide ? 300 : 0);
        }
      });

      self.ev.on('rsAfterSlideChange', function() {
        runBlocks();
      });
      function runBlocks() {
        var slide = self.currSlide;
        if(!self.currSlide || !self.currSlide.isLoaded) {
          return;
        }

        // clear previous animations
        if(self._slideWithBlocks !== slide) {
          if(self._animatedBlockTimeouts.length > 0) {
            for(i = 0; i < self._animatedBlockTimeouts.length; i++) {
              clearTimeout(self._animatedBlockTimeouts[i]);
            }
            self._animatedBlockTimeouts = [];
          }

          if(self._blockAnimProps.length > 0) {
            var cItemTemp;
            for(i = 0; i < self._blockAnimProps.length; i++) {
              cItemTemp = self._blockAnimProps[i];
              if(cItemTemp) {
                if(!self._useCSS3Transitions) {
                  cItemTemp.block.stop(true).css(cItemTemp.css);
                } else {
                  cItemTemp.block.css(self._vendorPref + self._TD, '0s');
                  cItemTemp.block.css(cItemTemp.css);
                }
                self._slideWithBlocks = null;
                slide.animBlocksDisplayed = false;
              }
            }
            self._blockAnimProps = [];
          }
          if(slide.animBlocks) {
            slide.animBlocksDisplayed = true;
            self._slideWithBlocks = slide;
            self._animateBlocks(slide.animBlocks);
          }
        }
      }
    },
    _updateAnimBlockProps: function(obj, props) {
      setTimeout(function() {
        obj.css(props);
      }, 6);
    },
    _animateBlocks: function(animBlocks) {
      var self = this,
        item,
        animObj,
        newPropObj,
        transitionData;

      var currItem,
        fadeEnabled,
        moveEnabled,
        effectName,
        effectsObject,
        moveEffectProperty,
        currEffects,
        newEffectObj,
        moveOffset,
        delay,
        speed,
        easing,
        moveProp,
        i,
        moveEffect,
        isOppositeProp;

      self._animatedBlockTimeouts = [];

      animBlocks.each(function(index) {

        item = $(this);


        animObj = {};
        newPropObj = {};
        transitionData = null;

          var moveOffset = item.attr('data-move-offset');
          if(!moveOffset) {
            moveOffset = self.st.block.moveOffset;
          } else {
            moveOffset = parseInt(moveOffset, 10);
          }

          if(moveOffset > 0) {
            moveEffect = item.data('move-effect');
            if(moveEffect) {
              moveEffect = moveEffect.toLowerCase();
              if(moveEffect === 'none') {
                moveEffect = false;
              } else if(moveEffect !== 'left' && moveEffect !== 'top' && moveEffect !== 'bottom' && moveEffect !== 'right') {
                moveEffect = self.st.block.moveEffect;
                if(moveEffect === 'none') {
                  moveEffect = false;
                }
              }
            } else {
              moveEffect = self.st.block.moveEffect;
            }
            if(moveEffect && moveEffect !== 'none') {
              var moveHorizontal;
              if(moveEffect === 'right' || moveEffect === 'left') {
                moveHorizontal = true;
              } else {
                moveHorizontal = false;
              }
              var currPos,
                startPos;

              isOppositeProp = false;

              if(self._useCSS3Transitions) {
                currPos = 0;
                moveProp = self._xProp;
              } else {
                if(moveHorizontal) {
                  if( !isNaN( parseInt(item.css('right'), 10) ) ) {
                    moveProp = 'right';
                    isOppositeProp = true;
                  } else {
                    moveProp = 'left';
                  }
                } else {

                  if( !isNaN( parseInt(item.css('bottom'), 10) ) ) {
                    moveProp = 'bottom';
                    isOppositeProp = true;
                  } else {
                    moveProp = 'top';
                  }
                }
                moveProp = 'margin-'+moveProp;
                if(isOppositeProp) {
                  moveOffset = -moveOffset;
                }

                if(!self._useCSS3Transitions) {
                  currPos = item.data('rs-start-move-prop');

                  if( currPos === undefined ) {
                    currPos = parseInt(item.css(moveProp), 10);

                    if(isNaN(currPos)) currPos = 0;

                    item.data('rs-start-move-prop', currPos);
                  }
                } else {
                  currPos = parseInt(item.css(moveProp), 10);
                }


              }

              if(moveEffect === 'top' || moveEffect === 'left') {
                startPos = currPos - moveOffset;
              } else {
                startPos = currPos + moveOffset;
              }

              newPropObj[moveProp] = self._getCSS3Prop(startPos, moveHorizontal);
              animObj[moveProp] = self._getCSS3Prop(currPos, moveHorizontal);

            }
          }


          var fadeEffect = item.attr('data-fade-effect');
          if(!fadeEffect) {
            fadeEffect = self.st.block.fadeEffect;
          } else if(fadeEffect.toLowerCase() === 'none' || fadeEffect.toLowerCase() === 'false') {
            fadeEffect = false;
          }
          if(fadeEffect) {
            newPropObj.opacity = 0;
            animObj.opacity = 1;
          }

          if(fadeEffect || moveEffect) {
            transitionData = {};
            transitionData.hasFade = Boolean(fadeEffect);
            if(Boolean(moveEffect)) {
              transitionData.moveProp = moveProp;
              transitionData.hasMove = true;
            }

            transitionData.speed = item.data('speed');
            if(isNaN(transitionData.speed)) {
              transitionData.speed = self.st.block.speed;
            }
            transitionData.easing = item.data('easing');
            if(!transitionData.easing) {
              transitionData.easing = self.st.block.easing;
            }
            transitionData.css3Easing = $.rsCSS3Easing[transitionData.easing];

            transitionData.delay =  item.data('delay');
            if(isNaN(transitionData.delay)) {
              transitionData.delay = self.st.block.delay * index;
            }

          }

          var blockPropsObj = {};
          if(self._useCSS3Transitions) {
            blockPropsObj[(self._vendorPref + self._TD)] =  '0ms';
          }
          blockPropsObj.moveProp = animObj.moveProp;
          blockPropsObj.opacity = animObj.opacity;
          blockPropsObj.display = 'none';


          self._blockAnimProps.push({block:item, css:blockPropsObj});

          self._updateAnimBlockProps(item, newPropObj);


          // animate caption
          self._animatedBlockTimeouts.push(setTimeout((function (cItem, animateData, transitionData, index) {
            return function() {
              cItem.css('display', 'block');
              if(transitionData) {
                var animObj = {};
                if(!self._useCSS3Transitions) {
                  setTimeout(function() {
                    cItem.animate(animateData, transitionData.speed, transitionData.easing);
                  }, 16);
                } else {
                  var prop = '';
                  if(transitionData.hasMove) {
                    prop += transitionData.moveProp;
                  }
                  if(transitionData.hasFade) {
                    if(transitionData.hasMove) {
                      prop += ', ';
                    }
                    prop += 'opacity';
                  }
                  animObj[(self._vendorPref + self._TP)] = prop;
                  animObj[(self._vendorPref + self._TD)] =  transitionData.speed + 'ms';
                  animObj[(self._vendorPref + self._TTF)] = transitionData.css3Easing;
                  cItem.css(animObj);
                  setTimeout(function() {
                    cItem.css(animateData);
                  }, 24);
                }
              }

              delete self._animatedBlockTimeouts[index];
            };
          })(item, animObj, transitionData, index), transitionData.delay <= 6 ? 12 : transitionData.delay));
        //}



      });
    }
  });
  $.rsModules.animatedBlocks = $.rsProto._initAnimatedBlocks;
})(jQuery);


(function($) {

  "use strict";

  /**
   *
   * RoyalSlider auto height module
   * @version 1.0.3:
   *
   * 1.0.2
   * - Changed "on" to "one" in afterInit event listener
   * - Removed id="clear"
   *
   * 1.0.3
   * - added rsAutoHeightChange event
   * - added minAutoHeight
   * - transition is now enabled only after first height
   */
  $.extend($.rsProto, {
    _initAutoHeight: function() {
      var self = this;
      if(self.st.autoHeight) {
        var holder,
          tH,
          currSlide,
          currHeight,
          firstTime = true,
          updHeight = function(animate) {
            currSlide = self.slides[self.currSlideId];
            holder = currSlide.holder;

            if(holder) {
              tH = holder.height();
              if(tH && tH !== currHeight && tH > (self.st.minAutoHeight || 30) ) {
                self._wrapHeight = tH;
                if(self._useCSS3Transitions || !animate) {
                  self._sliderOverflow.css('height', tH);
                } else {
                  self._sliderOverflow.stop(true,true).animate({height: tH}, self.st.transitionSpeed);
                }

                self.ev.trigger('rsAutoHeightChange', tH);

                // Apply CSS transitons
                if(firstTime) {
                  if(self._useCSS3Transitions) {
                    // force reflow
                    setTimeout(function() {
                      self._sliderOverflow.css(self._vendorPref + 'transition', 'height ' + self.st.transitionSpeed + 'ms ease-in-out');
                    },16);
                  }
                  firstTime = false;
                }
              }
            }
          };

        self.ev.on('rsMaybeSizeReady.rsAutoHeight', function(e, slideObject) {
          if(currSlide === slideObject) {
            updHeight();
          }
        });

        self.ev.on('rsAfterContentSet.rsAutoHeight', function(e, slideObject) {
          if(currSlide === slideObject) {
            updHeight();
          }
        });



        self.slider.addClass('rsAutoHeight');
        self.ev.one('rsAfterInit', function() {
          setTimeout(function() {
            updHeight(false);
            setTimeout(function() {
              self.slider.append('<div style="clear:both; float: none;"></div>');
            }, 16);
          }, 16);
        });
        self.ev.on('rsBeforeAnimStart', function() {
          updHeight(true);
        });
        self.ev.on('rsBeforeSizeSet' , function() {
          setTimeout(function() {
            updHeight(false);
          }, 16);
        });
      }

    }
  });
  $.rsModules.autoHeight = $.rsProto._initAutoHeight;
})(jQuery);


(function($) {

  "use strict";

  /**
   *
   * RoyalSlider auto play module
   * @version 1.0.5:
   *
   * 1.0.3:
   * - added support for 'autoplay' property name.
   *
   * 1.0.4
   * - added toggleAutoPlay public method
   *
   * 1.0.5
   * - Fixed issue when autoPlay may not pause when switching browser tabs
   */
  $.extend($.rsProto, {
    _initAutoplay: function() {
      var self = this,
        del;

      self._autoPlayDefaults = {
        enabled: false,
        stopAtAction: true,
        pauseOnHover: true,
        delay: 2000
      };

      // fix deprecated name
      if(!self.st.autoPlay && self.st.autoplay) {
        self.st.autoPlay = self.st.autoplay;
      }
      self.st.autoPlay = $.extend({}, self._autoPlayDefaults, self.st.autoPlay);

      if(self.st.autoPlay.enabled) {
        self.ev.on('rsBeforeParseNode', function(e, content, obj) {
          content = $(content);
          del = content.attr('data-rsDelay');
          if(del) {
            obj.customDelay = parseInt(del, 10);
          }
        });
        self.ev.one('rsAfterInit', function() {
          self._setupAutoPlay();
        });
        self.ev.on('rsBeforeDestroy', function() {
          self.stopAutoPlay();
          self.slider.off('mouseenter mouseleave');
          $(window).off('blur'+self.ns + ' focus' + self.ns);
        });

      }
    },
    _setupAutoPlay: function() {
      var self = this;

      self.startAutoPlay();

      self.ev.on('rsAfterContentSet', function(e, slideObject) {
        if(!self._isDragging && !self._isAnimating && self._autoPlayEnabled && slideObject === self.currSlide ) {
          self._play();
        }
      });
      self.ev.on('rsDragRelease', function() {
        if(self._autoPlayEnabled && self._autoPlayPaused) {
          self._autoPlayPaused = false;
          self._play();
        }
      });
      self.ev.on('rsAfterSlideChange', function() {
        if(self._autoPlayEnabled) {
          if(self._autoPlayPaused) {
            self._autoPlayPaused = false;

            if(self.currSlide.isLoaded) {
              self._play();
            }
          }
        }
      });
      self.ev.on('rsDragStart', function() {
        if(self._autoPlayEnabled) {
          if(self.st.autoPlay.stopAtAction) {
            self.stopAutoPlay();
          } else {
            self._autoPlayPaused = true;
            self._pause();
          }
        }
      });
      self.ev.on('rsBeforeMove', function(e, type, userAction) {
        if(self._autoPlayEnabled) {
          if(userAction && self.st.autoPlay.stopAtAction) {
            self.stopAutoPlay();
          } else {
            self._autoPlayPaused = true;
            self._pause();
          }
        }
      });

      self._pausedByVideo = false;
      self.ev.on('rsVideoStop', function() {
        if(self._autoPlayEnabled) {
          self._pausedByVideo = false;
          self._play();
        }
      });
      self.ev.on('rsVideoPlay', function() {
        if(self._autoPlayEnabled) {
          self._autoPlayPaused = false;
          self._pause();
          self._pausedByVideo = true;
        }
      });

      $(window).on('blur'+self.ns, function(){
        if(self._autoPlayEnabled) {
          self._autoPlayPaused = true;
          self._pause();
        }
      }).on('focus'+self.ns, function(){
        if(self._autoPlayEnabled && self._autoPlayPaused) {
          self._autoPlayPaused = false;
          self._play();
        }
      });

      if(self.st.autoPlay.pauseOnHover) {
        self._pausedByHover = false;
        self.slider.hover(
          function() {
            if(self._autoPlayEnabled) {
              self._autoPlayPaused = false;
              self._pause();
              self._pausedByHover = true;
            }
          },
          function() {
            if(self._autoPlayEnabled) {
              self._pausedByHover = false;
              self._play();
            }
          }
        );
      }

    },
    toggleAutoPlay: function() {
      var self = this;
      if(self._autoPlayEnabled) {
        self.stopAutoPlay();
      } else {
        self.startAutoPlay();
      }
    },
    startAutoPlay: function() {
      var self = this;
      self._autoPlayEnabled = true;
      if(self.currSlide.isLoaded) {
        self._play();
      }
    },
    stopAutoPlay: function() {
      var self = this;
      self._pausedByVideo = self._pausedByHover = self._autoPlayPaused = self._autoPlayEnabled = false;
      self._pause();
    },
    _play: function() {
      var self = this;
      if(!self._pausedByHover && !self._pausedByVideo) {
        self._autoPlayRunning = true;
        if(self._autoPlayTimeout) {
          clearTimeout(self._autoPlayTimeout);
        }
        self._autoPlayTimeout = setTimeout(function() {
          var changed;
          if(!self._loop && !self.st.loopRewind) {
            changed = true;
            self.st.loopRewind = true;
          }
          self.next(true);
          if(changed) {
            changed = false;
            self.st.loopRewind = false;
          }
        }, !self.currSlide.customDelay ? self.st.autoPlay.delay : self.currSlide.customDelay);
      }

    },
    _pause: function() {
      var self = this;
      if(!self._pausedByHover && !self._pausedByVideo) {
        self._autoPlayRunning = false;
        if(self._autoPlayTimeout) {
          clearTimeout(self._autoPlayTimeout);
          self._autoPlayTimeout = null;
        }
      }
    }
  });
  $.rsModules.autoplay = $.rsProto._initAutoplay;
})(jQuery);



(function($) {

  "use strict";

  /**
   *
   * RoyalSlider bullets module
   * @version 1.0.1:
   *
   * 1.0.1
   * - Minor optimizations
   *
   */
  $.extend($.rsProto, {
    _initBullets: function() {
      var self = this;
      if(self.st.controlNavigation === 'bullets') {
        var itemHTML = '<div class="rsNavItem rsBullet"><span></span></div>';
        self.ev.one('rsAfterPropsSetup', function() {

          self._controlNavEnabled = true;
          self.slider.addClass('rsWithBullets');
          var out = '<div class="rsNav rsBullets">';
          for(var i = 0; i < self.numSlides; i++) {
            out += itemHTML;
          }
          self._controlNav = out = $(out + '</div>');
          self._controlNavItems = out.appendTo(self.slider).children();

          self._controlNav.on('click.rs','.rsNavItem',function(e) {
            if(!self._thumbsDrag ) {
              self.goTo( $(this).index() );
            }
          });
        });

        self.ev.on('rsOnAppendSlide', function(e, parsedSlide, index) {
          if(index >= self.numSlides) {
            self._controlNav.append(itemHTML);
          } else {
            self._controlNavItems.eq(index).before(itemHTML);
          }
          self._controlNavItems = self._controlNav.children();
        });
        self.ev.on('rsOnRemoveSlide', function(e, index) {
          var itemToRemove = self._controlNavItems.eq(index);
          if(itemToRemove && itemToRemove.length) {
            itemToRemove.remove();
            self._controlNavItems = self._controlNav.children();
          }

        });

        self.ev.on('rsOnUpdateNav', function() {
          var id = self.currSlideId,
            currItem,
            prevItem;
          if(self._prevNavItem) {
            self._prevNavItem.removeClass('rsNavSelected');
          }
          currItem = self._controlNavItems.eq(id);

          currItem.addClass('rsNavSelected');
          self._prevNavItem = currItem;
        });
      }
    }
  });
  $.rsModules.bullets = $.rsProto._initBullets;
})(jQuery);



(function($) {

  "use strict";

  /**
   *
   * RoyalSlider Deep Linking Module
   * @version 1.0.6 + jQuery hashchange plugin v1.3 Copyright (c) 2010 Ben Alman:
   *
   * 1.0.1:
   * - Added timeout before hash changes to 750ms to avoid reloading animation.
   *
   * 1.0.2:
   * - Added multiple slider with hash support
   *
   * 1.0.3
   * - Removed hashchange listener on destroy()
   *
   * 1.0.4
   * - Decreased timeout from 750 to 400ms
   *
   * 1.0.5
   * - History state is now replaced instead of pushing to avoid back button confusion
   * - jQuery 1.9.0 compability
   *
   * 1.0.6
   * - Namespaced hashchange event
   *
   * 1.0.7
   * - Multiple sliders on one page
   */
  $.extend($.rsProto, {
    _initDeeplinking: function() {
      var self = this,
        isBlocked,
        hashTimeout,
        hashChangeTimeout;

      self._hashDefaults = {
        enabled: false,
        change: false,
        prefix: ''
      };

      self.st.deeplinking = $.extend({}, self._hashDefaults, self.st.deeplinking);

      if(self.st.deeplinking.enabled) {

        var hashChange = self.st.deeplinking.change,
            pText = self.st.deeplinking.prefix,
            prefix = '#' + pText,
            getSlideIdByHash = function() {
              var hash = window.location.hash;
              if(hash && hash.indexOf(pText) > 0) {
                hash = parseInt( hash.substring(prefix.length), 10 );
                if(hash >= 0) {
                  return hash - 1;
                }
              }
              return -1;
            };


        var id = getSlideIdByHash();
        if(id !== -1) {
          self.st.startSlideId = id;
        }

        if(hashChange) {
          $(window).on('hashchange'+self.ns, function(e){
            if(!isBlocked) {
              var id = getSlideIdByHash();
              if(id < 0) {
                return;
              }
              if(id > self.numSlides - 1)
                id = self.numSlides - 1;
              self.goTo( id );
            }
          });
          self.ev.on('rsBeforeAnimStart', function() {
            if(hashTimeout) {
              clearTimeout(hashTimeout);
            }
            if(hashChangeTimeout) {
              clearTimeout(hashChangeTimeout);
            }
          });

          self.ev.on('rsAfterSlideChange', function() {
            if(hashTimeout) {
              clearTimeout(hashTimeout);
            }
            if(hashChangeTimeout) {
              clearTimeout(hashChangeTimeout);
            }
            hashChangeTimeout = setTimeout(function() {
              isBlocked = true;
              window.location.replace( (''+window.location).split('#')[0] + prefix + (self.currSlideId + 1) );
              hashTimeout = setTimeout(function() {
                isBlocked = false;
                hashTimeout = null;
              }, 60);
            }, 400);

          });
        }
        self.ev.on('rsBeforeDestroy', function() {
          hashChangeTimeout = null;
          hashTimeout = null;
          if(hashChange) {
            $(window).off('hashchange' + self.ns);
          }
        });

      }
    }
  });
  $.rsModules.deeplinking = $.rsProto._initDeeplinking;
})(jQuery);

/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.

  // Reused string.
  var str_hashchange = 'hashchange',

    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,

    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );

  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };

  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };

  $.fn[ str_hashchange ].delay = 50;

  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {

    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }

      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },

    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }

      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }

  });

  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,

      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),

      fn_retval = function(val){ return val; },
      history_set = fn_retval,
      history_get = fn_retval;

    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };

    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };

    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );

      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );

        $(window).trigger( str_hashchange );

      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }

      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };

    window.attachEvent && !window.addEventListener && !supports_onhashchange && (function(){
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.

      var iframe,
        iframe_src;

      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function(){
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();

          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()

            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function(){
              iframe_src || history_set( get_fragment() );
              poll();
            })

            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )

            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;

          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function(){
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };

        }
      };

      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;

      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };

      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;

        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;

          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();

          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '<script>document.domain="' + domain + '"</script>' );

          iframe_doc.close();

          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };

    })();

    return self;
  })();

})(jQuery,this);




(function($) {

  "use strict";

  /**
   *
   * RoyalSlider fullscreen module
   * @version 1.0.5:
   *
   * 1.0.1:
   * - Added rsEnterFullscreen and rsExitFullscreen events
   *
   * 1.0.2
   * - Added window scroll detection
   *
   * 1.0.3
   * - Fullscreen button now is added to _controlsContainer element
   *
   * 1.0.4
   * - Fixed issue that could cause small image be loaded in fullscreen
   *
   * 1.0.5
   * - Fix "false" native fullscreen on Android
   *
   */
  $.extend($.rsProto, {
    _initFullscreen: function() {
      var self = this;

      self._fullscreenDefaults = {
        enabled: false,
        keyboardNav: true,
        buttonFS: true,
        nativeFS: false,
        doubleTap: true
      };
      self.st.fullscreen = $.extend({}, self._fullscreenDefaults, self.st.fullscreen);

      if(self.st.fullscreen.enabled) {
        self.ev.one('rsBeforeSizeSet', function() {
          self._setupFullscreen();
        });
      }
    },
    _setupFullscreen: function() {
      var self = this;
      self._fsKeyboard = (!self.st.keyboardNavEnabled && self.st.fullscreen.keyboardNav);

      if(self.st.fullscreen.nativeFS) {
        // Thanks to John Dyer http://j.hn/
        self._fullScreenApi = {
          supportsFullScreen: false,
          isFullScreen: function() { return false; },
          requestFullScreen: function() {},
          cancelFullScreen: function() {},
          fullScreenEventName: '',
          prefix: ''
        };

        var browserPrefixes = 'webkit moz o ms khtml'.split(' ');
        // check for native support
        if(!self.isAndroid) {
          if (typeof document.cancelFullScreen != 'undefined') {
            self._fullScreenApi.supportsFullScreen = true;
          } else {
            // check for fullscreen support by vendor prefix
            for (var i = 0; i < browserPrefixes.length; i++ ) {
              self._fullScreenApi.prefix = browserPrefixes[i];
              if (typeof document[ self._fullScreenApi.prefix + 'CancelFullScreen' ] != 'undefined' ) {
                self._fullScreenApi.supportsFullScreen = true;
                break;
              }
            }
          }
        }

        // update methods to do something useful
        if ( self._fullScreenApi.supportsFullScreen) {
          self.nativeFS = true;
          self._fullScreenApi.fullScreenEventName =  self._fullScreenApi.prefix + 'fullscreenchange' + self.ns;

          self._fullScreenApi.isFullScreen = function() {
            switch (this.prefix) {
              case '':
                return document.fullScreen;
              case 'webkit':
                return document.webkitIsFullScreen;
              default:
                return document[this.prefix + 'FullScreen'];
            }
          };
          self._fullScreenApi.requestFullScreen = function(el) {
            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
          };
          self._fullScreenApi.cancelFullScreen = function(el) {
            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
          };
        } else {
          self._fullScreenApi = false;
        }
      }


      if(self.st.fullscreen.buttonFS) {
        self._fsBtn = $('<div class="rsFullscreenBtn"><div class="rsFullscreenIcn"></div></div>')
          .appendTo(self._controlsContainer)
          .on('click.rs', function() {
            if(self.isFullscreen) {
              self.exitFullscreen();
            } else {

              self.enterFullscreen();
            }
          });
      }
    },
    enterFullscreen: function(preventNative) {
      var self = this;
      if( self._fullScreenApi ) {
        if(!preventNative) {
          self._doc.on( self._fullScreenApi.fullScreenEventName, function(e) {
            if(!self._fullScreenApi.isFullScreen()) {
              self.exitFullscreen(true);
            } else {
              self.enterFullscreen(true);
            }
          });
          self._fullScreenApi.requestFullScreen($('html')[0]);
          return;
        } else {
          self._fullScreenApi.requestFullScreen($('html')[0]);
        }
      }

      if(self._isFullscreenUpdating) {
        return;
      }
      self._isFullscreenUpdating = true;

      self._doc.on('keyup' + self.ns + 'fullscreen', function(e) {
        if(e.keyCode === 27) {
          self.exitFullscreen();
        }
      });
      if(self._fsKeyboard) {
        self._bindKeyboardNav();
      }

      var win = $(window);
      self._fsScrollTopOnEnter = win.scrollTop();
      self._fsScrollLeftOnEnter = win.scrollLeft();

      self._htmlStyle = $('html').attr('style');
      self._bodyStyle = $('body').attr('style');
      self._sliderStyle = self.slider.attr('style');

      $('body, html').css({
        overflow: 'hidden',
        height: '100%',
        width: '100%',
        margin: '0',
        padding: '0'
      });

      self.slider.addClass('rsFullscreen');


      var item,
        i;
      for(i = 0; i < self.numSlides; i++) {
        item = self.slides[i];

        item.isRendered = false;
        if(item.bigImage) {
          item.isBig = true;
          item.isMedLoaded = item.isLoaded;
          item.isMedLoading = item.isLoading;
          item.medImage = item.image;
          item.medIW = item.iW;
          item.medIH = item.iH;
          item.slideId = -99;

          if(item.bigImage !== item.medImage) {
            item.sizeType = 'big';
          }

          item.isLoaded = item.isBigLoaded;
          item.isLoading = false;
          item.image = item.bigImage;
          item.images[0] = item.bigImage;
          item.iW = item.bigIW;
          item.iH = item.bigIH;

          item.isAppended = item.contentAdded = false;
          self._updateItemSrc(item);
        }

      }


      self.isFullscreen = true;

      self._isFullscreenUpdating = false;
      self.updateSliderSize();
      self.ev.trigger('rsEnterFullscreen');

    },
    exitFullscreen: function(preventNative) {
      var self = this;

      if( self._fullScreenApi ) {
        if(!preventNative) {
          self._fullScreenApi.cancelFullScreen($('html')[0]);
          return;
        }
        self._doc.off( self._fullScreenApi.fullScreenEventName );
      }
      if(self._isFullscreenUpdating) {
        return;
      }
      self._isFullscreenUpdating = true;

      self._doc.off('keyup'  + self.ns + 'fullscreen');
      if(self._fsKeyboard) {
        self._doc.off('keydown' + self.ns);
      }

      $('html').attr('style', self._htmlStyle || '');
      $('body').attr('style', self._bodyStyle || '');



      var item,
        i;
      for(i = 0; i < self.numSlides; i++) {
        item = self.slides[i];


        item.isRendered = false;
        if(item.bigImage) {
          item.isBig = false;
          item.slideId = -99;
          item.isBigLoaded = item.isLoaded;
          item.isBigLoading = item.isLoading;
          item.bigImage = item.image;
          item.bigIW = item.iW;
          item.bigIH = item.iH;
          item.isLoaded = item.isMedLoaded;
          item.isLoading = false;
          item.image = item.medImage;
          item.images[0] = item.medImage;
          item.iW = item.medIW;
          item.iH = item.medIH;

          item.isAppended = item.contentAdded = false;

          self._updateItemSrc(item, true);


          if(item.bigImage !== item.medImage) {
            item.sizeType = 'med';
          }
        }
      }

      self.isFullscreen = false;

      var win = $(window);
      win.scrollTop( self._fsScrollTopOnEnter );
      win.scrollLeft( self._fsScrollLeftOnEnter );

      self._isFullscreenUpdating = false;
      self.slider.removeClass('rsFullscreen');

      self.updateSliderSize();
      // fix overflow bug
      setTimeout(function() {
        self.updateSliderSize();
      },1);
      self.ev.trigger('rsExitFullscreen');
    },
    _updateItemSrc: function(item, exit) {
      var newHTML = (!item.isLoaded && !item.isLoading) ? '<a class="rsImg rsMainSlideImage" href="'+item.image+'"></a>' : '<img class="rsImg rsMainSlideImage" src="'+item.image+'"/>';

      if(item.content.hasClass('rsImg')) {
        item.content = $(newHTML);
      } else {
        item.content.find('.rsImg').eq(0).replaceWith(newHTML);
      }
      if(!item.isLoaded && !item.isLoading && item.holder) {
        item.holder.html(item.content);
      }
    }
  });
  $.rsModules.fullscreen = $.rsProto._initFullscreen;
})(jQuery);





(function($) {

  "use strict";

  /**
   *
   * RoyalSlider global caption module
   * @version 1.0:
   *
   */
  $.extend($.rsProto, {
    _initGlobalCaption: function() {
      var self = this;
      if(self.st.globalCaption) {
        var setCurrCaptionHTML = function () {
          self.globalCaption.html(self.currSlide.caption);
        };
        self.ev.on('rsAfterInit', function() {
          self.globalCaption = $('<div class="rsGCaption"></div>').appendTo( !self.st.globalCaptionInside ? self.slider : self._sliderOverflow );
          setCurrCaptionHTML();
        });
        self.ev.on('rsBeforeAnimStart' , function() {
          setCurrCaptionHTML();
        });
      }
    }
  });
  $.rsModules.globalCaption = $.rsProto._initGlobalCaption;
})(jQuery);




(function($) {

  "use strict";

  /**
   *
   * RoyalSlider auto hide nav module
   * @version 1.0:
   *
   */
  $.extend($.rsProto, {
    _initAutoHideControlNav: function() {
      var self = this;
      if(self.st.navAutoHide && !self.hasTouch) {
        self.ev.one('rsAfterInit', function() {
          if(self._controlNav) {
            self._controlNav.addClass('rsHidden');

            var hoverEl = self.slider;
            hoverEl.one("mousemove.controlnav",function() {
              self._controlNav.removeClass('rsHidden');
            });

            hoverEl.hover(
              function() {
                self._controlNav.removeClass('rsHidden');
              },
              function() {
                self._controlNav.addClass('rsHidden');
              }
            );
          }

        });
      }
    }
  });
  $.rsModules.autoHideNav = $.rsProto._initAutoHideControlNav;
})(jQuery);




(function($) {

  "use strict";

  /**
   *
   * RoyalSlider tabs module
   * @version 1.0.2:
   *
   * 1.0.1:
   * - Dynamic adding/removing tabs.
   *
   * 1.0.2
   * - jQuery 1.9.0 compability
   */
  $.extend($.rsProto, {
    _initTabs: function() {
      var self = this;
      if(self.st.controlNavigation === 'tabs') {
        self.ev.on('rsBeforeParseNode', function(e, content, obj) {
          content = $(content);
          obj.thumbnail = content.find('.rsTmb').remove();
          if(!obj.thumbnail.length) {

            obj.thumbnail = content.attr('data-rsTmb');
            if(!obj.thumbnail) {
              obj.thumbnail = content.find('.rsImg').attr('data-rsTmb');
            }
            if(!obj.thumbnail) {
              obj.thumbnail = '';
            } else {
              obj.thumbnail = '<img src="'+obj.thumbnail+'"/>';
            }
          } else {
            obj.thumbnail = $(document.createElement('div')).append(obj.thumbnail).html();
          }
        });

        self.ev.one('rsAfterPropsSetup', function() {
          self._createTabs();
        });

        self.ev.on('rsOnAppendSlide', function(e, parsedSlide, index) {
          if(index >= self.numSlides) {
            self._controlNav.append('<div class="rsNavItem rsTab">' + parsedSlide.thumbnail + '</div>');
          } else {
            self._controlNavItems.eq(index).before('<div class="rsNavItem rsTab">' + item.thumbnail + '</div>');
          }
          self._controlNavItems = self._controlNav.children();
        });
        self.ev.on('rsOnRemoveSlide', function(e, index) {
          var itemToRemove = self._controlNavItems.eq(index);
          if(itemToRemove) {
            itemToRemove.remove();
            self._controlNavItems = self._controlNav.children();
          }
        });

        self.ev.on('rsOnUpdateNav', function() {
          var id = self.currSlideId,
            currItem,
            prevItem;
          if(self._prevNavItem) {
            self._prevNavItem.removeClass('rsNavSelected');
          }

          currItem = self._controlNavItems.eq(id);

          currItem.addClass('rsNavSelected');
          self._prevNavItem = currItem;
        });
      }

    },
    _createTabs: function() {
      var self = this,
        out = '',
        item;

      self._controlNavEnabled = true;
      out += '<div class="rsNav rsTabs">';
      for(var i = 0; i < self.numSlides; i++) {
        out += '<div class="rsNavItem rsTab">'+self.slides[i].thumbnail+'</div>';
      }
      out += '</div>';

      out = $(out);


      self._controlNav = out;
      self._controlNavItems = out.children('.rsNavItem');
      self.slider.append(out);


      self._controlNav.click(function(e) {
        var item = $(e.target).closest('.rsNavItem');
        if(item.length) {
          self.goTo(item.index());
        }
      });
    }
  });
  $.rsModules.tabs = $.rsProto._initTabs;
})(jQuery);




(function($) {

  "use strict";

  /**
   *
   * RoyalSlider thumbnails module
   * @version 1.0.6:
   *
   * 1.0.1
   * - Fixed bug with vertical thumbs caused by latest update
   *
   * 1.0.2:
   * - Dynamic adding/removing tabs.
   *
   * 1.0.3
   * - Removed first transition at slider initialization
   *
   * 1.0.4
   * - Added paddingTop & bottom
   * - firstMargin now accepts number which is min distance of first/last thumbnail
   *
   * 1.0.5
   * - IE10 touch support
   *
   * 1.0.6
   * - Fix issue when autoHeight is enabled
   *
   */
  $.extend($.rsProto, {
    _initThumbs: function() {
      var self = this;
      if(self.st.controlNavigation === 'thumbnails') {

        self._thumbsDefaults = {
          drag: true,
          touch: true,
          orientation: 'horizontal',
          navigation: true,
          arrows: true,
          arrowLeft: null,
          arrowRight: null,
          spacing: 4,
          arrowsAutoHide: false,
          appendSpan: false,
          transitionSpeed:600,
          autoCenter: true,
          fitInViewport: true,
          firstMargin: true,
          paddingTop: 0,
          paddingBottom: 0
        };

        self.st.thumbs = $.extend({}, self._thumbsDefaults, self.st.thumbs);
        self._firstThumbMoved = true;
        if(self.st.thumbs.firstMargin === false) { self.st.thumbs.firstMargin = 0; }
        else if(self.st.thumbs.firstMargin === true) { self.st.thumbs.firstMargin = self.st.thumbs.spacing; }

        self.ev.on('rsBeforeParseNode', function(e, content, obj) {
          content = $(content);
          obj.thumbnail = content.find('.rsTmb').remove();
          if(!obj.thumbnail.length) {
            obj.thumbnail = content.attr('data-rsTmb');
            if(!obj.thumbnail) {
              obj.thumbnail = content.find('.rsImg').attr('data-rsTmb');
            }
            if(!obj.thumbnail) {
              obj.thumbnail = '';
            } else {
              obj.thumbnail = '<img src="'+obj.thumbnail+'"/>';
            }
          } else {
            obj.thumbnail = $(document.createElement('div')).append(obj.thumbnail).html();
          }
        });

        self.ev.one('rsAfterPropsSetup', function() {
          self._createThumbs();
        });

        self._prevNavItem = null;

        self.ev.on('rsOnUpdateNav', function() {
          var currItem = $(self._controlNavItems[self.currSlideId]);
          if(currItem === self._prevNavItem) {
            return;
          }
          if(self._prevNavItem) {
            self._prevNavItem.removeClass('rsNavSelected');
            self._prevNavItem = null;
          }
          if(self._thumbsNavigation) {
            self._setCurrentThumb(self.currSlideId);
          }
          self._prevNavItem = currItem.addClass('rsNavSelected');
        });

        self.ev.on('rsOnAppendSlide', function(e, parsedSlide, index) {
          var html = '<div'+self._thumbsMargin+' class="rsNavItem rsThumb">'+self._addThumbHTML+parsedSlide.thumbnail+'</div>';
          if(index >= self.numSlides) {
            self._thumbsContainer.append(html);
          } else {
            self._controlNavItems.eq(index).before(html);
          }
          self._controlNavItems = self._thumbsContainer.children();
          self.updateThumbsSize();
        });
        self.ev.on('rsOnRemoveSlide', function(e, index) {
          var itemToRemove = self._controlNavItems.eq(index);
          if(itemToRemove) {
            itemToRemove.remove();
            self._controlNavItems = self._thumbsContainer.children();
            self.updateThumbsSize();
          }
        });


      }
    },
    _createThumbs: function() {
      var self = this,
        tText = 'rsThumbs',
        thumbSt = self.st.thumbs,
        out = '',
        style,
        item,
        spacing = thumbSt.spacing;

      self._controlNavEnabled = true;
      self._thumbsHorizontal = (thumbSt.orientation === 'vertical') ? false : true;

      self._thumbsMargin = style = spacing ? ' style="margin-' + (self._thumbsHorizontal ? 'right' : 'bottom') + ':'+ spacing+'px;"' : '';

      self._thumbsPosition = 0;
      self._isThumbsAnimating = false;
      self._thumbsDrag = false;
      self._thumbsNavigation = false;

      self._thumbsArrows = (thumbSt.arrows && thumbSt.navigation);

      var pl = (self._thumbsHorizontal ? 'Hor' : 'Ver');
      self.slider.addClass('rsWithThumbs' + ' rsWithThumbs'+ pl );

      out += '<div class="rsNav rsThumbs rsThumbs'+pl +'"><div class="'+tText+'Container">';
      self._addThumbHTML = thumbSt.appendSpan ? '<span class="thumbIco"></span>' : '';
      for(var i = 0; i < self.numSlides; i++) {
        item = self.slides[i];
        out += '<div'+style+' class="rsNavItem rsThumb">'+item.thumbnail+self._addThumbHTML+'</div>';
      }
      out = $(out +'</div></div>');

      var o = {};
      if(thumbSt.paddingTop) {
        o[self._thumbsHorizontal ? 'paddingTop' : 'paddingLeft'] = thumbSt.paddingTop;
      }
      if(thumbSt.paddingBottom) {
        o[self._thumbsHorizontal ? 'paddingBottom' : 'paddingRight'] = thumbSt.paddingBottom;
      }
      out.css(o);

      self._thumbsContainer = $(out).find('.' + tText + 'Container');

      if(self._thumbsArrows) {
        tText += 'Arrow';
        if(thumbSt.arrowLeft) {
          self._thumbsArrowLeft = thumbSt.arrowLeft;
        } else {
          self._thumbsArrowLeft = $('<div class="'+ tText +' ' + tText +'Left"><div class="'+tText+'Icn"></div></div>');
          out.append(self._thumbsArrowLeft);
        }

        if(thumbSt.arrowRight) {
          self._thumbsArrowRight = thumbSt.arrowRight;
        } else {
          self._thumbsArrowRight = $('<div class="'+ tText +' ' + tText +'Right"><div class="'+tText+'Icn"></div></div>');
          out.append(self._thumbsArrowRight);
        }


        self._thumbsArrowLeft.click(function() {
          var viewportSize = Math.floor(self._thumbsViewportSize / self._thumbSize),
            thumbId = Math.floor(self._thumbsPosition / self._thumbSize),
            newPos = (thumbId + self._visibleThumbsPerView) * self._thumbSize + self._thumbsSpacing;
          self._animateThumbsTo( newPos > self._thumbsMinPosition ? self._thumbsMinPosition : newPos );
        });
        self._thumbsArrowRight.click(function() {
          var viewportSize = Math.floor(self._thumbsViewportSize / self._thumbSize),
            thumbId = Math.floor(self._thumbsPosition / self._thumbSize),
            newPos = (thumbId - self._visibleThumbsPerView) * self._thumbSize + self._thumbsSpacing;
          self._animateThumbsTo( newPos < self._thumbsMaxPosition ? self._thumbsMaxPosition : newPos );
        });
        if(thumbSt.arrowsAutoHide && !self.hasTouch) {
          self._thumbsArrowLeft.css('opacity', 0);
          self._thumbsArrowRight.css('opacity', 0);

          out.one("mousemove.rsarrowshover",function() {
            if(self._thumbsNavigation) {
              self._thumbsArrowLeft.css('opacity', 1);
              self._thumbsArrowRight.css('opacity', 1);
            }
          });

          out.hover(
            function() {
              if(self._thumbsNavigation) {
                self._thumbsArrowLeft.css('opacity', 1);
                self._thumbsArrowRight.css('opacity', 1);
              }
            },
            function() {
              if(self._thumbsNavigation) {
                self._thumbsArrowLeft.css('opacity', 0);
                self._thumbsArrowRight.css('opacity', 0);
              }
            }
          );
        }
      }

      self._controlNav = out;
      self._controlNavItems = self._thumbsContainer.children();


      if(self.msEnabled && self.st.thumbs.navigation) {
        self._thumbsContainer.css('-ms-touch-action', self._thumbsHorizontal ? 'pan-y' : 'pan-x');
      }

      self.slider.append(out);

      self._thumbsEnabled = true;
      self._thumbsSpacing = spacing;


      if(thumbSt.navigation) {
        if(self._useCSS3Transitions) {
          self._thumbsContainer.css(self._vendorPref + 'transition-property', self._vendorPref + 'transform');
        }
      }

      self._controlNav.on('click.rs','.rsNavItem',function(e) {
        if(!self._thumbsDrag ) {
          self.goTo( $(this).index() );
        }
      });

      self.ev.off('rsBeforeSizeSet.thumbs').on('rsBeforeSizeSet.thumbs', function() {
        self._realWrapSize = self._thumbsHorizontal ? self._wrapHeight : self._wrapWidth;
        self.updateThumbsSize(true);
      });
      self.ev.off('rsAutoHeightChange.thumbs').on('rsAutoHeightChange.thumbs', function(e, newHeight) {
        self.updateThumbsSize(true, newHeight);
      });

    },
    updateThumbsSize: function(isResize, newHeight) {
      var self = this,
        firstThumb = self._controlNavItems.first(),
        cssObj = {};

      var numItems = self._controlNavItems.length;
      self._thumbSize = ( self._thumbsHorizontal ? firstThumb.outerWidth() : firstThumb.outerHeight() ) + self._thumbsSpacing;
      self._thumbsContainerSize = numItems * self._thumbSize - self._thumbsSpacing;
      cssObj[self._thumbsHorizontal ? 'width' : 'height'] = self._thumbsContainerSize + self._thumbsSpacing;

      self._thumbsViewportSize = self._thumbsHorizontal ? self._controlNav.width() : (newHeight !== undefined ? newHeight : self._controlNav.height());


      if(self._thumbsEnabled && (self.isFullscreen || self.st.thumbs.fitInViewport)) {
        if(self._thumbsHorizontal) {
          self._wrapHeight = self._realWrapSize - self._controlNav.outerHeight();
        } else {
          self._wrapWidth = self._realWrapSize - self._controlNav.outerWidth();
        }
      }

      if(!self._thumbsViewportSize) {
        return;
      }

      self._thumbsMaxPosition = -(self._thumbsContainerSize - self._thumbsViewportSize) - (self.st.thumbs.firstMargin);
      self._thumbsMinPosition = self.st.thumbs.firstMargin;
      self._visibleThumbsPerView = Math.floor(self._thumbsViewportSize / self._thumbSize);

      if(self._thumbsContainerSize < self._thumbsViewportSize) {
        if(self.st.thumbs.autoCenter) {
          self._setThumbsPosition((self._thumbsViewportSize - self._thumbsContainerSize) / 2);
        }
        if(self.st.thumbs.arrows && self._thumbsArrowLeft) {
          var arrDisClass = 'rsThumbsArrowDisabled';
          self._thumbsArrowLeft.addClass(arrDisClass);
          self._thumbsArrowRight.addClass(arrDisClass);
        }
        self._thumbsNavigation = false;
        self._thumbsDrag = false;
        self._controlNav.off(self._downEvent);

      } else if(self.st.thumbs.navigation && !self._thumbsNavigation) {
        self._thumbsNavigation = true;
        if( (!self.hasTouch && self.st.thumbs.drag) ||  (self.hasTouch && self.st.thumbs.touch)) {
          self._thumbsDrag = true;
          self._controlNav.on(self._downEvent, function(e) { self._onDragStart(e, true); });
        }
      }







      self._thumbsContainer.css(cssObj);
      if(isResize && newHeight) {
        self._setCurrentThumb(self.currSlideId);
      }

      if(self._useCSS3Transitions) {
        cssObj[(self._vendorPref + 'transition-duration')] = '0ms';
      }



    },
    setThumbsOrientation: function(newPlacement, dontUpdateSize) {
      var self = this;
      if(self._thumbsEnabled) {
        self.st.thumbs.orientation = newPlacement;
        self._controlNav.remove();
        self.slider.removeClass('rsWithThumbsHor rsWithThumbsVer');
        self._createThumbs();
        self._controlNav.off(self._downEvent);
        if(!dontUpdateSize) {
          self.updateSliderSize(true);
        }
      }
    },
    _setThumbsPosition: function(pos) {
      var self = this;
      self._thumbsPosition = pos;
      if(self._useCSS3Transitions) {
        self._thumbsContainer.css(self._xProp, self._tPref1 + ( self._thumbsHorizontal ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 );
      } else {
        self._thumbsContainer.css(self._thumbsHorizontal ? self._xProp : self._yProp, pos);
      }
    },
    _animateThumbsTo: function(pos, speed, outEasing, bounceAnimPosition, bounceAnimSpeed) {
      var self = this;
      if(!self._thumbsNavigation) {
        return;
      }
      if(!speed) {
        speed = self.st.thumbs.transitionSpeed;
      }
      self._thumbsPosition = pos;
      if(self._thumbsAnimTimeout) {
        clearTimeout(self._thumbsAnimTimeout);
      }
      if(self._isThumbsAnimating) {
        if(!self._useCSS3Transitions) {
          self._thumbsContainer.stop();
        }
        outEasing = true;
      }
      var animObj = {};
      self._isThumbsAnimating = true;
      if(!self._useCSS3Transitions) {
        animObj[self._thumbsHorizontal ? self._xProp : self._yProp] = pos + 'px';
        self._thumbsContainer.animate(animObj, speed, outEasing ? 'easeOutCubic' : self.st.easeInOut);
      } else {
        animObj[(self._vendorPref + 'transition-duration')] = speed+'ms';
        animObj[(self._vendorPref + 'transition-timing-function')] = outEasing ? $.rsCSS3Easing[self.st.easeOut] : $.rsCSS3Easing[self.st.easeInOut];
        self._thumbsContainer.css(animObj);
        self._setThumbsPosition(pos);
      }
      if(bounceAnimPosition) {
        self._thumbsPosition = bounceAnimPosition;
      }
      self._updateThumbsArrows();


      self._thumbsAnimTimeout = setTimeout(function() {
        self._isThumbsAnimating = false;
        if(bounceAnimSpeed) {
          self._animateThumbsTo(bounceAnimPosition, bounceAnimSpeed, true);
          bounceAnimSpeed = null;
        }
      }, speed);
    },
    _updateThumbsArrows: function() {
      var self = this;
      if(self._thumbsArrows) {
        var arrDisClass = 'rsThumbsArrowDisabled';

        if(self._thumbsPosition === self._thumbsMinPosition) {
          self._thumbsArrowLeft.addClass(arrDisClass);
        } else {
          self._thumbsArrowLeft.removeClass(arrDisClass);
        }
        if(self._thumbsPosition === self._thumbsMaxPosition) {
          self._thumbsArrowRight.addClass(arrDisClass);
        } else {
          self._thumbsArrowRight.removeClass(arrDisClass);
        }
      }
    },
    _setCurrentThumb: function(id, justSet) {

      var self = this,
        incr = 0,
        newPos,
        nextThumbEndPos = (id * self._thumbSize + self._thumbSize * 2 - self._thumbsSpacing + self._thumbsMinPosition),
        thumbId = Math.floor(self._thumbsPosition / self._thumbSize);

      if(!self._thumbsNavigation) {
        return;
      }
      if(self._firstThumbMoved) {
        justSet = true;
        self._firstThumbMoved = false;
      }

      if(nextThumbEndPos  + self._thumbsPosition > self._thumbsViewportSize) {
        if(id === self.numSlides - 1) {
          incr = 1;
        }
        thumbId = -id + self._visibleThumbsPerView - 2 + incr;
        newPos = thumbId * self._thumbSize + (self._thumbsViewportSize % self._thumbSize) + self._thumbsSpacing - self._thumbsMinPosition;
      } else {
        if(id !== 0) {
          if( (id-1) * self._thumbSize <= -self._thumbsPosition + self._thumbsMinPosition && (id-1) <= self.numSlides - self._visibleThumbsPerView) {
            thumbId = -id + 1;
            newPos = thumbId * self._thumbSize + self._thumbsMinPosition;
          }
        } else {
          thumbId = 0;
          newPos = self._thumbsMinPosition;
        }
      }

      if(newPos !== self._thumbsPosition) {
        var checkPos = (newPos === undefined) ? self._thumbsPosition : newPos;
        if(checkPos > self._thumbsMinPosition) {
          self._setThumbsPosition(self._thumbsMinPosition);
        } else if(checkPos < self._thumbsMaxPosition) {
          self._setThumbsPosition(self._thumbsMaxPosition);
        } else  if(newPos !== undefined) {
          if(!justSet) {
            self._animateThumbsTo(newPos);
          } else {
            self._setThumbsPosition(newPos);
          }
        }
      }
      self._updateThumbsArrows();
    }
  });
  $.rsModules.thumbnails = $.rsProto._initThumbs;
})(jQuery);







(function($) {

  "use strict";

  /**
   *
   * RoyalSlider video module
   * @version 1.1.3:
   *
   * 1.0.3:
   * - Added rsOnDestroyVideoElement event
   *
   * 1.0.4:
   * - Added wmode=transparent to default YouTube video embed code
   *
   * 1.0.5
   * - Fixed bug: HTMl5 YouTube player sometimes keeps playing in ie9 after closing
   *
   * 1.0.6
   * - A bit lightened Vimeo and YouTube regex
   *
   * 1.0.7
   * - Minor optimizations
   * - Added autoHideCaption option
   *
   * 1.0.9
   * - Fixed error that could appear if updateSliderSize method is called directly after video close
   *
   * 1.1.0
   * - Video is now removed in rsAfterSlideChange event to avoid transition lag
   * - Fixed bug that could cause appearing of arrows with auto-hide
   *
   * 1.1.1
   * - Added option disableCSS3inFF
   *
   * 1.1.2
   * - Hide static blocks when video is playing
   *
   * 1.1.3
   * - Fixed blocks autohiding issue
   */
  $.extend($.rsProto, {
    _initVideo: function() {
      var self = this;
      self._videoDefaults = {
        autoHideArrows: true,
        autoHideControlNav: false,
        autoHideBlocks: false,
        autoHideCaption: false,
        disableCSS3inFF: true,
        youTubeCode: '<iframe src="http://www.youtube.com/embed/%id%?rel=1&showinfo=0&autoplay=1&wmode=transparent" frameborder="no"></iframe>',
        vimeoCode: '<iframe src="http://player.vimeo.com/video/%id%?byline=0&portrait=0&autoplay=1" frameborder="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>'
      };

      self.st.video = $.extend({}, self._videoDefaults, self.st.video);

      self.ev.on('rsBeforeSizeSet', function() {
        if(self._isVideoPlaying) {
          setTimeout(function() {
            var content = self._currHolder;
            content = content.hasClass('rsVideoContainer') ? content : content.find('.rsVideoContainer');
            if(self._videoFrameHolder) {
              self._videoFrameHolder.css({
                width: content.width(),
                height: content.height()
              });
            }
          }, 32);
        }
      });
      var isFF = self._browser.mozilla;
      self.ev.on('rsAfterParseNode', function(e, content, obj) {
        var jqcontent = $(content),
          tempEl,
          hasVideo;

        if(obj.videoURL) {
          if(self.st.video.disableCSS3inFF && !hasVideo && isFF) {
            hasVideo = true;
            self._useCSS3Transitions = self._use3dTransform = false;
          }
          var wrap = $('<div class="rsVideoContainer"></div>'),
            playBtn = $('<div class="rsBtnCenterer"><div class="rsPlayBtn"><div class="rsPlayBtnIcon"></div></div></div>');
          if(jqcontent.hasClass('rsImg')) {
            obj.content = wrap.append(jqcontent).append(playBtn);
          } else {
            obj.content.find('.rsImg').wrap(wrap).after(playBtn);
          }
        }
      });

      self.ev.on('rsAfterSlideChange', function() {
        self.stopVideo();
      });

    },
    toggleVideo: function() {
      var self = this;
      if(!self._isVideoPlaying) {
        return self.playVideo();
      } else {
        return self.stopVideo();
      }
    },
    playVideo: function() {
      var self = this;
      if(!self._isVideoPlaying) {
        var currSlide = self.currSlide;
        if(!currSlide.videoURL) {
          return false;
        }
        self._playingVideoSlide = currSlide;

        var content = self._currVideoContent = currSlide.content;
        var url = currSlide.videoURL,
          videoId,
          regExp,
          match;

        if( url.match(/youtu\.be/i) || url.match(/youtube\.com/i) ) {

          regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;


          match = url.match(regExp);
          if (match && match[7].length==11){
            videoId = match[7];
          }

          if(videoId !== undefined) {
            self._videoFrameHolder = self.st.video.youTubeCode.replace("%id%", videoId);
          }
        } else if(url.match(/vimeo\.com/i)) {
          regExp = /(www\.)?vimeo.com\/(\d+)($|\/)/;
          match = url.match(regExp);
          if(match) {
            videoId = match[2];
          }
          if(videoId !== undefined) {
            self._videoFrameHolder = self.st.video.vimeoCode.replace("%id%", videoId);
          }
        }
        self.videoObj = $(self._videoFrameHolder);

        self.ev.trigger('rsOnCreateVideoElement', [url]);


        if(self.videoObj.length) {
          self._videoFrameHolder = $('<div class="rsVideoFrameHolder"><div class="rsPreloader"></div><div class="rsCloseVideoBtn"><div class="rsCloseVideoIcn"></div></div></div>');
          self._videoFrameHolder.find('.rsPreloader').after(self.videoObj);
          content = content.hasClass('rsVideoContainer') ? content : content.find('.rsVideoContainer');
          self._videoFrameHolder.css({
            width: content.width(),
            height: content.height()
          }).find('.rsCloseVideoBtn').off('click.rsv').on('click.rsv', function(e) {
            self.stopVideo();
            e.preventDefault();
            e.stopPropagation();
            return false;
          });
          content.append(self._videoFrameHolder);
          if(self.isIPAD) {
            content.addClass('rsIOSVideo');
          }

          self._toggleHiddenClass(false);

          setTimeout(function() {
            self._videoFrameHolder.addClass('rsVideoActive');
          }, 10);
          self.ev.trigger('rsVideoPlay');
          self._isVideoPlaying = true;
        }
        return true;
      }
      return false;
    },
    stopVideo: function() {
      var self = this;
      if(self._isVideoPlaying) {
        if(self.isIPAD) {
          self.slider.find('.rsCloseVideoBtn').remove();
        }

        self._toggleHiddenClass(true);

        setTimeout(function() {
          self.ev.trigger('rsOnDestroyVideoElement', [self.videoObj]);
          var ifr = self._videoFrameHolder.find('iframe');
          if(ifr.length) {
            try {
              ifr.attr('src', "");
            } catch(ex) { }
          }
          self._videoFrameHolder.remove();
          self._videoFrameHolder = null;
        }, 16);
        self.ev.trigger('rsVideoStop');
        self._isVideoPlaying = false;
        return true;
      }
      return false;
    },
    _toggleHiddenClass: function(remove, prevSlide) {

      var arr = [],
        self = this,
        vst = self.st.video;


      if(vst.autoHideArrows) {
        if(self._arrowLeft) {
          arr.push(self._arrowLeft, self._arrowRight);
          self._arrowsAutoHideLocked = !remove;
        }
        if(self._fsBtn) {
          arr.push(self._fsBtn);
        }
      }
      if(vst.autoHideControlNav && self._controlNav) {
        arr.push(self._controlNav);
      }
      if(vst.autoHideBlocks && self._playingVideoSlide.animBlocks) {
        arr.push(self._playingVideoSlide.animBlocks);
      }
      if(vst.autoHideCaption && self.globalCaption) {
        arr.push(self.globalCaption);
      }
      self.slider[remove ? 'removeClass' : 'addClass']('rsVideoPlaying');

      if(arr.length) {
        for(var i = 0; i < arr.length; i++) {
          if(!remove) {
            arr[i].addClass('rsHidden');
          } else {
            arr[i].removeClass('rsHidden');
          }
        }
      }
    }
  });
  $.rsModules.video = $.rsProto._initVideo;
})(jQuery);






(function($) {

  "use strict";

  /**
   *
   * RoyalSlider module that makes nearby slides visible
   * @version 1.0.2:
   *
   * 1.0.1
   * - Added navigateByCenterClick, breakpoint options
   *
   * 1.0.2
   * - Added hiddenOverflow option
   *
   */
  $.rsProto._initVisibleNearby = function() {
    var self = this;
    if(self.st.visibleNearby && self.st.visibleNearby.enabled) {
      self._vnDefaults = {
        enabled: true,
        centerArea: 0.6, // Area of center image. By default 60% will get center image, 20% for each image on side

        center: true,

        breakpoint: 0, // this option will be trigger change of centerArea parameter
        breakpointCenterArea: 0.8,

        hiddenOverflow: true,
        navigateByCenterClick: false
      };
      self.st.visibleNearby = $.extend({}, self._vnDefaults, self.st.visibleNearby);

      self.ev.one('rsAfterPropsSetup', function() {
        self._sliderVisibleNearbyWrap = self._sliderOverflow.css('overflow', 'visible').wrap('<div class="rsVisibleNearbyWrap"></div>').parent();
        if(!self.st.visibleNearby.hiddenOverflow) {
          self._sliderVisibleNearbyWrap.css('overflow', 'visible');
        }
        self._controlsContainer = self.st.controlsInside ? self._sliderVisibleNearbyWrap : self.slider;
      });

      self.ev.on('rsAfterSizePropSet', function() {
        var centerRatio,
          o = self.st.visibleNearby;

        if(o.breakpoint && self.width < o.breakpoint) {
          centerRatio = o.breakpointCenterArea;
        } else {
          centerRatio = o.centerArea;
        }
        if(self._slidesHorizontal) {
          self._wrapWidth = self._wrapWidth * centerRatio;
          self._sliderVisibleNearbyWrap.css({
            height: self._wrapHeight,
            width: self._wrapWidth / centerRatio
          });
          self._minPosOffset = self._wrapWidth * (1 - centerRatio) / 2 / centerRatio;
        } else {
          self._wrapHeight = self._wrapHeight * centerRatio;
          self._sliderVisibleNearbyWrap.css({
            height: self._wrapHeight / centerRatio,
            width: self._wrapWidth
          });
          self._minPosOffset = self._wrapHeight * (1 - centerRatio) / 2 / centerRatio;
        }
        if(!o.navigateByCenterClick) {
          self._nextSlidePos = self._slidesHorizontal ? self._wrapWidth : self._wrapHeight;
        }
        if(o.center) {
          self._sliderOverflow.css('margin-' + (self._slidesHorizontal ? 'left' : 'top' ), self._minPosOffset);
        }
      });

    }
  };
  $.rsModules.visibleNearby = $.rsProto._initVisibleNearby;
})(jQuery);


// end of AMD module wrap
}));


/***/ }),
/* 263 */
/***/ (function(module, exports) {

/*!
 * hoverIntent v1.8.0 // 2014.06.29 // jQuery v1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */
(function($){$.fn.hoverIntent=function(handlerIn,handlerOut,selector){var cfg={interval:100,sensitivity:6,timeout:0};if(typeof handlerIn==="object"){cfg=$.extend(cfg,handlerIn)}else{if($.isFunction(handlerOut)){cfg=$.extend(cfg,{over:handlerIn,out:handlerOut,selector:selector})}else{cfg=$.extend(cfg,{over:handlerIn,out:handlerIn,selector:handlerOut})}}var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if(Math.sqrt((pX-cX)*(pX-cX)+(pY-cY)*(pY-cY))<cfg.sensitivity){$(ob).off("mousemove.hoverIntent",track);ob.hoverIntent_s=true;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=false;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=$.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type==="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).on("mousemove.hoverIntent",track);if(!ob.hoverIntent_s){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).off("mousemove.hoverIntent",track);if(ob.hoverIntent_s){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.on({"mouseenter.hoverIntent":handleHover,"mouseleave.hoverIntent":handleHover},cfg.selector)}})(jQuery);


/***/ }),
/* 264 */
/***/ (function(module, exports) {

/*
  Workaround for using touch UI and classic UI in tandem in CQ/AEM 6.1.
  This was put in place because Adobe prefers not to fix the issue in the CQ codebase. See DayCare ticket:
  https://daycare.day.com/content/home/scripps/scripps_us/sn_digital/76555.html

           .          .
 .          .                  .          .              .
       +.           _____  .        .        + .                    .
   .        .   ,-~"     "~-.                                +
              ,^ ___         ^. +                  .    .       .
             / .^   ^.         \         .      _ .
            Y  l  o  !          Y  .         __CL\H--.
    .       l_ `.___.'        _,[           L__/_\H' \\--_-          +
            |^~"-----------""~ ^|       +    __L_(=): ]-_ _-- -
  +       . !                   !     .     T__\ /H. //---- -       .
         .   \                 /               ~^-H--'
              ^.             .^            .      "       +.
                "-.._____.,-" .                    .
         +           .                .   +                       .
  +          .             +                                  .
*/

(function() {
  /*
   * code adapted from http://www.quirksmode.org/js/cookies.html
   */
  var cookie = {
    get: function(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for(var i=0;i < ca.length;i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') {
          c = c.substring(1,c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
          return c.substring(nameEQ.length,c.length);
        }
      }
      return null;
    },
    // leave 'days' blank to expire at end of session
    set: function(name, value, days, path, domain) {
      var expires = "",
          sharedDomain = window.location.hostname.match(/[^\.]*\.*[a-z]*$/g),
          domain = (domain && sharedDomain && sharedDomain[0]) ? "; domain=." + sharedDomain[0] : "";

      if (days) {
        var date = new Date();
        date.setTime(date.getTime()+(days*24*60*60*1000));
        expires = "; expires="+date.toGMTString();
      }
      if (!path) {
        path = '/';
      }
      document.cookie = name + "=" + value + expires + "; path=" + path + domain;
    }
  };

  var modeCookie = cookie.get('cq-authoring-mode');
  if (!!modeCookie && (window.top === window.self)) {
    var touchSelector = (window.location.pathname.indexOf('/editor.html/') === 0),
        touchCookie = (modeCookie === 'TOUCH');

    if (!touchSelector && touchCookie) {
      cookie.set('cq-authoring-mode', 'CLASSIC');
      window.location.reload();
    }
  }
})();


/***/ }),
/* 265 */
/***/ (function(module, exports) {

var SNI = window.SNI = window.SNI || {};

SNI.Config                        = SNI.Config || {};
SNI.Config.Video                  = SNI.Config.Video || {};
SNI.Config.enableShopThisLook     = true;
SNI.Config.enableHeaderLogin      = ['hgtv','diy','gac'];
SNI.Config.enableSocialComments   = ['diy'];

SNI.Config.isEnabled = function(key) {
  var getUrlParam = function(param) {
          param = param.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
          var regex = new RegExp('[\\?&]' + param + '=([^&#]*)'),
              results = regex.exec(location.search);
          return results == null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
      },
      capitalize = function(val) {
          return val.charAt(0).toUpperCase() + val.slice(1);
      },
      out = false,
      override = getUrlParam(key);
      key = 'enable' + capitalize(key);

  if (!override && Array.isArray(SNI.Config[key])) {
    out = (SNI.Config[key].indexOf(SNI.Config.brand) >= 0);
  } else {
    out = (override === 'true') ? true : (override === 'false') ? false : SNI.Config[key];
  }
  return out;
};


/***/ }),
/* 266 */
/***/ (function(module, exports) {

SNI.Config.VPC = {
  setUri: function(uri) {
    var vodVersion = window.location.href.match(/[?|&]vodVersion=([^&|#]*)/);
    SNI.Config.VPC.vodVersion = (vodVersion && vodVersion.length > 1) ? decodeURIComponent( vodVersion[1] ) : false;
    SNI.Config.VPC.uri = SNI.Config.VPC.vodVersion ? uri.replace(/\.com\/.*/g, '.com/' + SNI.Config.VPC.vodVersion + '/') : uri;
  },
  insertJs: function() {
    if (SNI.Config.VPC.uri) {
      document.write('<script src="' + SNI.Config.VPC.uri + 'js/sni-video.min.js" onerror="if(console&&console.error){console.error(\'VPC JavaScript library \' + this.src + \' failed to load.\');}"></script>');
      //overriding default countdown time from 10 to 4
      document.write('<script>SNI.Video.Defaults.endframe.endframeCountdown = 4;</script>');
      // Disabling the embed module
      document.write('<script>SNI.Video.Defaults.embed.enabled = false;</script>');
    }
  },
  insertCss: function() {
    if (SNI.Config.VPC.uri) {
      document.write('<link rel="stylesheet" type="text/css" href="' + SNI.Config.VPC.uri + 'css/sni-video.min.css" />');
    }
  }
};


/***/ }),
/* 267 */
/***/ (function(module, exports) {

// safeguard against legacy browsers failing from any stray console calls in our output...
if (typeof window.console === 'undefined') {
    window.console = {};
    var types = ['log', 'warn', 'dir', 'info', 'debug'];
    for (var i = 0; i < types.length; i++) {
        window.console[types[i]] = function(){ return false; }
    }
}


/***/ }),
/* 268 */
/***/ (function(module, exports) {

// import t3 from 't3';

var SNI = window.SNI = window.SNI || {};

// t3 compat
Object.assign(SNI, SMBJS);


/***/ }),
/* 269 */
/***/ (function(module, exports) {

SNI.Application.addModule('article-stream', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var loc = context.getGlobal('location'),
      SniAds = context.getGlobal('SniAds'),
      check = context.getService('check'),
      template = context.getService('template'),
      debug = context.getService('logger').create('module.article-stream'),
      tracker = context.getService('scroll-tracker'),
      metadata = context.getService('metadata'),
      analytics = context.getService('analytics'),
      device = context.getService('device-type'),
      manager = context.getService('stream-manager'),
      readMoreSvc = context.getService('read-more');

  var defaults = void 0,
      config = void 0,
      $element = void 0,
      $endcap = void 0,
      $nextUp = void 0,
      adLibLoaded = void 0,
      previousEntry = void 0,
      currentEntry = void 0,
      lastEntry = void 0,
      $entryContainer = void 0,
      first = void 0,
      $container = void 0;

  defaults = {
    index: 1,
    last: 10,
    interval: 1500,
    adInterval: 1500,
    offset: .65,
    container: 'area',
    mobileAdContainer: 'article-body',
    mobileAdBlock: 'section',
    desktopAdContainer: 'container-aside',
    hardlineClass: 'stream-end',
    trigger: '.stream-trigger',
    endpointSelector: 'lazy-fetch',
    deferAttr: 'data-deferred-module',
    url: loc.pathname,
    ended: false
  };

  /*
    Initialize newly loaded article
  */
  function processArticle(entry, append) {

    var $entryContainer = void 0,
        leaderBoard = void 0,
        skip = void 0;

    if (config.index < config.last && typeof entry !== 'undefined' && append) {
      if (entry.hasOwnProperty('content') && entry.content !== '' && entry.class) {
        config.index += 1;

        $(entry.content).appendTo($('.' + config.container)).addClass(entry.class).removeClass(config.container);
        $entryContainer = $('.' + entry.class);
        $entryContainer.find('.o-Breadcrumb').css('position', 'relative');
        if (device.isMobile) {
          $entryContainer.find('.social-share').css('float', 'right');
        }
        manager.setTracked();
        if (config.index > 1) {
          if (config.index === config.last) {
            lastEntry = entry;
          }
          updateOG(entry); // This is needed by here the sharebar.  Sharebar should take a parameter instead
          SNI.Application.startAll($entryContainer[0]);
          prepDeferred($entryContainer);
          if (adLibLoaded) {
            leaderBoard = $entryContainer.find('[data-has-ad]').first();
            if (leaderBoard && entry.order) {
              var leaderBoardId = '' + leaderBoard.attr('id') + entry.order;
              leaderBoard.attr('id', leaderBoardId);
              var adType = leaderBoard.data('has-ad');
              SniAds.appendSlot(leaderBoardId, adType, {}, true);
            }
            if (device.isMobile) {
              $entryContainer.find('.' + config.mobileAdContainer).children().addClass(config.mobileAdBlock);
            } else {
              $entryContainer.find('.' + config.desktopAdContainer).addClass(entry.class + '-aside');
            }
          }
        }
        previousEntry = entry;
        skip = readMoreSvc.skipReadMore($entryContainer);
        if (skip) {
          readMoreSvc.removeReadMore($entryContainer, entry.class);
        } else {
          var $article = $entryContainer.find('.article-content');
          readMoreSvc.setHeight($article);
        }
      }
    } else if (config.index < config.last && typeof entry !== 'undefined' && !append) {
      $entryContainer = $('.' + config.container).find('[data-sni-area="content"]');
      $entryContainer.addClass(entry.class);
    }
    var $readMore = $entryContainer.find('[data-type="read-more"]');

    if (!skip) {
      $entryContainer.data('expanded', false);
    }
    if ($readMore.length > 0) {
      $readMore.data('container-class', entry.class); // Save reference to parent container
    }
  }

  function prepDeferred(target) {
    if (typeof target !== 'undefined') {
      target.find('[' + config.deferAttr + ']').each(function (index, el) {
        var $el = $(el);

        $el.attr('data-module', $el.attr('' + config.deferAttr)).removeAttr('' + config.deferAttr);
      });
    }
  }

  /*
    Update page meta tags on article init
    This is required by the social sharebar component
    IMPROVEMENT NEEDED: Send these values directly to the sharebar component.  Updating the page and then
    the share component is indirect
  */
  function updateOG(entry) {
    if (typeof entry !== 'undefined' && entry.hasOwnProperty('og')) {
      var og = entry.og;
      if (og.hasOwnProperty('title')) {
        document.title = og['title'];
      }
      if (og.hasOwnProperty('description')) {
        $('meta[property=\'description\']').attr('content', og['description']);
      }
      if (og.hasOwnProperty('og:title')) {
        $('meta[property=\'og\\:title\']').attr('content', og['og:title']);
      }
      if (og.hasOwnProperty('og:description')) {
        $('meta[property=\'og\\:description\']').attr('content', og['og:description']);
      }
      if (og.hasOwnProperty('og:image')) {
        $('meta[property=\'og\\:image\']').attr('content', og['og:image']);
      }
      if (og.hasOwnProperty('twitter:card')) {
        $('meta[property=\'twitter\\:card\']').attr('content', og['twitter:card']);
      }
      if (og.hasOwnProperty('og:site_name')) {
        $('meta[property=\'og\\:site_name\']').attr('content', og['og:site_name']);
      }
    }
  }

  /*
   Update metadata from article entry
   Fires a page view on article change when article count has increased
  */
  function updateMdm(entry, stat, articleChange) {
    if (typeof entry !== 'undefined' && entry.hasOwnProperty('mdm')) {
      var articleIndex = manager.views.articles;
      var metaInfo = manager.mdm.getEntry(articleIndex) || entry.mdm;
      var currentStat = stat || manager.views.behavioralInteraction();
      metadata.updateFromJSON(metaInfo);

      if (typeof currentStat !== 'undefined') {
        metadata.updateFromJSON({ 'behavioralInteraction': currentStat });
      }

      if (manager.views.totalPages > 1 && articleChange) {
        updateOG(entry);
        if (manager.views.isNewEntry) {
          // only fire a page view when direction is down
          analytics.callDynamicPageview();
        }
      }
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {
    behaviors: ['read-more'],
    messages: ['sni-ads.repeatingBigBoxPrePageview', 'scroll-tracker.threshold', 'scroll-tracker.interval', 'scroll-tracker.viewed', 'stream-manager.entryLoaded', 'article-stream.end', 'readMore.removed'],

    init: function init() {
      config = Object.assign({}, defaults, context.getConfig());
      readMoreSvc.setConfig(config);
      $element = $(context.getElement());
      $container = $element.parents('body');
      adLibLoaded = check.exists(['SniAds.River', 'SniAds.Event']);
      if (device.isMobile) {
        $endcap = $element.find('.rR').detach();
      }
      //  manager.getTracked(); //  gets tracked data from SESSION
      manager.setSelector(config.endpointSelector); //  lazy fetch
      manager.addEntry(config.url, false, false); // Get the first entry info - but do not append since it is on the page
      tracker.setNamespace('scroll.stream');
      tracker.setViewport(true);
      tracker.setInterval(config.interval);
      tracker.setThreshold(config.offset);
      tracker.setContainer($container);
      tracker.setScrollHandler();
    },
    destroy: function destroy() {
      tracker.removeScrollHander();
    },


    processArticle: processArticle,
    updateOG: updateOG,
    updateMdm: updateMdm,
    prepDeferred: prepDeferred,

    onmessage: function onmessage(name, data) {
      previousEntry = currentEntry;
      currentEntry = manager.getEntry();
      $entryContainer = $('.' + currentEntry.class);
      var index = data && data.index || 1;
      switch (name) {
        // Handle in article page views/counts only
        case 'sni-ads.repeatingBigBoxPrePageview':
          // Event not detected by Mobile?
          manager.views.incrementPage();
          updateMdm(currentEntry);
          debug.log('viewed?', manager.views.behavioralInteraction());
          break;
        // Load new entries
        case 'scroll-tracker.threshold':
          var futureEntry = index === 1 ? currentEntry : manager.getFutureEntry();
          if (futureEntry && futureEntry.nextUp && config.index < config.last) {
            debug.log('Update page - get new entry');
            manager.addEntry(futureEntry.nextUp, data.contract, true);
          } else {
            debug.warn('scroll-tracker.threshold: unable to get current entry from stream manager');
            context.broadcast('article-stream.end');
          }
          break;
        // Do article init
        case 'stream-manager.entryLoaded':
          debug.log('stream-manager.entryLoaded: processArticle: entry: ', data.item);
          processArticle(data.item, data.append);
          break;
        // Deprecated in Desktop, used in mobile
        case 'scroll-tracker.interval':
          var current = manager.getStoredEntryByValue('current', true),
              $closestToSlot = void 0,
              slotName = void 0;
          $entryContainer = $('.' + current.class);
          if (current) {
            if (current.hasOwnProperty('class') && current.class && typeof first !== 'undefined' && current.class !== first) {
              if (device.isMobile && adLibLoaded) {
                $closestToSlot = tracker.getClosest($('.' + current.class + ' .' + config.mobileAdBlock), { left: 1, top: $(window).scrollTop() + $(window).height() });
                $closestToSlot.after(template.riverAd(current.class + '_' + tracker.getIteration()));
                slotName = SniAds.appendSlot('#mobile_rr_bigbox_' + current.class + '_' + tracker.getIteration(), 'dfp_bigbox');
                SniAds.Event.publish('_newSlotDefined', slotName, SniAds.getDefinedSlots(slotName));
              }
            }
          }

          if (!manager.getStoredEntriesByValue('viewed', false) && config.index === config.last) {
            context.broadcast('article-stream.end');
          }
          break;
        case 'scroll-tracker.viewed':

          /*
            Triggered when a new article is in view.
            Updates metadata
            Updates analytics page view
            Ads RR ads on desktop
          */

          currentEntry = data.current;
          $entryContainer = $('.' + currentEntry.class);
          updateMdm(currentEntry, data.stats, true);

          if (currentEntry.hasOwnProperty('class') && config.index === 1) {
            first = currentEntry.class;
            $nextUp = $entryContainer.find('.nextUp').detach();
          }
          if (device.isMobile && data.current && data.current.og) {
            context.broadcast('socialShare.updateShareBar', {
              description: data.current.og.description ? data.current.og.description : $('meta[property="og:description"]').attr('content'),
              title: data.current.og['og:title'] ? data.current.og['og:title'] : $('meta[property="og:title"]').attr('content'),
              url: data.current.og.hubURL ? data.current.og.hubURL : $('meta[property="og:url"]').attr('content'),
              image: data.current.og['og:image'] ? '' + data.current.og['og:image'] : $('meta[property="og:image"]').attr('content')
            });
          }
          /*
            If current entry is not viewed then initialize big box and RR ads
          */
          debug.log(currentEntry.viewed, 'viewed?', manager.views.behavioralInteraction());
          if (currentEntry && !currentEntry.viewed) {
            manager.updateStoredEntry(currentEntry.url, 'viewed', true);
            var _slotName = SniAds.appendSlot('#dfp_bigbox_' + currentEntry.class + '_1', 'dfp_bigbox');
            SniAds.Event.publish('_newSlotDefined', _slotName, SniAds.getDefinedSlots(_slotName));
          }
          break;
        case 'article-stream.end':
          debug.log(previousEntry);
          if (lastEntry && lastEntry.hasOwnProperty('class') && !config.ended) {
            var last = lastEntry,
                lastClass = last.class,
                nextEntry = manager.getNextEntry(manager.getResponse()),
                lastResponse = void 0,
                lastMdm = void 0,
                lastSeo = void 0;
            if (device.isMobile) {
              $endcap.appendTo($('.' + lastClass).find('.container-site .container-fluid').find('.row')).addClass(config.hardlineClass);
              $nextUp.insertBefore($('.' + config.hardlineClass));
              $nextUp.css('margin-left', '.5rem');
            } else {
              $nextUp.appendTo($('.' + lastClass).find('.container-site').find('.col-md-18'));
              if (last.url) {
                $.get(last.url + '.weRecommend.html', function (data) {
                  if ($('.nextUp').length > 0) {
                    $(data.replace(/data-src/g, 'src')).insertAfter('.nextUp');
                  }
                });
              }
            }
            config.ended = true;
            if (nextEntry) {
              manager.fetchResponse(nextEntry + '.' + config.endpointSelector + '.json').then(function (val) {
                lastResponse = val;
                if (lastResponse.mdManager) {
                  lastMdm = lastResponse.mdManager;
                }
                if (lastResponse.seoMetaData) {
                  lastSeo = lastResponse.seoMetaData;
                }
                if (lastMdm.Url && lastMdm.Url !== '') {
                  $nextUp.find('.m-MediaBlock__m-MediaWrap').find('a').attr('href', '' + lastMdm.Url);
                }
                if (lastSeo['og:image'] && lastSeo['og:image'] !== '') {
                  var newImage = '' + lastSeo['og:image'];
                  if (!device.isMobile) {
                    newImage = newImage.replace(/^(\/.+\.)(\d{3,4})(\.)(\d{3,4})(\.\w+)$/m, '$1231$3174$5');
                  }
                  $nextUp.find('.m-MediaBlock__m-MediaWrap').find('img').attr('src', newImage);
                }
                if (lastMdm.Url && lastMdm.Url !== '') {
                  $nextUp.find('.m-MediaBlock__m-TextWrap').find('a').attr('href', '' + lastMdm.Url);
                }
                if (lastSeo['og:title'] && lastSeo['og:title'] !== '') {
                  $nextUp.find('.m-MediaBlock__a-HeadlineText').text('' + lastSeo['og:title']);
                }
                if (lastSeo['og:description'] && lastSeo['og:description'] !== '') {
                  $nextUp.find('.m-MediaBlock__a-Description').text('' + lastSeo['og:description']);
                }
              }).catch(function (reason) {
                debug.error('addEntry: unable to fetch nextUp: ', reason);
              });
            }
          }
          break;
      }
    }
  };
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperties = __webpack_require__(271);

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _freeze = __webpack_require__(277);

var _freeze2 = _interopRequireDefault(_freeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (strings, raw) {
  return (0, _freeze2.default)((0, _defineProperties2.default)(strings, {
    raw: {
      value: (0, _freeze2.default)(raw)
    }
  }));
};

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(272), __esModule: true };

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(273);
var $Object = __webpack_require__(12).Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(21);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(18), 'Object', { defineProperties: __webpack_require__(131) });


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(55);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(45);
var toLength = __webpack_require__(133);
var toAbsoluteIndex = __webpack_require__(276);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(96);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(278), __esModule: true };

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(279);
module.exports = __webpack_require__(12).Object.freeze;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(24);
var meta = __webpack_require__(134).onFreeze;

__webpack_require__(280)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(21);
var core = __webpack_require__(12);
var fails = __webpack_require__(54);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(135);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(284);
var $Object = __webpack_require__(12).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(21);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(18), 'Object', { defineProperty: __webpack_require__(22).f });


/***/ }),
/* 285 */
/***/ (function(module, exports) {

SNI.Application.addModule('asset-label', function (context) {

  return {
    behaviors: ['popover']
  };
});

/***/ }),
/* 286 */
/***/ (function(module, exports) {

SNI.Application.addModule('asset-multi-media', function (context) {

  // const debug = context.getService('logger').create('module.asset-multi-media');
  var el = context.getElement();
  var $el = $(el);
  var defaultConfig = {
    behaviors: [],
    lastVideoNum: 0,
    isStarted: false
  };
  var store = context.getService('state').createStore('asset-multi-media', {
    data: Object.assign({}, defaultConfig, context.getConfig()),
    computed: {
      videoModule: function videoModule() {
        return $el.find('[data-module=video-embed]');
      },
      videoId: function videoId() {
        return store.videoModule.attr('id');
      }
    },
    methods: {
      getVideoNumber: function getVideoNumber(slide) {
        return parseInt($(slide).attr('data-vid-num'));
      },
      pauseVideo: function pauseVideo(id) {
        context.broadcast('video.pause', { id: store.videoId });
      },
      playVideo: function playVideo(id, videoNum) {
        SNI.Video.Players[id].play(videoNum, true);
      }
    }
  });

  var onmessage = {
    'lightbox.expand': function lightboxExpand() {
      store.playVideo(store.videoId, store.lastVideoNum);
    },

    'lightbox.collapse': function lightboxCollapse() {
      store.pauseVideo(store.videoId);
    },

    'carousel.slide.clicked': function carouselSlideClicked(_ref) {
      var slide = _ref.slide;

      var videoNum = store.getVideoNumber(slide);
      store.lastVideoNum = videoNum;

      // Ensure lightbox is expanded
      // This also causes the video to play
      context.broadcast('lightbox.expand');
    }
  };

  return {
    behaviors: store.behaviors.concat('toggle-on-message'),
    onmessage: onmessage
  };
});

/***/ }),
/* 287 */
/***/ (function(module, exports) {

/**
 * @fileoverview Asset Navigation Module
 * @author Jonathan Kemp
 * @author Igor Alpert
 */

/*
 * Handles the disabling and re-enabling links in certain cases.
 * Adds the affix behavior to the module.
 */
SNI.Application.addModule('asset-navigation', function (context) {
  'use strict';

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------


  var ASSET_NAVIGATION_PREV_ITEMS = 'ASSET_PREV';

  var $el = $(context.getElement());
  var sS = context.getGlobal('sessionStorage');
  var debug = context.getService('logger').create('module.asset-navigation');

  var defaults = {
    disabledClass: 'is-Disabled'
  };

  var _Object$assign = Object.assign({}, defaults, context.getConfig()),
      disabledClass = _Object$assign.disabledClass,
      urls = _Object$assign.urls,
      path = _Object$assign.path;

  var prevLinks = JSON.parse(sS.getItem(ASSET_NAVIGATION_PREV_ITEMS));

  if (!Array.isArray(prevLinks)) {
    prevLinks = [];
  }

  var buildLinks = function buildLinks(_ref) {
    var _ref$urls = _ref.urls,
        urls = _ref$urls === undefined ? [] : _ref$urls,
        _ref$path = _ref.path,
        path = _ref$path === undefined ? '' : _ref$path;

    debug.log({ urls: urls, path: path });

    var previousUrl = $(prevLinks).get(-1);
    var nextUrl = urls.find(function (url) {
      return prevLinks.indexOf(url) === -1;
    });

    var $previous = $el.find('[data-type="previous"]');
    var $next = $el.find('[data-type="next"]');

    if (previousUrl && path !== previousUrl) {
      // Trying to avoid loops
      $previous.attr('href', previousUrl);
    } else if ($(urls).get(1)) {
      // In case we dont have prev link (most likely its first recipe we try to use 2nd item from feed as prev)
      $previous.attr('href', $(urls).get(1));
    } else {
      // We dont have any links to use, just disable button
      $previous.addClass(disabledClass);
    }

    if (nextUrl) {
      $next.attr('href', nextUrl);
    } else {
      $next.addClass(disabledClass);
    }
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    behaviors: ['affix'],

    onclick: function onclick(event, element, type) {
      if ($(element).hasClass(disabledClass)) {
        event.preventDefault();
      }

      switch (type) {

        case 'previous':
          prevLinks.pop();
          break;

        // Before we go mark current page as 'seen'
        case 'next':
          if (prevLinks.indexOf(path) === -1) {
            prevLinks.push(path);
          }
          break;
      }

      sS.setItem(ASSET_NAVIGATION_PREV_ITEMS, JSON.stringify(prevLinks));
    },
    init: function init() {
      buildLinks({ urls: urls, path: path });
    },


    buildLinks: buildLinks
  };
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(289), __esModule: true };

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(144);
__webpack_require__(297);
__webpack_require__(308);
__webpack_require__(309);
module.exports = __webpack_require__(12).Promise;


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(96);
var defined = __webpack_require__(95);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(142);
var descriptor = __webpack_require__(66);
var setToStringTag = __webpack_require__(69);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(31)(IteratorPrototype, __webpack_require__(9)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(32);
var toObject = __webpack_require__(293);
var IE_PROTO = __webpack_require__(97)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(95);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(295);
var step = __webpack_require__(296);
var Iterators = __webpack_require__(56);
var toIObject = __webpack_require__(45);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(140)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 295 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 296 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(68);
var global = __webpack_require__(8);
var ctx = __webpack_require__(64);
var classof = __webpack_require__(145);
var $export = __webpack_require__(21);
var isObject = __webpack_require__(24);
var aFunction = __webpack_require__(65);
var anInstance = __webpack_require__(298);
var forOf = __webpack_require__(299);
var speciesConstructor = __webpack_require__(146);
var task = __webpack_require__(147).set;
var microtask = __webpack_require__(304)();
var newPromiseCapabilityModule = __webpack_require__(100);
var perform = __webpack_require__(148);
var promiseResolve = __webpack_require__(149);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(9)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(305)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(69)($Promise, PROMISE);
__webpack_require__(306)(PROMISE);
Wrapper = __webpack_require__(12)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(307)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 298 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(64);
var call = __webpack_require__(300);
var isArrayIter = __webpack_require__(301);
var anObject = __webpack_require__(23);
var toLength = __webpack_require__(133);
var getIterFn = __webpack_require__(302);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(23);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(56);
var ITERATOR = __webpack_require__(9)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(145);
var ITERATOR = __webpack_require__(9)('iterator');
var Iterators = __webpack_require__(56);
module.exports = __webpack_require__(12).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 303 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(8);
var macrotask = __webpack_require__(147).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(55)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(31);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(8);
var core = __webpack_require__(12);
var dP = __webpack_require__(22);
var DESCRIPTORS = __webpack_require__(18);
var SPECIES = __webpack_require__(9)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(9)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(21);
var core = __webpack_require__(12);
var global = __webpack_require__(8);
var speciesConstructor = __webpack_require__(146);
var promiseResolve = __webpack_require__(149);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(21);
var newPromiseCapability = __webpack_require__(100);
var perform = __webpack_require__(148);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 310 */,
/* 311 */
/***/ (function(module, exports) {

SNI.Application.addModule('collage', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  // let debug = context.getService('logger').create('module.collage');

  var modUtil = context.getService('utility');

  var defaults = {
    numRows: 2,
    gutterWidth: 5,
    imageSizes: { '5': 161, '9': 301, '13': 441 }
  };

  var collage = null;

  var _getRandomBetween = function _getRandomBetween(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  var _shuffle = function _shuffle(array) {
    return array.sort(function () {
      return 0.5 - Math.random();
    });
  };

  /**
    * @source: the array we're sourcing from
    * @index: the index of the item in the source
    * @dest: the destination array of the item
  */
  var _choosePreset = function _choosePreset(source, index, dest) {
    dest.push(source[index]);
    source.splice(index, 1);
  };

  var Collage = function Collage(element, settings) {

    var photoRatios = {
      'square': { scale: 1 },
      'portrait': { scale: 3 / 4 },
      'landscape': { scale: 4 / 3 }
    };

    this.rowPresetChoices = [{
      name: 'small',
      height: 148,
      images: [photoRatios.landscape, photoRatios.portrait, photoRatios.square, photoRatios.square]
    }, {
      name: 'medium',
      height: 197,
      images: [photoRatios.landscape, photoRatios.square, photoRatios.portrait]
    }, {
      name: 'large',
      height: 294,
      images: [photoRatios.landscape, photoRatios.portrait]
    }];

    this.$element = $(element);
    this.$cta = this.$element.find('.m-VisualCta');

    this.rows = [];
    this.chosenRowPresets = [];
    this.rows_total = 0;
    this.image_pool = [];

    this.container = this.$element.find('.m-MediaWrap:visible');
    this.gutter_width = settings.gutterWidth;
    this.rowCount = settings.numRows;
    this.imageSizes = settings.imageSizes;

    // If you've instantiated a Collage, we assume you want to
    // immediately render it. `render` can be called through this
    // module's API if you want to re-calc the layout, re-randomize
    // and re-render at runtime. That's a lot of "r"s.
    this.render();

    var that = this;
    $(window).on('orientationchange', function () {
      that.container.find('.o-Capsule__a-Image').remove();
      setTimeout(function () {
        that.render();
      }, 500);
    });
  };

  Collage.prototype = {

    getCtaUrl: function getCtaUrl() {
      var url = this.$cta.find('[href]').attr('href') || '#';
      this.container.on('click', function (e) {
        window.location.href = url;
        e.preventDefault();
      });
      return url;
    },

    randomize: function randomize() {
      // Generate a subset of images to use for the rows
      // for (var i=0; i <= this.photoFiles.length; i++) {
      //   this.random = _getRandomBetween(0, this.photoFiles.length);
      //   this.image = this.photoFiles[this.random];
      //   this.image_pool.push(this.image);
      //   this.photoFiles.splice(this.random, 1);
      // }

      // To balance out the visualization, we _always_ want to
      // include a "large" row preset (when the `numRows` are exactly 2).
      // So, if we're on the second or, in this case, last iteration
      // and we haven't selected the "large" row preset, then choose it manually.
      var rowCount = this.rowCount;
      var rowPresetChoices = this.rowPresetChoices.slice();
      this.chosenRowPresets = [];

      if (rowCount === 2) {
        rowCount = rowCount - 1;
        _choosePreset(rowPresetChoices, 2, this.chosenRowPresets);
      }

      // Randomly choose rows from the row presets
      for (var j = 0; j < rowCount; j++) {
        this.random = _getRandomBetween(0, rowPresetChoices.length);
        _choosePreset(rowPresetChoices, this.random, this.chosenRowPresets);
      }

      // Randomize further by shuffling the chosen presets
      _shuffle(this.chosenRowPresets);

      // Randomize further by shuffling the photos within this preset
      // for (var k=0, len=this.chosenRowPresets.length; k < len; k++){
      //   _shuffle(this.chosenRowPresets[k].images);
      // }
    },

    calculateLayout: function calculateLayout(row) {
      this.row = row;
      this.row_height = this.row.height;
      this.row_images = this.row.images;

      var x = void 0,
          cur_item = void 0,
          item_width = void 0,
          difference = void 0,
          height = 50,
          item_dimensions = [],
          numItems = this.row.images.length,
          container_width = $('body').hasClass('modded-overlay') ? window.innerWidth : this.container.parent().innerWidth();

      // Start iteratively sizing-up each item in the row
      // until they collectively grow up to, or beyond, the
      // containers' width. but then snap them back to the max width
      this.row = 0;
      while (this.row < container_width) {

        // loop through each item
        for (x = 0; x < numItems; x++) {
          this.image = this.row_images[x];

          // calculate the width and height for each item
          item_width = Math.floor(this.image.scale * height);

          cur_item = {};
          cur_item.width = item_width;
          cur_item.height = height;

          if (height === 463) cur_item.height = 462;

          item_dimensions.push(cur_item);

          // update the row width based on the item widths minus the gutter total
          this.row += item_width;
        }

        this.row = this.row + this.gutter_width * (numItems - 1);

        // reset row width if its less than the container width
        if (this.row < container_width) {
          this.row = 0;
          item_dimensions = [];
        }

        // if the computed row width is greater than the container width calculate
        // the difference and subtract from the last item's width
        if (this.row > container_width) {
          difference = this.row - container_width;
          item_dimensions[item_dimensions.length - 1].width -= difference;
        }

        // add 1 to the min-height/ideal height and repeat
        height += 1;
      }
      return item_dimensions;
    },

    chooseImageRendition: function chooseImageRendition(container, img) {
      var thisSize = void 0,
          imgSizes = Object.keys(this.imageSizes),
          images = [img.attr('data-src-sm'), img.attr('data-src-md'), img.attr('data-src-lg')];

      //just want to ensure all the image sizes are set before we try to use them :)
      for (var i = images.length - 1; i >= 0; i--) {
        if (typeof images[i] !== 'string' || !images[i]) {
          images.pop();
        }
      }
      for (var _i = 0; _i < images.length; _i++) {
        thisSize = Number(this.imageSizes[imgSizes[_i] + '']);
        if (thisSize >= container.width && thisSize >= container.height) {
          return images[_i];
        }
      }
      return images[images.length - 1];
    },

    render: function render() {

      this.randomize();

      // initialization here is important because this
      // controls the iterator that chooses from the image pool.
      // if you want images to be more "randomly" chosen,
      // you could adjust this.
      var n = 0,
          li = void 0,
          image = void 0,
          width = void 0,
          height = 0,
          imageDimensions = void 0,
          rowHeights = [],
          listItems = this.container.find('li');

      this.$imgs = [];

      // Time to render each preset and its calculated layout.
      // Render calls will _always_ re-calculate layout.
      // Rendering is dom-idempotent. In the sense that it will not
      // append the rendered nodes to existing DOM collages. it replaces.
      for (var i = 0; i < this.chosenRowPresets.length; i++) {

        imageDimensions = this.calculateLayout(this.chosenRowPresets[i]);

        // Render to DOM
        for (var y = 0; y < imageDimensions.length; y++) {

          this.image = imageDimensions[y];
          width = this.image.width;
          height = this.image.height;

          image = this.chooseImageRendition(this.image, listItems.eq(n).find('img:first'));

          li = $('<li />', {
            height: height,
            width: width,
            'class': 'o-Capsule__a-Image'
          });

          this.$imgs.push($('<img />', {
            src: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', //1x1 transparent gif
            'data-src': image,
            width: width,
            height: height
          }).appendTo(li));

          li.appendTo(this.container);

          n++;
        }
        rowHeights.push(height);
      }

      this.initLazyLoad(this.$imgs);

      //if more than 2 rows tall, vertically center in the first two rows
      if (this.rowCount > 2) {
        this.$cta.css({
          'transform': 'translate(-50%, 0)',
          'top': (rowHeights[0] + rowHeights[1] - this.$cta.outerHeight() + this.gutter_width) / 2 + this.gutter_width
        });
      }
    },

    initLazyLoad: function initLazyLoad($imgs) {
      var randomString = (Math.random() * 10000000000000000 + '_' + Date.now()).replace(/\./g, ''),
          events = ['scroll.collage-lazyload_' + randomString, 'resize.collage-lazyload_' + randomString];
      var collage = this;

      $(window).on(events.join(' '), function () {
        if ($imgs.length === 0) {
          for (var j = 0; j < events.length; j++) {
            $(window).off(events[j]);
          }
        } else {
          for (var i = 0; i < $imgs.length; i++) {
            if ($imgs[i] && modUtil.isInViewport($imgs[i][0], 'partial')) {
              $imgs[i].hide().filter('[data-src]').one('load', function () {
                $(this).closest('li').css('background-image', 'url(' + $(this).attr('data-src') + ')');
                // don't need now, with theming:  $(this).siblings('.shim').addClass('faded');
                collage.$cta.fadeIn(700);
              }).attr('src', $imgs[i].attr('data-src')).each(function (idx, elt) {
                //Cache fix for browsers that don't trigger .load()
                if (elt.complete) $(elt).trigger('load');
              });

              $imgs.splice(i, 1);
              i--;
            }
          }
        }
      }).trigger(events[0]);
    }

  }; // end prototype


  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------


  var init = function init() {
    var config = Object.assign({}, defaults, context.getConfig());
    collage = new Collage(context.getElement(), config) || collage;
  };

  var destroy = function destroy() {
    collage = null;
  };

  return {
    init: init,
    destroy: destroy
  };
});

/***/ }),
/* 312 */
/***/ (function(module, exports) {

SNI.Application.addModule('content-feed', function (context) {

  // Private

  var debug = context.getService('logger').create('module.content-feed');

  // public

  var module = {

    behaviors: ['load-more', 'lazy-load'],

    init: function init() {
      debug.log('Content Feed Module: Init Start');
    }

  };

  return module;
});

/***/ }),
/* 313 */
/***/ (function(module, exports) {

/**
  * Dropdown Filter: this is used for dropdowns there are generated from an HTML list
  * gives the list dropdown the ability to have a selected state
  */

SNI.Application.addModule('dropdown-filter', function (context) {
  'use strict';

  var element = $(context.getElement()),
      $element = $(element),
      debug = context.getService('logger').create('module.dropdown-filter');

  var defaults = {
    format: 'YYYY-MM-DD'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  return {

    config: config,

    init: function init() {

      var $selectedFilterItem = $element.find('.dropdown-menu').find('.selected');
      var offset = $selectedFilterItem.length ? $selectedFilterItem.position().top : false;
      if (offset) {
        debug.log('dropping down the filter');
        $element.find('.dropdown-menu').scrollTop(offset);
      } else {
        debug.warn('dropdown selected element not found');
      }
    }

  };
});

/***/ }),
/* 314 */
/***/ (function(module, exports) {

SNI.Application.addModule('editorial-promo', function (context) {

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 315 */
/***/ (function(module, exports) {

// iFrame Component for Engage Sciences Sweepstakes and Voting

SNI.Application.addModule('engage-sciences', function (context) {

  var $element = $(context.getElement()),
      debug = context.getService('logger').create('engage-sciences'),
      check = context.getService('check').new(debug),
      loader = context.getService('dependency-loader');

  var defaults = {
    ngxIframeSelector: '',
    preEntrySel: '#pre-entry-content'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  return {
    init: function init() {
      // Hosted by vendor Engage Sciences. This script MUST be included before the iframe
      loader.load(config.ngxScript).then(function () {

        if (!check.exists('SNI.EngageSweepsManager')) {
          debug.error('SNI.EngageSweepsManager not defined! Module not initialized.');
          return;
        }

        var $iframe = config.ngxIframeSelector.length ? $element.find('#' + config.ngxIframeSelector) : [];

        if ($iframe.length === 0) {
          debug.error('An iframe could not be found.  Maybe an ngxId field in CQ was left blank?');
          return;
        }

        SNI.EngageSweepsManager.activate(config.sweepsConfig);

        /* Add Custom State Listeners
        For executing code that is only supposed to run when the iframe returns a certain state.
        Use the SNI.EngageSweepsManager.statusReport(); in the console to find available states of iframe.
          #Pre-Entry-Content Function for Smart Home 2015 Photo of the Day
        Current Implemetation of this requires this code to be added in a script tag on the page, in the CMS:
        $(".pullQuote").attr("id","pre-entry-content");   .pullQuote could be any component on the page */

        $iframe.attr('src', $iframe.attr('data-src')).load(function () {
          SNI.EngageSweepsManager.stateListener('show', function () {
            $(config.preEntrySel).hide();
          });
        });
      }).catch(function () {
        debug.error('failed to load ' + config.ngxScript + '!');
      });
    }
  };
});

/***/ }),
/* 316 */
/***/ (function(module, exports) {

SNI.Application.addModule('episode-feed', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var defaults = {
    dynamicPanelId: '#facets1',
    defaultPanelId: '#facets2',
    tabsSel: '.m-TabbedContent__m-TabNav',
    epCardSel: '.m-EpisodeCard'
  };

  var config = Object.assign({}, defaults, context.getConfig());
  var $element = $(context.getElement());

  /** Returns the time zone of the client. */
  var getZone = function getZone(dateTime) {
    var dst = isDaylightSavings(dateTime);
    var zone = 'eastern';
    switch (dateTime.getTimezoneOffset()) {
      default:
        zone = 'eastern'; // eastern|central|mountain|pacific
        break;
      case 240:
        // GMT -4:00
        zone = 'eastern';
        break;
      case 300:
        // GMT -5:00
        zone = dst ? 'central' : 'eastern';
        break;
      case 360:
        // GMT -6:00
        zone = dst ? 'mountain' : 'central';
        break;
      case 420:
        // GMT -7:00
        zone = dst ? 'pacific' : 'mountain';
        break;
      case 480:
        // GMT -8:00
        zone = 'pacific';
        break;
    }
    return zone;
  };

  /** Returns true if the client is on day light savings. */
  var isDaylightSavings = function isDaylightSavings(date) {
    return date.getTimezoneOffset() < stdTimezoneOffset(date);
  };

  var stdTimezoneOffset = function stdTimezoneOffset(date) {
    var jan = new Date(date.getFullYear(), 0, 1);
    var jul = new Date(date.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  };

  /** extract future epidsodes from Recent tab and put them in Upcoming tab **/
  var makeUpcomingTab = function makeUpcomingTab($element) {
    var now = new Date();
    var zone = getZone(now);
    var upcomingShows = $('<div/>', { 'class': 'load-more-container' });
    var upcomingShowCount = 0;
    var loadMoreShows = $('<div/>');
    var loadMoreList = $('<div>', { 'class': 'list-load-more' });

    // If the client is in the west cost, either mountain of pacific, adj the time before doing the comparison.
    if (zone === 'mountain' || zone === 'pacific') {
      now.setHours(now.getHours() - 3);
    }

    $element.find('[data-time]').each(function (indexInArray, elt) {
      var $elt = $(elt);
      var timestamp = $elt.attr('data-time');
      var airTime = new Date(timestamp);

      var millisPerMinute = 1000 * 60;
      var tenMinutesBeforeInMillis = -10 * millisPerMinute;
      var twentyMinutesAfterInMillis = 20 * millisPerMinute;

      var diff = now.getTime() - airTime.getTime();
      var onNow = tenMinutesBeforeInMillis <= diff && diff < twentyMinutesAfterInMillis;

      if (onNow || now.getTime() < airTime.getTime()) {
        if (upcomingShowCount < 3) {
          upcomingShows.append($elt.clone());
        } else {
          loadMoreShows.append($elt.clone());
        }

        $elt.remove();
        upcomingShowCount++;
      }
    });

    // facet 2
    // this will remove Recently on TV tab if there are 0 results left in the .load-more-container
    if ($(config.defaultPanelId + ' .load-more-container').children().length <= 0) {
      $(config.tabsSel).children().eq(1).remove();
    }

    // if there are upcoming shows add them to facet1
    if ($(upcomingShows).children().length > 0) {
      $(config.dynamicPanelId).prepend(upcomingShows);
    }

    if ($(loadMoreShows).children().length > 0) {
      var appendedList = loadMoreList.append(loadMoreShows.children());
      $(config.dynamicPanelId).append(appendedList);
      $(config.dynamicPanelId).find('.load-more').show();
    }
  };

  // reverse Recent Episodes order: most to least recent
  var reverseRecent = function reverseRecent() {
    var $recentCont = $(config.defaultPanelId);
    var $recentEps = $recentCont.find(config.epCardSel);
    var $newLoadMoreContainer = $('<div class="load-more-container"></div>');
    var $newListLoadMore = $('<div class="list-load-more"></div>');
    var i = void 0;
    var lim = Math.max($recentEps.length - 3, 0);
    // up to 3 shown initially
    for (i = $recentEps.length - 1; i >= lim; i--) {
      $newLoadMoreContainer.append($recentEps.eq(i));
    }
    // any additional initially hidden then shown on demand
    while (i >= 0) {
      $newListLoadMore.append($recentEps.eq(i));
      i--;
    }
    $recentCont.find('.load-more-container, .list-load-more').remove();
    $recentCont.prepend($newLoadMoreContainer).prepend($newListLoadMore);
    if ($recentEps.length > 3) $(config.defaultPanelId).find('.load-more').show();
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  var init = function init() {

    makeUpcomingTab($element);

    // existing impl doesn't work at all-- not even a ul -- new impl reverseRecent() method above
    // Reverse the order of the li for facet2, the recently aired shows.
    // let ul = $(settings.defaultPanelId).find('ul');
    // ul.children('li').each(function(i, li) { ul.prepend(li); });
    reverseRecent();
  };

  return {

    init: init,

    behaviors: ['tab']

  };
});

/***/ }),
/* 317 */
/***/ (function(module, exports) {

SNI.Application.addModule('episode-list', function (context) {

  return {
    behaviors: ['truncate']
  };
});

/***/ }),
/* 318 */
/***/ (function(module, exports) {

SNI.Application.addModule('footer', function (context) {
  'use strict';

  /*  Simple module to handle scroll top link with animation  */

  return {
    behaviors: ['lazy-load', 'hover-intent'],
    onclick: function onclick(event, element, elementType) {
      if (elementType === 'scroll-top') {
        event.preventDefault();
        $(document.body).animate({ scrollTop: 0 }, 200);
      }
    }
  };
});

/***/ }),
/* 319 */
/***/ (function(module, exports) {

SNI.Application.addModule('full-width-promo', function (context) {

  return {
    behaviors: ['lazy-load', 'multi-component-dynamic-ad']
  };
});

/***/ }),
/* 320 */
/***/ (function(module, exports) {

SNI.Application.addModule('gigya/commentsLink', function (context) {

  var debug = context.getService('logger').create('module.gigya.commentsLink');

  var _context$getService = context.getService('gigya/comments'),
      addStreamItem = _context$getService.addStreamItem;

  var element = context.getElement();
  var $element = $(element);

  var defaults = {
    commentsLink: '',
    setIndex: 0,
    setCount: 1,
    context: {}
  };

  var config = Object.assign({}, defaults, context.getConfig());

  function init() {

    debug.log('init', $element);

    if (!config.streamID) {

      debug.log('Cannot render CommentLink without module config: streamID');
      return;
    }

    if (config.setName) {
      // Set up for gigya API call
      this.params = {
        containerID: config.containerID,
        streamID: config.streamID,
        categoryID: config.categoryID,
        context: this,
        commentsLink: config.commentsLink
      };

      if (config.setName) {
        if (!config.setCount) {
          debug.warn('CommentLink total items missing');
          return;
        }

        this.params.setName = config.setName;
        this.params.setCount = Number(config.setCount);

        debug.log('Adding to ' + config.setName + ' item ' + (config.setIndex || 0) + ' of ' + config.setCount, this.params);
        addStreamItem(this.params);
      }
    }
  }

  return {
    messages: ['gigya_stream_info'],
    init: init,
    onmessage: function onmessage(name, data) {
      debug.log('Message', name, data);
      if (name === 'gigya_stream_info') {
        /*
            categoryID
            commentCount
            isUserSubscribed
            moderationMode
            moderationModes
            ratingCount
            rssURL
            status
            streamID
            threadCount
            */
        var _data$streamInfo = data.streamInfo,
            approvedCommentCount = _data$streamInfo.approvedCommentCount,
            streamID = _data$streamInfo.streamID;

        if (config.streamID === streamID) {
          $element.find('#' + config.containerID).html('<a href="' + config.commentsLink + '">(' + approvedCommentCount + ') Comment' + (approvedCommentCount !== 1 ? 's' : '') + '</a>');
        }
      }
    }
  };
});

/***/ }),
/* 321 */
/***/ (function(module, exports) {

SNI.Application.addModule('gigya/comments', function (context) {

  /***
     Private Methods
  */
  var _context$getService = context.getService('gigya/comments'),
      showCommentsUI = _context$getService.showCommentsUI,
      getStreamInfo = _context$getService.getStreamInfo,
      getCommentInfo = _context$getService.getCommentInfo,
      getPageID = _context$getService.getPageID,
      tpl = context.getService('gigya/templates'),
      moderation = context.getService('gigya/moderation'),
      mdManager = context.getGlobal('mdManager'),
      debug = context.getService('logger').create('module.gigya/comments'),
      device = context.getService('device-type'),
      account = context.getService('gigya/account');

  /**
    * Handle comments UI loading error - currently only shows and error msg
    * @param {object} res - an object with the error reported by Gigya
    */


  function clientLoadError(res) {
    // Notify of error
    debug.log(res);
  }

  /**
      Run when comments are loaded
      @param {object} eventObj - passed in by gigya
  */
  function doCommentOnLoad(eventObj) {

    var params = eventObj.sourceData,
        context = eventObj.context;

    context.publishRatings = true;
    params.includeRatingDetails = true;
    params.context = context;

    if (context.isRatings) {
      getStreamInfo(params);
    }

    // Mobile hide composebox
    if (device.isMobile && context.hideComposeBox) {
      var $box = $('#' + context.containerID).find('.gig-comments-composebox');
      $box.addClass('comments-main-box').hide();
    }
  }

  /**
   * Handle stream info pub event (deprecated the callback approach)
   * @param {object} eventObj - an object that contains context and stream Info
   */

  function processStream(eventObj) {
    var streamInfo = eventObj.streamInfo,
        context = eventObj.context;

    var commentCount = streamInfo.commentCount;
    var hideDivIfNoComments = context && context.hideDivIfNoComments ? context.hideDivIfNoComments : false;

    if (hideDivIfNoComments && commentCount <= 0) {
      $(hideDivIfNoComments).hide();
    }
  }

  /**
      Handle comment submitted event (only one task is being run but it could potentially do more)
      @param {object} eventObj - An object passed in by Gigya which will be passed on to comments moderation service
    */
  function doCommentSubmitted(eventObj) {
    handleModerationOnCommentSubmitted(eventObj);
  }

  /**
    * Comment moderation - pass the comment to the moderation service
    * @param {object} eventObj - Comment to be moderated w/properties
    */
  function handleModerationOnCommentSubmitted(eventObj) {

    // User data
    var user = eventObj.user,
        comment = eventObj && eventObj.comment || {};

    comment.categoryId = eventObj.categoryID;

    moderation.processComment({ user: user, comment: comment });
  }

  /**
   * Cleans up the classes on a replybox after the cancel button has been clicked.
   * When cancel is clicked, gigya inercepts the before it gets to T3, therefore we
   * can't determine which cancel button was just clicked to clean up it's parent classes
   * (as that cancel button is no longer in the DOM). This method just reapplies the 'closed'
   * state classes to every empty replybox currently on the page.
   */
  function clearReplyBox() {
    $('[data-replybox]:empty').attr('class', 'gig-comment-replybox gig-comments-composebox').closest('.gig-comment').removeClass('is-showingReply');
    // Ensure closest comment has is-shown to false
  }

  /*
    Init
  */

  function init() {

    // SET UP
    var $elem = this.$elem = $(context.element);
    var moduleConfig = context.getConfig();

    // Gigya - get config from module
    var containerID = moduleConfig.containerID,
        categoryID = moduleConfig.categoryID,
        step = moduleConfig.step,
        commentTags = moduleConfig.commentTags,
        filterTags = moduleConfig.filterTags,
        modURL = moduleConfig.modURL;

    var configStreamID = moduleConfig.streamID;
    // Set Mod URL
    var URL = modURL || '';
    if (URL) moderation.setModURL(URL, 'comments');

    var commentType = moduleConfig.type || 'comment'; // comment or review
    var pageID = getPageID();
    var streamID = configStreamID || pageID; // FN reviews pass the stream ID through x-config
    var site = mdManager.getSite();

    // Get templates (the templates returned are strings)
    var TEMPLATES = tpl.getTemplates({ layout: site, commentType: commentType });

    // Set up config object
    var params = this.params = {
      categoryID: categoryID,
      streamID: streamID,
      version: 2,
      context: {},
      containerID: containerID,
      cid: '',
      commentTags: commentTags || '',
      filterTags: filterTags || '',
      enabledShareProviders: 'facebook,twitter,googleplus',
      hideShareButtons: true,
      showLoginBar: true,
      useHiResIcons: true,
      hideDivIfNoComments: '.hideDiv',
      templates: TEMPLATES.ALL,
      onLoad: doCommentOnLoad,
      onError: clientLoadError,
      onCommentSubmitted: doCommentSubmitted,
      useSiteLogin: true,
      onSiteLoginClicked: account.showLoginScreen,
      width: '100%',
      customLang: {
        overall_rating: 'Your Rating',
        write_a_comment: 'Write your comment (required)',
        write_a_review: 'Post Review',
        post_your_review: 'Post Review',
        post_your_comment: 'Post Comment'
      }
    };

    // Add some properties to the context object that will be passed by Gigya
    params.context.hideDivIfNoComments = params.hideDivIfNoComments;

    if (commentType === 'ratings') {
      params.context.isRatings = true;
    }

    // Save for later
    this.$container = $elem.find('.social-comments-container');

    // Mobile hide TOP compose box
    if (device.isMobile) {

      this.isMobile = device.isMobile;

      var oldContainerID = containerID;
      containerID += '-wrapper';

      var $addAnchor = $('<a/>').attr('href', '#').attr('data-type', 'comment-show-compose').text('Add Your ' + (commentType === 'comment' ? 'Comment' : 'Review')).addClass('m-Comments__a-Button');

      var $composeWrapper = $('<div/>').attr('id', containerID).addClass('comment-compose-wrapper');

      this.$container = $elem.find('.comment-compose-wrapper');

      var $oldContainer = $('#' + oldContainerID);

      $oldContainer.append([$addAnchor, $composeWrapper]);

      if (step) $oldContainer.hide(); // do not hide recipe

      params.context.hideComposeBox = true;
      params.context.containerID = containerID;
      params.containerID = containerID;
    }
    //  (DIY ONLY)
    //  Check to see if this a Step comment, if it is, defer init until we have stream info
    if (!step) {
      // it is not a DIY comment, call the comments UI service
      showCommentsUI(params);
      this.showComments = false;
    } else {
      // request stream info, init later
      this.step = step;
      // Hide H2 on DIY
      var $h2 = this.$elem.find('h2');
      $h2.hide();

      var $toggleDiv = this.$toggleDiv = $('<div class="toggle-comments hideBtn"></div>');
      $toggleDiv.insertBefore($h2);

      var $addComment = $('<a/>').text('Add a Comment').addClass('comment-add-link').attr('data-type', 'toggle-btn');

      // on DIY custom markup is added above the gigya container
      this.$toggleDiv.append($addComment);

      this.$elem.css('display', 'block');

      getCommentInfo({ streamID: streamID, categoryID: categoryID, tags: filterTags.split(', '), context: { step: step } });
    }
  }

  return {
    behaviors: ['gigya/remove-inline-styles'],
    messages: ['gigya_stream_info', 'gigya_comment_info'],
    init: init,
    showComments: true,
    replyShowing: false,
    commentText: '',
    onclick: function onclick(e, element, elementType) {
      // show hide comments
      // Get DYI specific markup that can be updated on clicks
      var $addComment = this.$elem.find('.comment-add-link'),
          $commentCount = this.$elem.find('.comment-hide-link'),
          $span = this.$elem.find('.comment-count-sep');

      // Cache $ refs for gigya custom behaviors
      var $currentElement = $(element);
      var $parent = $currentElement.closest('.gig-comment');
      var $composeWrapper = this.$elem.find('.comments-main-box');

      // debug.log('elementType', elementType);

      /* Custom behaviors for Gigya buttons are defined below
      *   1. Show more options - shows options footer on each comment on mobile
      *   2. Show compose box on Mobile
      *   3. Toggle reply box on a specific comment
      *   4. Show Comment replies on a specific comment
      *   5. Handle the cancel link next to the post button
      *   6. DIY only - Toggle the entire comments module
      */

      switch (elementType) {
        //  1
        case 'comment-more-options':
          $parent.find('.comment-footer-options').removeClass('is-Hidden');
          $currentElement.hide();
          e.preventDefault();
          break;
        //  2
        case 'comment-show-compose':
          e.preventDefault();
          $composeWrapper.show();
          $currentElement.hide();
          break;
        //  3
        case 'comment-reply-toggle':
          if ($parent.hasClass('is-showingReply')) {
            $currentElement.removeClass('gig-comment-replyLink-active');
            var $cancel = $parent.find('.gig-composebox-cancel');
            var $wrapper = $cancel.parent();
            $cancel.click();
            $wrapper.remove();
            $parent.removeClass('is-showingReply');
            clearReplyBox();
          } else {
            clearReplyBox();
            $currentElement.addClass('gig-comment-replyLink-active');
            if (this.isMobile) {
              var pos = $currentElement.offset().top;
              $(document).scrollTop(pos - 20); // auto scroll input box into view
              $parent.find('.gig-comment-replybox').show();
            }
            $parent.find('.gig-composebox-cancel').show();
            $parent.addClass('is-showingReply');
          }
          e.preventDefault();
          break;
        //  4
        case 'comments-show-link':
          if ($currentElement.hasClass('is-showingComments')) {
            $currentElement.removeClass('is-showingComments').find('.comments-show-text').text('Show');
          } else {
            $currentElement.addClass('is-showingComments').find('.comments-show-text').text('Hide');
          }
          e.preventDefault();
          e.stopPropagation();
          break;
        //  5
        case 'comments-cancel-btn':
          $('.gig-comment-replyLink').removeClass('gig-comment-replyLink-active');
          clearReplyBox();
          // $parent.find('[data-replybox]').removeClass('gig-composebox-open');
          break;
        //  6
        case 'toggle-btn':
          // remember toggle state using this.showComments (Applies to entire module)
          if (this.showComments) {
            // init comments UI
            showCommentsUI(this.params);
            this.showComments = false;

            this.$elem.find('h2').css('display', 'block'); // cannot use show(), must explicitly set display block

            if (this.isMobile) {
              this.$elem.find('.social-comments-container').show();
            }

            $addComment.text('Hide Comments');
            $commentCount.hide();
            $span.hide();
          } else {
            // remove comments UI  using the CANCEL button on the gigya API and by setting the inner HTML to blank afterwards
            this.$container.find('.gig-composebox-cancel').click();
            this.$container.html(''); // clear the DOM
            this.$container.removeClass('gig-composebox-open');

            // update the markup
            $addComment.text('Add a Comment');
            $commentCount.show();
            $span.show();
            this.$elem.find('h2').hide();
            this.$elem.find('.social-comments-module').hide(); // Temporary while old styles are re-enabled
            this.showComments = true;

            if (this.isMobile) {
              this.$elem.find('.social-comments-container').hide();
              this.$elem.find('a[data-type="comment-show-compose"]').show();
            }
          }
          break;
      }
    },
    onmessage: function onmessage(name, data) {

      var streamID = data.streamInfo && data.streamInfo.streamID;

      switch (name) {
        case 'gigya_stream_info':
          if (streamID === this.params.streamID && !this.step) {
            // applies to non-step comment types
            // process stream (hide comments div, etc.)
            processStream(data);
          }
          break;
        case 'gigya_comment_info':
          if (this.step === data.context.step) {
            var commentCount = data.commentCount;

            if (!commentCount) {
              debug.log('Filtered comment data error.');
              return;
            }

            var commentText = this.commentText = commentCount + ' Comment' + (commentCount === 1 ? '' : 's');
            var $commentCount = $('<a />').text(commentText).addClass('comment-hide-link').attr('data-type', 'toggle-btn'),
                $span = $('<span>|</span>').addClass('comment-count-sep').css({ padding: '10px' });

            // on DIY custom markup is added above the gigya container
            this.$toggleDiv.append([$span, $commentCount]);
          }
          break;
      }
    }
  };
});

/***/ }),
/* 322 */
/***/ (function(module, exports) {

/**
* Login modal module
* The markup is loaded dynamically via screensets, this module shoould be started then
*/
SNI.Application.addModule('login-registration', function (context) {
  var gigyaSvc = context.getService('gigya'),
      debug = context.getService('logger').create('module.gigya.registration.module'),
      url = gigyaSvc.getSiteURL(),
      mdManager = context.getGlobal('mdManager'),
      $elem = void 0;

  function init() {
    var promoTxt = gigyaSvc.configGS('reg_promo_text') || 'Promo text',
        site = (url || mdManager.getSite().toUpperCase()) + '\'s';
    debug.log('init reg screen');
    $elem = $(context.element);

    if (promoTxt) {
      $elem.find('.gigya-core-promote').prepend('<span>' + promoTxt + '</span>');
      $('.gigya-core-promote-default').show();
    }

    $elem.find('.gigya-core-sitename').text(site);
  }

  function destroy() {
    $elem = null;
  }

  return {
    behaviors: ['gigya/screens'],
    init: init,
    destroy: destroy
  };
});

/***/ }),
/* 323 */
/***/ (function(module, exports) {

/**
* Profile page module
* if a user is logged in we inset the profile screenset
* edit fields name and nickname etc
* resize photo
* send to cloudinary service
*/
SNI.Application.addModule('profile-page', function (context) {

  var gigyaSvc = context.getService('gigya'),
      config = context.getConfig(),
      debug = context.getService('logger').create('module.gigya.profile'),
      moderation = context.getService('gigya/moderation');

  var moderatedFields = gigyaSvc.account.getModeratedFields(); // used to dynanically populate some fields
  var DEFAULT_AVATAR = 'https://cdns.gigya.com/gs/i/comments2/Avatar_empty_x3.png';

  if (!config.moderationURL) {
    debug.error('Moderation URL missing, profiles is not available');
    return false;
  }
  moderation.setModURL(config.moderationURL, 'profile');

  // Alias the account insert profile action i.e. show the profile screen
  var _gigyaSvc$account = gigyaSvc.account,
      insertProfile = _gigyaSvc$account.insertProfile,
      getProfileInfo = _gigyaSvc$account.getProfileInfo;

  // add photo and button

  var avatarUI = function avatarUI(eventObj) {
    var defaultAvatar = DEFAULT_AVATAR,
        gigyaData = eventObj,
        $profileImg = $('#fnCommunityAvatarImg');
    var profileAvatar = gigyaData && gigyaData.profile && gigyaData.profile.photoURL;
    /*  use profile avatar or DEFAULT if there is no avatar */
    var avatar = profileAvatar || defaultAvatar,
        fixedAvatar = avatar.replace('http://', '//'); // Fix http social uploads
    $profileImg.attr('src', fixedAvatar);

    /*  If we are not using default then show the remove link and set a max height*/
    if (avatar !== DEFAULT_AVATAR) {
      $('#btn-profile-remove').show();
      $('#fnCommunityAvatarImg').css({ 'max-height': '100px' });
    }
  };

  var afterProfileLoad = function afterProfileLoad(eventObj) {
    debug.log('render avatar & init social upload');
    avatarUI(eventObj);

    var displayData = getProfileInfo(eventObj),
        tempNickName = '',
        nickname = void 0,
        email = void 0;

    // display fields from TEMP or Profile (illusion of live)
    moderatedFields.forEach(function (field) {
      var target = '#data-' + field;
      var value = displayData[field];

      if (field === 'nickname' && value === '') {
        debug.log('Nickname is completely empty.  Falling back to email.');
        email = displayData['email'];
        tempNickName = email.split('@')[0];
        nickname = tempNickName;
        value = nickname || 'Anonymous'; // Default nickname to first 10 chars of email or to Anonymous as a last resort
      }
      if (field === 'email') {
        // Do not change email directly since it is populated by gigya
        $('#fnCommunityEditEmail').val(value);
        $('#fnCommunityEditProfileEmail').val(value);
      } else {
        $(target).val(value);
      }
    });

    gigyaSvc.socialUpload.init(config);

    debug.log('Profile is displaying the following data: ' + displayData);
  };

  // if logged in show profile info on page
  var messageHandlers = {
    'gigya.isloggedIn': function gigyaIsloggedIn() {
      insertProfile({ afterProfileLoad: afterProfileLoad });
    },
    'gigya.isloggedOut': function gigyaIsloggedOut() {
      debug.log('take user out of this page');
      location.href = '/';
    }
  };

  return {
    behaviors: ['gigya/profile'],

    messages: Object.keys(messageHandlers),
    onclick: function onclick(event, element, elementType) {
      if (elementType === 'btn-profile-remove') {
        debug.log('clicked on remove');
        event.preventDefault();
        var $avatar = $('#fnCommunityAvatarImg'),
            $hidden = $('#fnCommunityAvatarHiddenField'),
            $thumbnail = $('#fnCommunityThumbnailHiddenField'),
            avatarURL = $avatar.data('old-img') || DEFAULT_AVATAR,
            hiddenURL = $hidden.data('old-img') || DEFAULT_AVATAR,
            hiddenThumbnail = $thumbnail.data('old-img' || DEFAULT_AVATAR);

        //  set back to old values - or reset to blanks
        $avatar.attr('src', avatarURL);
        $hidden.val(hiddenURL);
        $thumbnail.val(hiddenThumbnail);

        $('#btn-profile-remove').hide();
      }
    },
    onmessage: function onmessage(message, data) {
      messageHandlers[message](data);
    }
  };
});

/***/ }),
/* 324 */
/***/ (function(module, exports) {

SNI.Application.addModule('gigya/ratings', function (context) {

  var debug = context.getService('logger').create('module.gigya.ratings');
  var device = context.getService('device-type');

  var _context$getService = context.getService('gigya/comments'),
      addStreamItem = _context$getService.addStreamItem,
      ratingSets = _context$getService.ratingSets;

  var element = context.getElement();
  var $element = $(element);
  var scrollToElement = void 0;

  var REVIEWS_TARGET = '#reviewsTop';

  var defaults = {
    useRatingSum: true,
    summaryContainer: '[data-review-summary]',
    starsClassName: 'm-Rating__a-StarsLink',
    noReviewsClassName: '',
    ratingLink: ''
  };

  //when instantiated from within the following selectors,
  //hide stars when no ratings have been submitted and hide review count when no reviews have been submitted
  var HIDE_EMPTY_IN_CONTEXTS = ['[data-module="jukebox"]', '[data-module="editorial-promo"]', '[data-module="multi-content-stream"]'];

  var hiddenCls = 'is-Hidden';

  // config contains: streamID, containerID, categoryID, containerID, summaryType and widgetType
  var config = Object.assign({}, defaults, context.getConfig());

  var MAXSTARS = 5;

  var HTML_STAR_FULL = '<div class="gig-rating-star gig-rating-star-full"></div>',
      HTML_STAR_HALF = '<div class="gig-rating-star gig-rating-star-half"></div>',
      HTML_STAR_EMPTY = '<div class="gig-rating-star gig-rating-star-empty"></div>';

  /***    RATINGS API
   *      Ratings are a type of comments with additional features
  */

  /**
   * A JS template that returns the final custom markup string with stars and total reviews link
   * @param {object} values
   */
  function renderStarsLink(values) {
    var IS_ALLOWED_EMPTY = $element.closest(HIDE_EMPTY_IN_CONTEXTS.join(',')).length === 0;
    var AVGRATING = values.AVGRATING,
        MAXRATING = values.MAXRATING,
        STARS = values.STARS,
        TOTAL_REVIEWS = values.TOTAL_REVIEWS;

    var REVIEW_COUNT = TOTAL_REVIEWS;
    //  build starts and link
    var RATINGS_MARKUP = '<span class="gig-rating-stars ' + (!IS_ALLOWED_EMPTY && REVIEW_COUNT < 1 ? hiddenCls : '') + '" title="' + AVGRATING + ' of ' + MAXRATING + ' stars">' + STARS + '</span>';
    var REVIEWS_MARKUP = '<span class="gig-rating-ratingsum ' + (!IS_ALLOWED_EMPTY && REVIEW_COUNT < 1 ? hiddenCls : '') + '">' + REVIEW_COUNT + ' Review' + (REVIEW_COUNT === 1 ? '' : 's') + '</span>';
    return '' + (RATINGS_MARKUP + (config.useRatingSum ? REVIEWS_MARKUP : ''));
  }

  function starsMarkup(ratings) {
    var stars = ratings.stars,
        halfstar = ratings.halfstar;


    var html = stars.map(function (s) {
      return HTML_STAR_FULL;
    });
    var diff = MAXSTARS - stars.length;

    if (halfstar) {
      html.push(HTML_STAR_HALF);
      --diff;
    }

    for (var i = 0; i < diff; i++) {
      html.push(HTML_STAR_EMPTY);
    }

    return html;
  }

  /**
    * Returns an object that has parsed out decimal and integer parts of a rating.  Reuses FN's string parsing logic
    * @param {number} - the rating value
  */
  function splitRatings(n) {
    //make sure number is passed in
    if (typeof n !== 'number') {
      debug.log('ratings value is not valid - cannot provide ratings UI');
      return;
    }
    //convert to string and split into array
    var m = n.toString().split('.');
    // convert back into numbers
    // convert full number
    var fullStars = parseInt(m[0]),
        stars = [];
    // if a remainder exist convert that
    var count = m.length,
        halfstar = false;

    if (count > 0) {
      var remainderVal = parseInt(m[1]);
      // round up or down
      if (remainderVal !== undefined) {
        if (remainderVal > 5) {
          fullStars++;
        } else if (remainderVal <= 5) {
          halfstar = true;
        }
      }
    } else {
      fullStars = Math.floor(n);
    }

    // save into index number into new array
    for (var i = 0; fullStars > i; i++) {
      stars.push(i);
    }

    return {
      n: n,
      stars: stars,
      halfstar: halfstar,
      fullStars: fullStars
    };
  }

  /*
    Returns the Rating stars HTML to display to users
      @param params
    @return ratingStarsHTML
  */
  function getRatingUI(rrInfo, stars) {

    var AVGRATING = rrInfo.avgRating;
    var TOTAL_REVIEWS = rrInfo.reviewsCount;
    var STARS = stars.join('');

    var values = {
      AVGRATING: AVGRATING,
      MAXRATING: MAXSTARS,
      STARS: STARS,
      TOTAL_REVIEWS: TOTAL_REVIEWS
    };

    var ratingStarsHTML = renderStarsLink(values); //  Stars Markup & Reviews Link
    var $summary = $('<a />').addClass(config.starsClassName).html(ratingStarsHTML).attr('href', config.ratingLink + REVIEWS_TARGET);

    return $summary;
  }

  function getRatingStars(rrInfo) {
    var avgRating = rrInfo.avgRating; // Ratings and reviews stream Info

    var ratings = splitRatings(avgRating);
    var html = starsMarkup(ratings); // build stars markup using parsed rating value
    var widgetMarkup = getRatingUI(rrInfo, html); // get stars and review link markup
    return widgetMarkup;
  }

  function init() {

    var setCount = 1; // Set count is 1 by default, unless we can count the total rating atoms in the page

    if (!config.streamID) {
      debug.log('Cannot render rating stars without module config: streamID');
      return; // exit early - need to get param stream from global config?
    }

    if (!config.widgetType || config.setName) {
      // Set up for gigya API call
      this.params = {
        containerID: config.containerID,
        streamID: config.streamID,
        categoryID: config.categoryID,
        context: this,
        linkedCommentsUI: config.linkedCommentsUI,
        showCommentButton: false
        //showReadReviewsLink: false,
        //onLoad: null
      };

      if (config.setName) {
        if (!config.setCount) {
          debug.warn('ratings total items missing');
          return;
        }

        this.params.setName = config.setName;
        this.params.setCount = Number(config.setCount);
        // Construct sets when counts are possible
        if (config.isRatingAtom) {
          if (!ratingSets.atoms) ratingSets.atoms = $('[data-type="rating/atom"]');
          setCount = ratingSets.atoms.length;
          if (setCount > 0) {
            this.params.setName = 'atoms';
            this.params.setCount = Number(setCount);
          }
        }

        debug.log('Adding to ' + this.params.setName + ' item ' + config.setIndex + ' of ' + this.params.setCount);
        addStreamItem(this.params);
      }
    }
  }

  return {
    behaviors: ['gigya/remove-inline-styles'],
    messages: ['gigya_stream_info', 'gigya_ready', 'gigya.isloggedIn'],
    init: init,
    getRatingStars: getRatingStars,

    onclick: function onclick(e, element, elementType) {
      switch (elementType) {
        case 'comment-show-compose':
          if (device.isMobile) {
            scrollToElement = REVIEWS_TARGET;
          }
          break;
      }
    },
    onmessage: function onmessage(name, data) {
      // message type
      switch (name) {
        case 'gigya.isloggedIn':
          if (data && scrollToElement) {
            var $reviews = $(scrollToElement);
            if ($reviews.length) {
              $('html, body').animate({ scrollTop: $reviews.position().top });
              scrollToElement = undefined;
            }
          }
          break;
        case 'gigya_stream_info':
          /*
            threadCount = Number of reviews including reviews without ratings
            approvedCommentCount = Total number of Reviews + Comments
            ratingCount = Number of reviews with ratings - not in use
          */
          var _data$streamInfo = data.streamInfo,
              streamID = _data$streamInfo.streamID,
              approvedCommentCount = _data$streamInfo.approvedCommentCount,
              threadCount = _data$streamInfo.threadCount,
              avgRatings = _data$streamInfo.avgRatings;

          var avgRating = avgRatings && avgRatings._overall;
          //  We are counting reviews without ratings, hence the ratingCount = threadCount
          //  rrInfo = Ratings and Reviews Info
          var rrInfo = { avgRating: avgRating, reviewsCount: threadCount, commentCount: approvedCommentCount };
          var stars = void 0;

          if (typeof avgRating === 'undefined') return; // exit early since there's no ratings data

          //Display summary based off of summaryType
          var summary = '';
          var summaryType = config.summaryType;

          if (summaryType === 'reviews') {
            // summary = `<a href="${config.ratingLink + REVIEWS_TARGET}">${ratingCount} Review${ratingCount === 1?'':'s'}</a>`;
          } else if (summaryType === 'comments') {
            summary = approvedCommentCount + ' Comment' + (approvedCommentCount === 1 ? '' : 's');
          } else if (!approvedCommentCount) {
            summary = 'Be the first to review';
          } else {
            var totalComments = approvedCommentCount - threadCount;
            if (threadCount > approvedCommentCount) {
              debug.warn('Thread Count exceeds comment count.');
              totalComments = threadCount;
            }
            summary = threadCount + ' Review' + (threadCount === 1 ? '' : 's') + ', ' + totalComments + ' Comment' + (totalComments === 1 ? '' : 's');
          }

          if (config.streamID === streamID) {

            // Remove "no reviews" styling if comments found
            if (config.noReviewsClassName && approvedCommentCount) {
              $element.removeClass(config.noReviewsClassName);
            }

            // widget type
            switch (config.widgetType) {
              case 'summary':
                stars = this.getRatingStars(rrInfo);
                var summaryContainer = $element.find(config.summaryContainer);
                var ratingsContainer = $element.find('#' + config.containerID);

                if (summaryContainer.length) {
                  ratingsContainer.html(summary);
                  summaryContainer.html(stars);
                } else {
                  ratingsContainer.html([stars, summary]);
                }

                break;
              case 'stars-link':
                stars = this.getRatingStars(rrInfo);
                $element.find('#' + config.containerID).html(stars);
                break;
              default:
                break;
            }
          }
          break;
        default:
          break;
      }
    }
  };
});

/***/ }),
/* 325 */
/***/ (function(module, exports) {

SNI.Application.addModule('header-mobile', function (context) {
  var debug = context.getService('logger').create('module.mobile-header');
  var $element = $(context.getElement());
  var ads = context.getService('ads');
  var utility = context.getService('utility');
  var $siteNav = void 0;
  var menuState = false;

  var defaults = {
    setNavTop: true,
    searchExposed: false,
    openClass: 'is-Open',
    activeClass: 'is-Active',
    searchOpenClass: 'has-OpenSearch',
    navMenuSel: '[data-module="mobile-nav"]',
    navButtonSel: '[data-type="button-header-nav"]',
    searchBoxSel: '[data-mobile-search-box]',
    searchInputSel: '[data-type="search-input"]'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  var behaviors = ['toggle-on-message'];

  if (config.dropdowns) {
    behaviors.push('hover-intent');
  }

  function toggleNav(state) {
    var $menuBtn = $element.find(config.navButtonSel);
    menuState = state = typeof state === 'undefined' ? !menuState : state;
    toggleSearch(false);
    setNavTop();
    $menuBtn.toggleClass(config.activeClass, state);
    $siteNav.toggleClass(config.openClass, state);
    context.broadcast(state ? 'mobileNav.show' : 'mobileNav.hide');
    $element.find('[data-type="button-close"]').toggle(state);
    if (state) {
      utility.bindClickOutside($siteNav, 'mobile-header-nav', function (e) {
        toggleNav(false);
      }, $menuBtn[0]);
    } else {
      utility.unbindClickOutside('mobile-header-nav');
    }
  }

  function setNavTop() {
    if ($siteNav.length) {
      if (config.setNavTop) {
        $siteNav.css('top', $element.position().top + $element.outerHeight(true));
      }
    } else {
      debug.error('mobile nav not found!');
    }
  }

  function toggleSearch(state) {
    if (config.searchExposed) return;
    var $searchWrap = $element.find(config.searchBoxSel);
    if (state) {
      toggleNav(false);
      // $('html, body').animate({ scrollTop: 0 });
      utility.bindClickOutside($searchWrap, 'mobile-header-search', function (e) {
        toggleSearch(false);
      });
    } else {
      utility.unbindClickOutside('mobile-header-search');
      $element.find(config.searchInputSel).val('');
    }
    $searchWrap.toggleClass(config.openClass, state);
    $element.toggleClass(config.searchOpenClass, state);
    if (state) {
      $element.find(config.searchInputSel).focus();
    }
  }

  var messageObject = {
    'mobile-nav.toggle': function mobileNavToggle(state) {
      toggleNav(state);
    }
  };

  return {

    config: config,

    behaviors: behaviors,

    init: function init() {
      utility.addJavaScriptCssClass();

      $siteNav = $(config.navMenuSel);

      //keep menu in the right position even after ads load
      ads.event.subscribe('slotRenderComplete', function (slotName, slot) {
        setNavTop();
      });

      // Added this because the typeahead plugin is eating events
      $('[data-type=button-search-cancel]').click(function (event) {
        event.preventDefault();
        toggleSearch(false);
      });
    },

    onclick: function onclick(event, element, elementType) {
      if (elementType === 'button-header-nav') {
        event.preventDefault();
        toggleNav();
      }
      if (elementType === 'button-search-open') {
        event.preventDefault();
        toggleSearch(true);
      }
    },


    messages: Object.keys(messageObject),

    onmessage: function onmessage(name, data) {
      messageObject[name](data);
    }
  };
});

/***/ }),
/* 326 */
/***/ (function(module, exports) {

SNI.Application.addModule('header', function (context) {
  'use strict';

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var defaults = {};
  var config = Object.assign({}, defaults, context.getConfig());
  var debug = context.getService('logger').create('module.header');
  var behaviors = ['hover-intent'];

  // Turn new gigya features on or off depending on config
  if (SNI.Config.useGigyaLogin) {
    behaviors.push('gigya/handle-login', 'gigya/login');
    debug.log('Gigya login activated by OSGI setting. Adding behaviors: ' + behaviors.join(', '));
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  return {
    behaviors: behaviors,
    config: config
  };
});

/***/ }),
/* 327 */
/***/ (function(module, exports) {

SNI.Application.addModule('how-to', function (context) {
  'use strict';

  var $element = $(context.getElement()),
      device = context.getService('device-type'),
      check = context.getService('check'),
      debug = context.getService('logger').create('modules.how-to');

  var defaults = {
    materialsList: '.m-RequiredMaterials__m-PromoList',
    materialsCta: '.m-PromoList__a-Cta',
    bannerBody: '.o-Banner__m-Body[style]',
    pageBody: '[data-sni-area=content]'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  //TODO: make this hackery not needed as a part of CCT-351
  function bgHack() {
    if (device.isMobile) {
      return;
    } //hack not needed on mobile
    var $src = $(config.bannerBody),
        $targ = $(config.pageBody);

    if ($src.length && $targ.length) {
      $targ.attr('style', $src.attr('style'));
      $src.removeAttr('style');
    }
  }

  return {

    config: config,

    init: function init() {
      debug.log('inited!');

      bgHack(); /* hack to allow variable heights in h1 tag */

      if (check.exists('SniAds')) {
        context.getGlobal('SniAds').appendSlot('final_bigbox', 'dfp_bigbox');
      }
    },

    onclick: function onclick(event, element, elementType) {
      if (elementType !== '') {
        event.preventDefault();
      }

      var $lead = $element.find('[data-how-to-lead]');

      if (elementType === 'showmore') {
        $lead.find(config.materialsList + ' li:nth-of-type(1n+4)').css('display', 'block');
        $lead.find(config.materialsCta).css('display', 'none');
      }
    }
  };
});

/***/ }),
/* 328 */
/***/ (function(module, exports) {

SNI.Application.addModule('image-embed', function (context) {

  return {
    behaviors: ['social-pinterest']
  };
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(330), __esModule: true };

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(139);
__webpack_require__(144);
module.exports = __webpack_require__(101).f('iterator');


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(332), __esModule: true };

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(333);
__webpack_require__(138);
__webpack_require__(338);
__webpack_require__(339);
module.exports = __webpack_require__(12).Symbol;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(8);
var has = __webpack_require__(32);
var DESCRIPTORS = __webpack_require__(18);
var $export = __webpack_require__(21);
var redefine = __webpack_require__(141);
var META = __webpack_require__(134).KEY;
var $fails = __webpack_require__(54);
var shared = __webpack_require__(98);
var setToStringTag = __webpack_require__(69);
var uid = __webpack_require__(67);
var wks = __webpack_require__(9);
var wksExt = __webpack_require__(101);
var wksDefine = __webpack_require__(102);
var enumKeys = __webpack_require__(334);
var isArray = __webpack_require__(335);
var anObject = __webpack_require__(23);
var isObject = __webpack_require__(24);
var toIObject = __webpack_require__(45);
var toPrimitive = __webpack_require__(93);
var createDesc = __webpack_require__(66);
var _create = __webpack_require__(142);
var gOPNExt = __webpack_require__(336);
var $GOPD = __webpack_require__(337);
var $DP = __webpack_require__(22);
var $keys = __webpack_require__(94);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(151).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(103).f = $propertyIsEnumerable;
  __webpack_require__(150).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(68)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(31)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(94);
var gOPS = __webpack_require__(150);
var pIE = __webpack_require__(103);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(55);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(45);
var gOPN = __webpack_require__(151).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(103);
var createDesc = __webpack_require__(66);
var toIObject = __webpack_require__(45);
var toPrimitive = __webpack_require__(93);
var has = __webpack_require__(32);
var IE8_DOM_DEFINE = __webpack_require__(130);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(18) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(102)('asyncIterator');


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(102)('observable');


/***/ }),
/* 340 */
/***/ (function(module, exports) {

SNI.Application.addModule('instagram-embed', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var debug = context.getService('logger').create('module.instagram-embed');

  var $element = void 0,
      defaults = void 0,
      config = void 0,
      instgrm = void 0,
      module = void 0;

  defaults = {
    url: '',
    hideCaption: false,
    jsURL: '//platform.instagram.com/en_US/embeds.js',
    embedURL: 'https://api.instagram.com/oembed',
    embedName: 'instagram'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setEmbedConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function loadEmbed() {
    var apiPath = config.embedURL,
        url = config.url || '',
        hideCaption = config.hideCaption;

    $.ajax({
      url: apiPath,
      dataType: 'jsonp',
      data: {
        url: url,
        hidecaption: hideCaption,
        omitscript: true
      },
      context: this
    }).done(function (response) {
      $element.html(response.html);
      instgrm.Embeds.process();
    }).fail(function (xhr, response) {
      debug.log('instagram embed GET error: ', response);
    });
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  module = {
    init: function init() {
      setEmbedConfig(defaults, context.getConfig());
      $element = $(context.getElement());
      instgrm = context.getGlobal('instgrm');
      loadEmbed();
    },

    updateObject: updateObject,
    setEmbedConfig: setEmbedConfig
  };

  return module;
});

/***/ }),
/* 341 */
/***/ (function(module, exports) {

SNI.Application.addModule('jukebox', function (context) {
  return {
    behaviors: ['load-more', 'lazy-load']
  };
});

/***/ }),
/* 342 */
/***/ (function(module, exports) {

SNI.Application.addModule('load-more', function (context) {
  // This is a temporary module for load-more until load-more is refactored.
  return {
    behaviors: ['load-more']
  };
});

/***/ }),
/* 343 */
/***/ (function(module, exports) {

SNI.Application.addModule('mobile-nav', function (context) {

  var debug = context.getService('logger').create('module.mobile-nav');
  var loadBehaviors = [];

  // Turn new gigya features on or off depending on config
  if (SNI.Config.useGigyaLogin) {
    loadBehaviors.push('gigya/handle-login', 'gigya/login');
    debug.log('Gigya login activated by OSGI setting. Adding behaviors: ' + loadBehaviors.join(', '));
  }

  return {
    behaviors: loadBehaviors,
    onclick: function onclick(event, element, elementType) {
      if (elementType === 'button-close') {
        event.preventDefault();
        context.broadcast('mobile-nav.toggle', false);
      }
    }
  };
});

/***/ }),
/* 344 */
/***/ (function(module, exports) {

SNI.Application.addModule('multi-content-stream', function (context) {

  return {
    behaviors: ['lazy-load', 'truncate']
  };
});

/***/ }),
/* 345 */
/***/ (function(module, exports) {

/** Newsletter Component
 **  3 required settings to pass to newsletter service:
 **  reminderBrand , reminderSourceId, reminderListId
 ** Newsletter ID needed for newsletter
 */

SNI.Application.addModule('newsletter', function (context) {

  var moduleEl = void 0,
      $element = void 0,
      mdManager = void 0,
      service = void 0,
      debug = void 0,
      defaults = void 0,
      config = void 0;

  return {
    onclick: function onclick(event, element, elementType) {
      if (elementType !== '') {
        event.preventDefault();
      }

      switch (elementType) {
        case 'subscribe-initial':
          this.state1Submit();
          break;
        case 'subscribe-more':
          this.state2Submit();
          break;
        case 'cancel':
          this.state2Cancel();
          break;
        default:
        // do nothing
      }
    },
    init: function init() {
      moduleEl = context.getElement();

      $element = $(moduleEl);

      mdManager = context.getGlobal('mdManager');

      service = context.getService('newsletter-subscribe');

      debug = context.getService('debug');

      defaults = {
        // This one gets set in the CMS
        newsletterId: '',
        newsletterName: '',
        newsletterSource: '',
        newsletterBrand: 'hgtv',
        newsletterCategory: '',
        newsletterShowMore: true,
        newsletterSite: '',
        subscribeBrand: 'hgtv',
        title: '',
        description: '',
        subscribeType: 'reminder',
        subscribeId: '',
        // Various message templates that the widget uses
        msg: {
          state2Thanks: '<strong>Thanks for subscribing to the {{newsletterName}} newsletter.</strong> Check out all our other great newsletters from {{newsletterSite}}.',
          state2ThanksReminder: '<strong>Thank You, </strong> You have successfully registered to receive email reminders to enter the giveaway.',
          state3Thanks: '<strong>Thanks,</strong> we have added your selections to your subscriptions.',
          state3NoThanks: 'Sure, no problem. You\'re now subscribed to the {{newsletterName}} newsletter.'
        },
        // Various error messages that the widget uses
        err: {
          emailEmpty: 'Please enter your email address.',
          emailInvalid: 'Your email address is invalid.',
          noCheckbox: 'Please select at least one newsletter from the list above.',
          serviceError: 'A problem occurred, please try again later or contact customer service.'
        },
        selectors: {
          state1: '.ns-state1',
          state2: '.ns-state2',
          state3: '.ns-state3',
          statePrefix: '.ns-',
          stateNamePrefix: 'state',
          errors: '.ns-errors',
          description: '.ns-description'
        }
      };

      // In the JSP, anything with a type of "text/x-config" will be passed in here
      // config = Object.assign({}, defaults, context.getConfig());
      // need a deep merge if we are overriding one "msg":
      config = $.extend(true, {}, defaults, context.getConfig());

      // Check if subscription is newsletter and if so, change subscribe type
      if (config.newsletterId) {
        config.subscribeType = 'newsletter';
      }

      this.initTitle();
      this.initDescription();
      this.initThanks();
    },
    destroy: function destroy() {
      moduleEl = null;
      $element = null;
      mdManager = null;
      service = null;
      debug = null;
      defaults = null;
      config = null;
    },
    initTitle: function initTitle() {
      var self = this;

      if (config.title) {
        $element.find('h2').html(self.substitute(config.title));
      }
    },
    initDescription: function initDescription() {
      var self = this;

      if (config.description) {
        $element.find(config.selectors.state1 + ' ' + config.selectors.description).html(self.substitute(config.description));
      }
    },
    initThanks: function initThanks() {
      var msg = void 0;

      // Update the thanks message text so it includes the newsletter name
      if (config.subscribeType === 'newsletter') {
        msg = this.substitute(config.msg.state2Thanks);
      } else {
        msg = this.substitute(config.msg.state2ThanksReminder);
      }

      $element.find(config.selectors.state2 + ' ' + config.selectors.description).html(msg);

      // Also update the thanks message on the state3 page in case we jump directly there
      msg = this.substitute(config.msg.state3Thanks);

      $element.find(config.selectors.state3 + ' ' + config.selectors.description).html(msg);
    },
    state1Submit: function state1Submit() {
      var _arguments = arguments;

      var self = this;

      if (!self.state1Validate()) {
        return;
      }

      self.showLoading();

      //set API url and parameters depending on subscription type
      if (config.subscribeType === 'newsletter') {
        config.subscribeBrand = config.newsletterBrand;
        config.subscribeId = config.newsletterId;
        config.subscribeSource = config.newsletterSource;
      } else {
        config.subscribeBrand = mdManager.getParameter('site');
        config.subscribeSource = mdManager.getPageTitle().replace(/\ /g, '_');
      }

      service.subscribe({
        email: self.getEmail(),
        nl: config.subscribeId,
        listId: config.listId,
        source: config.subscribeSource,
        nlbrand: config.subscribeBrand,
        subscribeType: config.subscribeType
      }).done(function () {
        // Service call successfully subscribed
        self.state2Show();
      }).fail(function () {
        // Service call did not subscribe
        self.showLoading(false);
        self.setError(config.selectors.stateNamePrefix + '1', config.err.serviceError);
        debug.error(_arguments);
      });
    },
    state1Validate: function state1Validate() {
      var email = this.getEmail();
      this.setError(config.selectors.statePrefix + '1', '');

      if (email.length === 0) {
        this.setError(config.selectors.statePrefix + '1', config.err.emailEmpty);
        return false;
      }

      if (!this.isValidEmail(email)) {
        this.setError(config.selectors.statePrefix + '1', config.err.emailInvalid);
        return false;
      }

      return true;
    },
    state2Show: function state2Show() {
      if (!config.newsletterShowMore && config.subscribeType === 'newsletter') {
        // Skip state2 and jump immediately to state3 to show a thank you message.
        this.showState(config.selectors.statePrefix + '3');
      } else {
        this.showState(config.selectors.statePrefix + '2');
      }
    },
    state2Submit: function state2Submit() {
      var _arguments2 = arguments;

      //At this point, state2Submit is exclusively for the newsletter
      var self = this,
          nl = [];

      // Make sure the form is ready to submit
      if (!self.state2Validate()) {
        return;
      }

      self.showLoading();

      // Get array of newsletter ids that were checked
      $element.find(config.selectors.state2 + ' :checkbox').filter(':checked').each(function (index, element) {
        nl.push(element.value);
      });

      service.subscribe({
        email: self.getEmail(),
        nl: nl,
        source: config.newsletterSource,
        listId: config.listId,
        nlbrand: config.newsletterBrand,
        subscribeType: config.subscribeType
      }).done(function () {
        // Service call successfully subscribed
        self.showState(config.selectors.statePrefix + '3');
      }).fail(function () {
        // Service call did not subscribe
        self.showLoading(false);
        self.setError(config.selectors.statePrefix + '2', config.err.serviceError);
        debug.error(_arguments2);
      });
    },
    state2Cancel: function state2Cancel() {
      $element.find(config.selectors.state3 + ' ' + config.selectors.description).html(this.substitute(config.msg.state3NoThanks));
      this.showState(config.selectors.state3);
    },
    state2Validate: function state2Validate() {
      // Clear any existing errors
      this.setError(config.selectors.statePrefix + '2', '');

      // Verify that at least one checkbox was checked
      if (!$element.find(config.selectors.state2 + ' :checkbox').is(':checked')) {
        this.setError(config.selectors.statePrefix + '2', config.err.noCheckbox);
        return false;
      }

      return true;
    },
    setError: function setError(state, msg) {
      var errorClass = state + ' ' + config.selectors.errors;
      $element.find(errorClass).html(msg || '').toggle(Boolean(msg));
    },
    showState: function showState(state) {
      var showClass = '' + state;
      // *The initial show/hide of these divs is set in the newsletter CSS
      this.showLoading(false);

      $element.find(config.selectors.state1).hide();
      $element.find(config.selectors.state2).hide();
      $element.find(showClass).show();
    },
    showLoading: function showLoading(show) {
      $element.find('[data-ui-loader]').toggle(show !== false);
    },
    getEmail: function getEmail() {
      return $.trim($element.find(config.selectors.state1 + ' input[name=email]').val() || '');
    },
    isValidEmail: function isValidEmail(email) {
      var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(email);
    },
    substitute: function substitute(s) {
      return s.replace(/\{\{([^{}]*)\}\}/g, function (a, b) {
        var r = config[b];
        return typeof r === 'string' || typeof r === 'number' ? r : a;
      });
    }
  };
});

/***/ }),
/* 346 */
/***/ (function(module, exports) {

SNI.Application.addModule('nutrition-info', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.nutrition-info');

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  var defaults = {};

  var settings = Object.assign({}, defaults, context.getConfig());

  var init = function init() {
    debug.log('Module started', settings);
  };

  return {
    behaviors: ['popover'],
    init: init
  }; //end return
});

/***/ }),
/* 347 */
/***/ (function(module, exports) {

SNI.Application.addModule('on-tv-full-width', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.on-tv'),
      template = context.getService('template'),
      utility = context.getService('utility'),
      schedule = context.getService('schedule'),
      url = context.getService('url'),
      defaults = {
    parentClass: 'm-ScheduleCard',
    isWhatsHotOn: false,
    onTonightTimeGMT: '0:0'
  };

  var element = void 0,
      settings = void 0;

  function watchButton(watchUrl) {
    return template.button({
      url: watchUrl,
      parentClass: settings.parentClass,
      text: 'Watch Live TV'
    });
  }

  function showWhatsOnNow(showNode, watchUrl) {
    var $whatOnNow = $(showNode),
        onNowLabel = template.subHeadline({
      parentClass: settings.parentClass,
      text: 'On Now'
    });

    if (watchUrl) {
      $whatOnNow.append(watchButton(watchUrl));
    }

    $whatOnNow.prepend(onNowLabel).show();
  }

  function showWhatsOnNext(showNode) {
    var $whatsOnNext = $(showNode),
        nextLabel = template.subHeadline({
      parentClass: settings.parentClass,
      text: 'Up Next'
    });

    $whatsOnNext.prepend(nextLabel).show();
  }

  function showWhatsOnTv(dateTime, $element) {
    var whatOnNow = void 0,
        whatsOnNext = void 0;

    var watchUrl = url.watchSite(),
        isWhatsHotOn = settings.isWhatsHotOn;

    // This could be optimized, currently search is Big O n.
    $element.find('[data-time]').each(function (indexInArray, showNode) {
      var airTime = new Date($(showNode).attr('data-time')),
          airTimeHourMin = airTime.getUTCHours() + ':' + airTime.getUTCMinutes(),
          comparison = schedule.compareDateTimeNowAndAirtime(dateTime, airTime, utility.getZone(dateTime));

      if (comparison === 0) {
        whatOnNow = showNode;
        showWhatsOnNow(showNode, watchUrl);
      } else if (comparison < 0 && !whatsOnNext) {
        whatsOnNext = showNode;
        showWhatsOnNext(showNode, watchUrl);

        if (watchUrl && !whatOnNow) {
          $(whatsOnNext).append(watchButton(watchUrl));
        }
      }

      //if element's airTime equals onTonightTimeGMT then it is whatsOnTonight
      //if OnNow is not present then show OnTonight
      if (airTimeHourMin === settings.onTonightTimeGMT && (!whatOnNow || !isWhatsHotOn)) {
        $(showNode).show();
      }
    });

    $element.find('[data-time]:not(:visible)').remove();
  }

  function init() {
    var now = new Date();

    element = context.getElement();

    debug.log('On-TV Module: initialized');

    settings = Object.assign({}, defaults, context.getConfig());

    showWhatsOnTv(now, $(element));
  }

  return {
    init: init
  };
});

/***/ }),
/* 348 */
/***/ (function(module, exports) {

SNI.Application.addModule('on-tv', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.on-tv');
  var ll = context.getService('lazy-load');
  var utility = context.getService('utility');
  var schedule = context.getService('schedule');
  var url = context.getService('url');
  var element = context.getElement();
  var $element = $(element);
  var settings = void 0;

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  function init() {
    debug.log('On-TV Module: initialized');

    settings = context.getConfig();

    /** Called on load */
    var now = new Date();
    showWhatsOnTv(now, $element);

    //fire the lazy load scroll event so images that weren't visible (before showWhatsOnTv fired) will load if in the viewport
    ll.forceScroll();
  }

  // TODO: Break this down into smaller parts for easier comprehension/testability
  function showWhatsOnTv(dateTime, element) {
    var zone = utility.getZone(dateTime);

    var whatOnNow = void 0,
        whatsOnNext = void 0,
        $whatOnNow = void 0,
        $whatsOnNext = void 0,
        whatsOnTonight = void 0,
        $whatsOnTonight = void 0,
        watchUrl = url.watchSite(),
        version = element.find('[data-version]').data('version'),
        mediaBlockClass = 'm-MediaBlock',
        onNowClass = 'is-OnNow',
        buttonClass = mediaBlockClass + '__a-Button',
        mediaLabelClass = mediaBlockClass + '__a-Label',
        mediaLabel2Class = mediaBlockClass + '__a-Label--OnTV',
        mediaElement = '<div class="' + mediaBlockClass + '__m-MediaWrap"></div>',
        mediaSelector = '.' + mediaBlockClass + '__m-MediaWrap',
        textSelector = '.' + mediaBlockClass + '__m-TextWrap',
        onNowLabel = '<span class="' + mediaLabelClass + '">On Now</span>',
        nextLabel = '<span class="' + mediaLabelClass + '">Up Next</span>',
        nextLabelRR = nextLabel,
        watchButton = function watchButton(url) {
      return '<a href="' + url + '" class="' + buttonClass + '">Watch Live TV</a>';
    };

    //get values from the ettings onfig
    var onTonightTimeGMT = settings.onTonightTimeGMT;
    var isWhatsHotOn = settings.isWhatsHotOn;

    // This could be optimized, currently search is Big O n.
    element.find('[data-time]').each(function (indexInArray, value) {
      var airTime = new Date($(value).attr('data-time')),
          comparison = schedule.compareDateTimeNowAndAirtime(dateTime, airTime, zone);
      if (comparison === 0) {
        whatOnNow = value;
      } else if (comparison < 0 && !whatsOnNext) {
        whatsOnNext = value;
      }

      //if element's airTime equals onTonightTimeGMT then it is whatsOnTonight
      var airTimeHourMin = airTime.getUTCHours() + ':' + airTime.getUTCMinutes();
      if (airTimeHourMin === onTonightTimeGMT) {
        whatsOnTonight = value;
      }
    });

    //testing...
    //whatOnNow = element.find('[data-time]:first')[0];

    if (whatOnNow) {
      $whatOnNow = $(whatOnNow);

      $whatOnNow.find('.' + mediaBlockClass).addClass(onNowClass);
      //if mediaWrap doesn't exist from template, add mediaWrap for label
      if ($whatOnNow.find(mediaSelector).length <= 0) {
        $whatOnNow.find('.' + mediaBlockClass).prepend(mediaElement);
      }
      var $media = $whatOnNow.find(mediaSelector);
      var $text = $whatOnNow.find(textSelector);

      //mobile
      if (version === 'mobile') {
        $text.prepend(onNowLabel);
        $text.append(watchButton(watchUrl));
      } else {
        $media.append(onNowLabel);
        if (watchUrl.length) {
          $text.append(watchButton(watchUrl));
        }
      }
      $whatOnNow.show();
    } else if (watchUrl.length) {
      $(whatsOnNext).find(textSelector).append(watchButton(watchUrl));
    }

    if (whatsOnNext && $(whatsOnNext).length) {
      $whatsOnNext = $(whatsOnNext);

      //if mediaWrap doesn't exist from template, add mediaWrap for label
      if ($whatsOnNext.find(mediaSelector).length <= 0) {
        $whatsOnNext.find('.' + mediaBlockClass).prepend(mediaElement);
      }
      var _$media = $whatsOnNext.find(mediaSelector);
      var _$text = $whatsOnNext.find(textSelector);

      if (version === 'mobile') {
        _$text.prepend(nextLabel);
      } else if (version === 'right-rail') {
        _$media.prepend(nextLabelRR);
      } else {
        _$media.append(nextLabel);
      }
      $whatsOnNext.show();
    }

    //if WhatsHot doesn't have image, wrap label in mediaWrap
    if (isWhatsHotOn) {
      var $whatsHotElement = element.find('.l-List > div:last-child');
      var $whatsHotLabel = element.find('.l-List > div:last-child > span');
      if ($whatsHotElement.find(mediaSelector).length <= 0) {
        $whatsHotLabel.wrap(mediaElement);
      }
    }

    //if either OnNow or WhatsHot is not present then show OnTonight
    if (!whatOnNow || !isWhatsHotOn) {
      $whatsOnTonight = $(whatsOnTonight);
      //if mediaWrap doesn't exist from template, wrap label in mediaWrap
      if ($whatsOnTonight.find(mediaSelector).length <= 0) {
        var $whatOnTonightLabel = $whatsOnTonight.find('.' + mediaBlockClass + ' > span');
        $whatOnTonightLabel.wrap(mediaElement);
      }
      $whatsOnTonight.show();
    }

    element.find('[data-time]:not(:visible)').remove();

    //make some things easier to style
    if (version === 'right-rail') {
      element.find('.' + mediaBlockClass).find('.' + mediaLabelClass + ':not(:first)').remove();
      element.find('.' + mediaLabelClass).each(function () {
        $(this).filter(function () {
          return $(this).closest('.' + onNowClass).length === 0;
        }).prependTo($(this).closest(mediaSelector)).removeClass(mediaLabelClass).addClass(mediaLabel2Class);
      });
    }
  }

  return {
    init: init,
    showWhatsOnTv: showWhatsOnTv,
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 349 */
/***/ (function(module, exports) {

SNI.Application.addModule('page', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var deviceType = context.getService('device-type');
  var cookie = context.getService('cookie');
  var utils = context.getService('utility');
  var loadBehaviors = ['deferred-loader', 'router', 'media-stream', 'track-shopping'];
  var debug = context.getService('logger').create('module.page');
  var ads = context.getService('ads');
  var internationalDialog = context.getService('internationalDialog');

  // Turn new gigya features on or off depending on config
  if (SNI.Config.useGigyaLogin) {
    loadBehaviors.push('gigya/init');
    debug.log('Gigya login activated by OSGI setting. Adding behaviors: ' + loadBehaviors.join(', '));
  }

  if (window.location.search.match(/[\&|\?]themeSelect/gi) || context.getGlobal('cqWCMshowThemeSelector')) {
    loadBehaviors.push('theme-selector');
  }

  //when author tools are specifically turned off, keep query string params while clicking around the website
  function adjustUrl() {
    var eles = [];
    var sels = ['a[href$="/en"]', 'a[href^="/"][href$=".html"]', 'a[href^="/content/"]:not([href^="/content/dam"],[href$=".html"])', '[data-module="select-button"] option[value^="/"][value$=".html"]'];
    $(sels.join(', ')).each(function () {
      var $ele = $(this);
      var nodeName = $ele[0].nodeName.toLowerCase();
      var attrib = nodeName === 'option' ? 'value' : 'href';
      var url = $ele.attr(attrib);
      if (attrib && url) {
        if (url.match(/[^.html]$/g) && (url.match(/\/en$/g) || url.match(/^\/content\//g))) {
          url += '.html';
        }
        if (deviceType.isMobile && !url.match('\.mobile\.html$')) {
          url = url.replace(/\.html$/, '.mobile.html');
        }
        $ele.attr(attrib, url + window.location.search);
        eles.push($ele[0]);
      }
    });
    if (eles.length) {
      debug.log('adjustUrl() adjusted ' + eles.length + ' urls', eles);
    }
  }

  function setLayoutCookie(param) {
    //create easy way to toggle layout cookie
    var current = cookie.get('layout');
    if (param === 'desktop') {
      if (current) {
        cookie.remove('layout');
        debug.log('toggling layout cookie to desktop (by removing layout cookie)');
        window.location.reload();
      }
    } else if (current !== param) {
      cookie.set('layout', param);
      debug.log('toggling layout cookie to ' + param);
      window.location.reload();
    }
  }

  var layout = utils.getUrlParam(window.location.href, 'layout');
  if (layout.length) {
    setLayoutCookie(layout);
  }

  if (utils.getUrlParam(window.location.href, 'wcmmode') === 'disabled') {
    adjustUrl();
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {
    behaviors: loadBehaviors,

    init: function init() {
      ads.collapseSlots();
      utils.addJavaScriptCssClass();
      // Check country code and show modal to redirect to native site if not from US
      internationalDialog.modal();
    }
  };
});

/***/ }),
/* 350 */
/***/ (function(module, exports) {

SNI.Application.addModule('photo-category', function (context) {

  var device = context.getService('device-type'),
      debug = context.getService('logger').create('module.photo-category');

  var module = void 0,
      defaults = void 0,
      config = void 0;

  defaults = {
    teaser: '.editorial-promo',
    desktopPromo: 'one-column',
    mobilePromo: 'two-column',
    cutoff: 0,
    filterCtrl: '.filter-control',
    filterUrl: [],
    basePath: null,
    pagination: '',
    shade: '.filter-shade',
    launcher: '.launchme',
    launchImg: '.rsImg'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setCategoryConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function cleanArray(dirtyArray) {
    var newArray = [];
    for (var i = 0; i < dirtyArray.length; i++) {
      if (dirtyArray[i]) {
        newArray.push('/' + dirtyArray[i]);
      }
    }
    return newArray;
  }

  function updatePromo() {
    if (device.isMobile) {
      setTimeout(function waitForTeaser() {
        if ($(config.teaser).length) {
          changeLayout();
        } else if (config.cutoff > 20) {
          debug.log('updatePromo: Teaser not loaded, not altering layout');
        } else {
          config.cutoff++;
          setTimeout(waitForTeaser, 50);
        }
      }, 50);
    }
  }

  function directLauncher() {
    $(config.launcher).click(function (e) {
      e.preventDefault();
      window.location = $(config.launchImg).attr('href');
    });
  }

  function changeLayout() {
    $(config.teaser).removeClass(config.desktopPromo).addClass(config.mobilePromo);
  }

  function setInitialFilters() {
    var selectedFacets = device.isMobile ? $('.facet-select').find(':selected') : $('.facetOption.selected');
    if (!$.isEmptyObject(selectedFacets)) {
      selectedFacets.each(function () {
        config.filterUrl[$(this).data('position')] = $(this).data('tagpath');
      });
    }
  }

  function setFilterListeners() {
    if (device.isMobile) {
      $(config.filterCtrl).click(function () {
        $(config.shade).slideToggle();
      });
      $('.facet-select').each(function () {
        $(this).change(function () {
          var pagePatt = /\/p\/[0-9]+$/;
          var targetPath = $(this).find(':selected').data('targetpath');
          if (pagePatt.test(targetPath)) {
            config.pagination = pagePatt.exec(targetPath);
            targetPath = targetPath.slice(0, targetPath.search(pagePatt));
          }
          config.basePath = targetPath;
          config.filterUrl[$(this).find(':selected').data('position')] = $(this).find(':selected').data('tagpath');
        });
      });
      $(document).on('click touchstart', '.load-photos', function (e) {
        e.preventDefault();
        debug.log('setFilterListeners: basePath: ', config.basePath);
        if (typeof config.basePath !== 'undefined' && config.basePath !== null) {
          config.filterUrl = cleanArray(config.filterUrl);
          window.location = config.basePath + config.filterUrl.join('') + config.pagination;
        }
      });
    } else {
      $('.facetOption').each(function () {
        $(this).click(function (e) {
          e.preventDefault();
          var pagePatt = /\/p\/[0-9]+$/;
          var targetPath = $(this).data('targetpath');
          if (pagePatt.test(targetPath)) {
            config.pagination = pagePatt.exec(targetPath);
            targetPath = targetPath.slice(0, targetPath.search(pagePatt));
          }
          config.basePath = targetPath;
          config.filterUrl[$(this).data('position')] = $(this).data('tagpath');
          if (!device.isMobile) {
            $(this).parent('li').parent('#pv-pl-nav-select').parent('.dropdown-menu').siblings('.dropdown-toggle').html($(this).text() + ' <i class="icon icon-angle-down"></i>');
          }
        });
      });

      $('.btn-go').click(function (e) {
        e.preventDefault();
        if (typeof config.basePath !== 'undefined' && config.basePath !== null) {
          config.filterUrl = cleanArray(config.filterUrl);
          window.location = config.basePath + config.filterUrl.join('') + config.pagination;
        }
      });
    }
  }

  module = {
    init: function init() {
      setCategoryConfig(defaults, context.getConfig());
      updatePromo();
      directLauncher();
      setInitialFilters();
      setFilterListeners();
    },


    updateObject: updateObject,
    setCategoryConfig: setCategoryConfig
  };

  return module;
});

/***/ }),
/* 351 */
/***/ (function(module, exports) {

SNI.Application.addModule('photo-gallery-launcher', function (context) {

  var modal = context.getService('modal'),
      debug = context.getService('logger').create('module.photo-gallery-launcher'),
      check = context.getService('check').new(debug),
      deviceType = context.getService('device-type'),
      module = void 0,
      launcherElement = void 0,
      $launcherElement = void 0,
      launcherId = void 0,
      galleryModal = void 0,
      defaults = void 0,
      config = void 0;

  defaults = {
    assetPageSelector: '.photo-gallery-collection',
    launchIndex: false,
    galleryOffset: 0,
    queueSelector: 'slideshow-queue',
    currentScrollPosition: 0,
    launchIndexUpdated: false,
    updatedIndex: 0,
    startSlide: 0
  };

  function setLaunchIndex(newIndex) {
    config.updatedIndex = parseInt(newIndex);
  }

  function launchGalleryModal(element) {
    var $clickElement = $(element),
        $slideshowQueue = void 0,
        $gallery = void 0,
        index = void 0;

    if (config.launchIndexUpdated) {
      index = config.updatedIndex + config.galleryOffset;
    } else {
      index = ($clickElement.closest(config.launchIndex).index() || 0) + config.galleryOffset;
    }

    $slideshowQueue = config.galleryQueue || $launcherElement.find('.slideshow-queue');

    if ($slideshowQueue.length > 0) {
      if ($clickElement.data('queue-selector')) {
        $slideshowQueue = $clickElement.find($clickElement.data('queue-selector'));
      }

      $gallery = $slideshowQueue.clone();
      $gallery.removeClass(config.queueSelector);

      if (index !== -1) {
        $gallery.data('startSlide', index);
        config.startSlide = index;
      }

      setGalleryModal('photo-gallery', $gallery);
    }
  }

  function setGalleryModal(id, gal) {
    var containerSelector = '#' + id;
    if (typeof galleryModal === 'undefined') {
      galleryModal = false;
    }

    $('body').addClass('full-overlay-modal-open');
    if (deviceType.isMobile) {
      $('body').height($(window).height());
      $('html').css({ overflow: 'hidden' });
    }

    galleryModal = modal.open(id, gal);
    context.broadcast('galleryModal.opened', {
      container: containerSelector,
      origin: launcherId,
      startingSlide: config.startSlide
    });
  }

  function insertPosterImage() {
    var photoHash = window.location.hash,
        $queueSlide = $(config.assetPageSelector).find('.slideshow-queue .slide'),
        cleanString = photoHash.toLowerCase().replace('#photo-', ''),
        parsedNumber = 0,
        slideImage = void 0;

    if (cleanString && parseInt(cleanString, 10) > 0) {
      parsedNumber = parseInt(cleanString, 10) - 1;
    }

    slideImage = $queueSlide.eq(parsedNumber).find('.rsImg').attr('data-is-18');

    if (slideImage === undefined) {
      slideImage = $queueSlide.eq(0).find('.rsImg').attr('data-is-18');
    }

    $(config.assetPageSelector).find('.gallery-poster-image').remove().end().prepend($('<img />', { 'src': slideImage, 'class': 'gallery-poster-image photo-gallery-launch' }));
  }

  function setupPromoPinterest(event) {
    event.stopPropagation();

    if (!check.exists('PinUtils')) return;

    context.getGlobal('PinUtils').pinOne({
      media: config.imageURL,
      url: config.pageURL,
      description: config.description
    });
  }

  function recordScrollPosition() {
    config.currentScrollPosition = $(document).scrollTop();
  }

  function restoreScrollPosition(originalLauncher) {
    if (originalLauncher === launcherId) {
      window.scrollTo(0, config.currentScrollPosition);
    }
  }

  module = {

    behaviors: ['lazy-load', 'social-pinterest'],

    messages: ['galleryModal.closed', 'carousel.indexUpdated'],

    init: function init() {
      launcherElement = context.getElement();
      $launcherElement = $(launcherElement);
      launcherId = $launcherElement.attr('id');
      config = Object.assign({}, defaults, context.getConfig());
      if ($(config.assetPageSelector).length) {
        insertPosterImage();
      }
      context.broadcast('gallery.ImageUpdate', {});
    },

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'galleryModal.closed':
          restoreScrollPosition(data.origin);
          break;
        case 'carousel.indexUpdated':
          config.launchIndexUpdated = true;
          setLaunchIndex(data.updatedIndex);
          break;
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'launch-gallery-modal':
          event.preventDefault();
          recordScrollPosition();
          launchGalleryModal(element);
          break;
        case 'promo-social-pinit':
          setupPromoPinterest(event);
          break;
      }
    }

  };

  return module;
});

/***/ }),
/* 352 */
/***/ (function(module, exports) {

SNI.Application.addModule('photo-gallery', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var module = void 0,
      galleryElement = void 0,
      $galleryElement = void 0,
      galleryContainer = void 0,
      galleryModal = void 0,
      $slideToolbar = void 0,
      slider = void 0,
      config = void 0,
      receivedId = void 0,
      deviceType = void 0,
      SniAds = void 0,
      mdManager = void 0,
      debug = context.getService('logger').create('module.photo-gallery'),
      check = context.getService('check').new(debug),
      template = void 0,
      metadata = void 0,
      analytics = void 0,
      router = void 0,
      defaults = void 0;

  if (!check.jqueryPlugin('royalSlider')) return {};

  defaults = {
    galleryType: 'dynamic',
    galleryViewType: 'overlay',
    galleryPageTypes: {
      singleImage: false
    },
    galleryCount: 0,
    numGalleriesViewed: 0,
    galleryParent: '',
    galleryURL: '',
    galleryIndex: '',
    totalPlace: 0,
    nextGalleryIndex: false,
    loadedState: '',
    lastGallery: false,
    viewedAllGalleries: false,
    galleryContainerSelector: '.slideshow-wrapper',
    ajaxUrl: '',
    ajaxStayAhead: 3,
    ajaxFetchNumSlides: 10,
    ajaxPaging: false,
    ajaxImagesPerPage: 18,
    readyToFetchMore: true,
    adLibLoaded: false,
    coldLoad: true,
    galleryAdSetup: {
      container: '#photo-gallery',
      dismiss_elts: '.rsArrowIcn',
      disable_elts: '',
      blockDelay: 10
    },
    hash: '',
    overlayBigboxName: '',
    overlayPhotoIntName: '',
    overlayPhotoIntMobileName: '',
    interstitialShownClass: '.interstitial-show',
    galleryLoadingClass: 'loading',
    galleryStartingPosition: 0,
    photoTraySelector: '.m-SlideContainer__m-PhotoTray',
    trayActionSelector: '.m-SlideContainer__a-Title',
    hiddenTrayClass: 'tray-hidden',
    visibleTrayClass: 'tray-showing',
    currentTrayVisiblity: 'tray-hidden',
    hoverRightClass: 'hoverRight',
    hoverLeftClass: 'hoverLeft',
    slideClassSelector: '.slide',
    rightDataType: 'increment-slide',
    leftDataType: 'decrement-slide',
    showTraySpan: '<span></span>',
    backNavPercent: 20,
    afterSlideName: 'gallery.afterSlide',
    beforeAnimName: 'gallery.beforeAnimation',
    beforeSizeName: 'gallery.beforeSizeSet',
    lastSlideName: 'gallery.lastSlide',
    afterContentSetName: 'gallery.afterContentSet',
    previousArrowSelector: '.rsArrowLeft',
    nextArrowSelector: '.rsArrowRight',
    hotspotElement: 'img.rsMainSlideImage',
    hotspotUrlName: 'hotspotUrl',
    originalGallery: 0,
    consecutiveGallery: 1,
    overLoop: false,
    voteModalId: 'voteModalOnboarding',
    nextGallerySel: '[data-type="open-next-gallery"]',
    nextGalleryLinkSel: '[data-next-gallery-link]',
    voteReadyBtnSel: '[data-vote-ready-btn]',
    voteElement: '[data-vote-gallery-thumb]',
    voteWrapper: '[data-vote-module]',
    voteEnabled: false,
    voteAllowed: false,
    readyForNextVoteCat: true,
    rsConfig: {
      imageAlignCenter: false,
      globalCaption: false,
      fadeinLoadedSlide: false,
      arrowsNav: true,
      arrowsNavAutoHide: false,
      arrowsNavHideOnTouch: false,
      controlNavigation: 'none',
      controlsInside: true,
      imageScalePadding: 0,
      transitionSpeed: 0,
      transitionType: 'fade',
      minSlideOffset: 50,
      loop: true,
      addActiveClass: true,
      deeplinking: {
        change: false,
        enabled: true,
        prefix: 'photo-'
      },
      fullscreen: {
        enabled: true,
        buttonFS: false,
        nativeFS: true
      },
      allowCSS3: true,
      keyboardNavEnabled: false,
      numImagesToPreload: 2,
      navigateByClick: false,
      imageScaleMode: 'fit-if-smaller',
      sliderDrag: false,
      preloaderHTML: ''
    }
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setGalleryConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function setGalleryPageTypes(currentContext, currentPageTypes) {
    var pages = void 0,
        updatedPages = void 0;

    pages = currentPageTypes;
    updatedPages = updateObject(pages, {
      singleImage: $('body').hasClass('singleImagePage')
    });

    currentContext.broadcast('gallerydataupdated', {
      galleryPageTypes: updatedPages
    });
  }

  function setPreloaderHTML(markup) {
    config.rsConfig.preloaderHTML = markup;
  }

  function getServices(currentContext) {
    deviceType = currentContext.getService('device-type');
    template = currentContext.getService('template');
    metadata = currentContext.getService('metadata');
    analytics = currentContext.getService('analytics');
    router = currentContext.getService('router');
    galleryModal = currentContext.getService('modal');
    debug.log('getServices: router: ', router);
  }

  function checkAdLibrary(currentContext, checkService) {
    currentContext.broadcast('gallerydataupdated', {
      adLibLoaded: checkService.exists(['SniAds.Gallery', 'SniAds.Event'])
    });
  }

  function setAdConfig(currentContext, adLibExists, galleryAdSetup, coldLoad) {
    if (adLibExists) {
      SniAds.Gallery.init(galleryAdSetup);
      if (!coldLoad) {
        SniAds.Gallery.reset();
      }
      currentContext.broadcast('gallerydataupdated', {
        coldLoad: false
      });
    }
  }

  function checkStartSlide(currentContext, element) {
    var freshStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var startPosition = void 0;
    if (typeof element.data('startSlide') !== 'undefined' || freshStart > 0) {
      startPosition = typeof element.data('startSlide') !== 'undefined' ? element.data('startSlide') : freshStart;
      currentContext.broadcast('gallerydataupdated', {
        galleryStartingPosition: startPosition
      });
    }
  }

  function updateRoyalSliderConfig(sliderSettings, data) {
    var updatedRSConfig = void 0,
        newSettings = void 0;

    newSettings = data;
    updatedRSConfig = updateObject(sliderSettings, newSettings);

    return updatedRSConfig;
  }

  function setSliderConfig(currentContext, sliderSettings, isMobile, isTablet, pos) {
    var settings = void 0;

    settings = {
      startSlideId: pos,
      autoHeight: isMobile
    };

    if (isMobile || isTablet) {
      settings = updateObject(settings, {
        transitionSpeed: 300,
        sliderTouch: true,
        transitionType: 'move'
      });
    }

    if (config.galleryType === 'curated') {
      if (config.overLoop) {
        settings = updateObject(settings, {
          loop: true
        });
      } else {
        settings = updateObject(settings, {
          loop: false
        });
      }
    }

    // need to add GAC preloader check

    currentContext.broadcast('gallerydataupdated', {
      rsConfig: updateRoyalSliderConfig(sliderSettings, settings)
    });
  }

  function cacheElements(elementContext, containerSelector) {
    galleryElement = elementContext.getElement();
    $galleryElement = $(galleryElement);
    galleryContainer = $galleryElement.find(containerSelector);

    if (typeof galleryModal === 'undefined') {
      galleryModal = false;
    }

    if (typeof slider === 'undefined') {
      slider = false;
    }

    if (typeof $slideToolbar === 'undefined') {
      $slideToolbar = false;
    }
  }

  function prepareGallery(container, loading) {
    container.removeClass(loading);
  }

  function createCustomSliderEvents(currentContext, settings, proto, mods) {
    $.extend(proto, {
      _addAfterSlideEvent: function _addAfterSlideEvent() {

        var self = this,
            sliderEvents = {
          rsAfterSlideChange: settings.afterSlideName,
          rsBeforeAnimStart: settings.beforeAnimName,
          rsBeforeSizeSet: settings.beforeSizeName,
          rsTryingToAdvancePastLastSlide: settings.lastSlideName
        },
            key = void 0;

        var _loop = function _loop() {
          var name = key,
              val = sliderEvents[name];

          self.ev.on(name, function (event) {
            currentContext.broadcast(val, {
              event: event
            });
          });
        };

        for (key in sliderEvents) {
          _loop();
        }

        self.ev.on('rsAfterContentSet', function (e, slideObject) {
          if (!self.sliderReady) {
            self.ev.trigger('rsSliderReady');
            currentContext.broadcast(settings.afterContentSetName, {
              event: e,
              slideObject: slideObject
            });
            self.sliderReady = true;
          }
        });
      }
    });
    mods.addAfterSlideEvent = proto._addAfterSlideEvent;
  }

  function createCustomPrevNextHandling(currentSlider) {
    currentSlider.lastSlideId = -1;

    $(document).bind('keydown.photoGalleryModalKeyFilter', function (e) {
      if (!$('#voteModalOnboarding').is(':visible')) {
        switch (e.which) {
          case 37:
            currentSlider.prev();
            e.preventDefault();
            break;
          case 39:
            currentSlider.next();
            e.preventDefault();
            break;
        }
      }
    });
  }

  function goNextClick(container, threshold, clickX) {
    var sliderWidth = container.width(),
        clickPercentage = clickX / sliderWidth * 100;

    if (clickPercentage > threshold) {
      return true;
    } else {
      return false;
    }
  }

  function updateConsecutiveGallery(currentContext, metadataService, data) {
    metadataService.setGalleryData(data);
    currentContext.broadcast('gallerydataupdated', data);
  }

  function incrementOriginalGallery(currentContext, metadataService, settings) {
    settings.originalGallery++;
    updateConsecutiveGallery(currentContext, metadataService, {
      originalGallery: settings.originalGallery,
      consecutiveGallery: settings.consecutiveGallery
    });
  }

  function startSlider(currentContext, container, settings) {
    slider = container.royalSlider(settings).data('royalSlider');
    currentContext.broadcast('gallery.sliderInit', {
      slider: slider
    });
  }

  function removeGalleryModal(element, currentContext, galleryID) {
    debug.log('removeGalleryModal: element: ', element);
    $(element).removeClass('full-overlay-modal-open');

    if (deviceType.isMobile) {
      $('body, html').removeAttr('style');
    }

    currentContext.broadcast('galleryModal.closed', {
      origin: galleryID
    });
  }

  function createSlideToolbar(isMobile, container) {
    if (isMobile) {
      return $('<div>').addClass('slide-toolbar').prependTo(container);
    } else {
      return false;
    }
  }

  function setTrayVisibility(currentContext, element, hidden, visible, isMobile) {
    if (!isMobile) {
      var tray = $(element),
          hide = hidden,
          show = visible,
          newState = void 0;

      tray.toggleClass(hide + ' ' + show);

      newState = tray.hasClass(show) ? show : hide;

      currentContext.broadcast('gallerydataupdated', {
        currentTrayVisiblity: newState
      });
    }
  }

  function maintainTrayVisibility(element, hidden, visible, state, isMobile) {
    if (!isMobile) {
      $(element).toggleClass(hidden + ' ' + visible, false).addClass(state);
    }
  }

  function addSlideNumber(currentSlider) {
    var slideContent = currentSlider.currSlide.content;
    slideContent.find('.rsCurr').text(currentSlider.currSlideId + 1);
    slideContent.find('.rsLength').text(currentSlider.numSlides);
  }

  function createSlideNumbering(type, templateService, currentSlider, tray) {
    if (type === 'curated') {
      $(templateService.slideCount()).appendTo(currentSlider.currSlide.content.find(tray));
      addSlideNumber(currentSlider);
    }
  }

  function getSlideTitle($slide) {
    var $ele = $slide.find('h1');
    return $ele.clone().children().remove().end().text() || $ele.text();
  }

  function processSlideMetadata($slide, metadataService, analyticsService) {
    var mdmData = $slide.data('mdm') || false,
        behavioralInteraction = void 0,
        uniqueIDPrime = void 0,
        earl = void 0;

    if (mdManager) {
      mdManager.setParameter('CurrentRoom', getSlideTitle($slide));
    }

    uniqueIDPrime = metadataService.updateConsecutiveViewCount(mdmData);
    behavioralInteraction = metadataService.getMediaStreamNumber(mdmData, 1);

    if (config.voteEnabled) {
      metadataService.updateFromString({ Url: config.galleryURL });
    }

    if (mdmData) {
      metadataService.updateFromJSON(mdmData);
      if (uniqueIDPrime) {
        metadataService.updateFromJSON({ Overlay_UniqueId: uniqueIDPrime });
      }
      if (behavioralInteraction) {
        metadataService.updateFromJSON({ behavioralInteraction: behavioralInteraction });
      }
    } else {
      debug.log('Slide MDM data missing');
    }

    //Add the #hash if one is defined (e.g. #comparison)
    if (mdManager && typeof config.hash !== 'undefined' && config.hash.length) {
      earl = mdManager.getParameterString('Url');
      //Remove any previous hash
      if (earl.includes('#')) {
        earl = earl.substring(0, earl.indexOf('#'));
      }
      earl = '' + earl + config.hash;
      metadataService.updateFromJSON({ 'Url': earl });
    }

    analyticsService.callDynamicPageview();
  }

  function refreshAds(currentContext, isMobile, adLibLoaded, container, bigboxName, templateService) {
    if (!isMobile && adLibLoaded) {
      var adWrapper = container.closest('[data-module]').find('.bigbox-ad'),
          $overBB = void 0;

      if (bigboxName === '') {
        adWrapper.append(templateService.overlayBigbox());
        bigboxName = SniAds.appendSlot('overlay_bigbox', 'dfp_bigbox');
        currentContext.broadcast('gallerydataupdated', {
          overlayBigboxName: bigboxName
        });
        SniAds.Gallery.setSyncSlot(bigboxName);
      } else {
        $overBB = $('#overlay_bigbox').show();

        if (!adWrapper.has('#overlay_bigbox')) {
          $overBB.appendTo(adWrapper);
        } else {
          SniAds.refreshSlot(bigboxName);
        }
      }
    }
  }

  function createAdWrapper(adLib, container, templateService) {
    if (adLib) {
      container.after(templateService.adWrapper());
    }
  }

  function setInterstitialConfig(settings) {
    if (settings.adLibLoaded) {
      var currentSettings = void 0,
          galleryType = void 0;

      galleryType = settings.galleryViewType;

      switch (galleryType) {
        case 'overlay':
          currentSettings = {
            desktop: {
              wrapper: 'photo_interstitial_wrapper',
              slot: 'dfp_photo_interstitial',
              slotInst: 'overlayPhotoIntName',
              markup: 'interstitialWrapper'
            },
            mobile: {
              wrapper: 'photo_interstitial_wrapper_mobile',
              slot: 'dfp_smartphone_interstitial',
              slotInst: 'overlayPhotoIntMobileName',
              markup: 'interstitialWrapperMobile'
            }
          };
          break;
      }

      context.broadcast('gallerydataupdated', {
        interstitialSettings: settings.isMobile ? currentSettings.mobile : currentSettings.desktop
      });
    }
  }

  function createInterstitialContainer(settings, container, templateService) {
    if (settings.adLibLoaded) {

      if (settings.interstitialSettings.slotInst === '' || $('#' + settings.interstitialSettings.slotInst).length === 0) {
        container.before(templateService[settings.interstitialSettings.markup]());
        if (settings.isTablet || settings.isMobile) {
          container.before(templateService.interstitialMobileCloseBtn());
        }

        updateInterstitialSlotInstance(settings);

        SniAds.Gallery.setInterstitialSlot(settings[settings.interstitialSettings.slotInst]);
      } else {
        $('#' + settings.interstitialSettings.slotInst + ', #' + settings.interstitialSettings.wrapper).show();
        SniAds.refreshSlot(settings.interstitialSettings.slotInst);
      }

      createInterstitialOrientationHandler(settings, container);
    }
  }

  function updateInterstitialSlotInstance(settings) {
    if (settings.adLibLoaded) {
      var updatedSlotInst = void 0,
          newInterstitialSettings = void 0;

      updatedSlotInst = SniAds.appendSlot(settings.interstitialSettings.wrapper, settings.interstitialSettings.slot, true);

      newInterstitialSettings = updateObject(settings.interstitialSettings, {
        slotInst: updatedSlotInst
      });

      context.broadcast('gallerydataupdated', {
        interstitialSettings: newInterstitialSettings
      });
    }
  }

  function listenForOrientationChange(settings, container) {
    var orientationHandler = function orientationHandler() {
      if (isInterstitialShown(settings, container) && settings.overlayPhotoIntMobileName) {
        SniAds.refreshSlot(settings.overlayPhotoIntMobileName);
      }
    };
    return orientationHandler;
  }

  function createInterstitialOrientationHandler(settings, container) {
    var handler = listenForOrientationChange(settings, container);
    if (settings.adLibLoaded && settings.isMobile && window.addEventListener && window.removeEventListener) {
      window.addEventListener('orientationchange', handler, false);
      context.broadcast('gallerydataupdated', {
        interstitialOrientationHandler: handler
      });
    }
  }

  function getInterstitial(interstitialShown, container) {
    if (interstitialShown) {
      return container.closest(interstitialShown);
    }
  }

  function isInterstitialShown(settings, container) {
    var intShown = settings.interstitialShownClass;
    return getInterstitial(intShown, container).length > 0;
  }

  function handleInterstitial(settings, currentSlider, container, checkService) {
    if (settings.adLibLoaded) {
      if (settings.isMobile) {
        if (currentSlider.currSlideId >= currentSlider.lastSlideId && currentSlider.currSlideId !== currentSlider.numSlides - 1) {
          SniAds.Gallery.next();
        } else if (currentSlider.currSlideId < currentSlider.lastSlideId && currentSlider.currSlideId !== 0) {
          SniAds.Gallery.previous();
        }
      } else {
        if (currentSlider.lastSlideId >= 0) {
          if (currentSlider.currSlideId >= currentSlider.lastSlideId) {
            SniAds.Gallery.next();
          } else {
            if (currentSlider.currSlideId < currentSlider.lastSlideId) {
              SniAds.Gallery.previous();
            }
          }
        }
      }

      if (isInterstitialShown(settings, container) && (currentSlider.currSlideId === currentSlider.numSlides - 1 || currentSlider.currSlideId !== 0)) {
        var arrows = container.find('.rsArrow');
        arrows.addClass('force-show').on('click.slidesend', function (e) {
          arrows.removeClass('force-show').unbind('click.slidesend');
          closeInterstitial(settings, container, checkService);
          return false;
        });
      }
    }
  }

  function closeInterstitial(settings, container, checkService) {
    if (settings.adLibLoaded) {
      var interstitial = void 0,
          interSlot = void 0,
          interstitialBlurPrevent = void 0;

      if ($('#ad-gallery-control').length > 0 && $('#ad-gallery-control').attr('rel') === 'gallery-blocked') {
        return false;
      }

      interstitial = getInterstitial(settings.interstitialShownClass, container);
      if (interstitial.hasClass('interstitial-show')) {
        interstitial.removeClass('interstitial-show');

        if (checkService.exists('googletag')) {
          interSlot = SniAds.getDefinedSlots()[SniAds.Gallery.getConfigData().interstitialSlot];
          context.getGlobal('googletag').pubads().clear([interSlot]);
        }

        interstitialBlurPrevent = setInterval(function () {
          if (container.hasClass('m-NextAsset--blur') || container.hasClass('slider-blur')) {
            clearInterval(interstitialBlurPrevent);
            container.removeClass('m-NextAsset--blur slider-blur');
          }
        }, 10);

        return true;
      }
      return false;
    }
  }

  function updateShopElement(currentContext, currentSlider) {
    currentContext.broadcast('shopElementChanged', {
      newElement: currentSlider.currSlide.content
    });
  }

  function setReceivedId(transmitter) {
    receivedId = transmitter;
  }

  function traverseSlideshow(container, settings, pageX, currentSlider, checkService) {
    var ad = closeInterstitial(settings, container, checkService);

    if (!settings.isMobile && !ad) {
      if (goNextClick(container, settings.backNavPercent, pageX)) {
        currentSlider.next();
      } else {
        currentSlider.prev();
      }
    }
  }

  function delegateArrowEvents(container, leftSelector, leftType, rightSelector, rightType) {
    var left = container.find(leftSelector),
        right = container.find(rightSelector);

    if (left.length && right.length) {
      left.attr('data-type', leftType);
      right.attr('data-type', rightType);
    }
  }

  function setArrowHoverState(container, leftClass, rightClass, hoverRight) {
    if (hoverRight) {
      container.addClass(rightClass).removeClass(leftClass);
    } else {
      container.addClass(leftClass).removeClass(rightClass);
    }
  }

  function removeArrowHoverState(container, left, right) {
    container.removeClass(left).removeClass(right);
  }

  function getAdditionalContent(currentContext, ajaxUrl, paging, currentAjaxPage, currentSlider, ajaxFetchNumSlides, slideClass) {
    var finalAjaxUrl = ajaxUrl,
        countOfHTML = void 0,
        lastHTML = void 0,
        nextPage = void 0,
        $slideData = void 0,
        $voteSlides = void 0;

    if (finalAjaxUrl !== '') {
      countOfHTML = finalAjaxUrl.match(/.html/g) || 0;

      if (countOfHTML.length > 1) {
        lastHTML = finalAjaxUrl.lastIndexOf('.html');
        finalAjaxUrl = finalAjaxUrl.substring(0, lastHTML);
      }

      if (!config.voteEnabled) {
        if (paging) {
          nextPage = ++currentAjaxPage;

          currentContext.broadcast('gallerydataupdated', {
            ajaxPageWeAreOn: nextPage
          });

          finalAjaxUrl = finalAjaxUrl.substring(0, finalAjaxUrl.lastIndexOf('/p/'));
          finalAjaxUrl += /p/ + nextPage;
        } else {
          finalAjaxUrl += '/o/' + currentSlider.numSlides + '/n/' + ajaxFetchNumSlides;
        }
        finalAjaxUrl = finalAjaxUrl + '.html';
      }

      if (check.isLocalhost() || check.isAuthor()) {
        finalAjaxUrl += '?wcmmode=disabled';
      }

      //if on mobile author
      if (deviceType.isMobile && check.isAuthor()) {
        finalAjaxUrl = finalAjaxUrl.replace(/\.slideshow\.html/, '.mobile.slideshow.html');
        finalAjaxUrl = finalAjaxUrl.replace(/\.galleryoverlay\.html/, '.mobile.galleryoverlay.html');
      }

      currentContext.broadcast('gallerydataupdated', {
        readyToFetchMore: false
      });

      debug.log('getAdditionalContent: finalAjaxUrl: ', finalAjaxUrl);

      $.get(finalAjaxUrl, function (data) {
        debug.log('getAdditionalContent: data: ', data);
        $slideData = $('<div>').append(data);
        debug.log('getAdditionalContent: $slideData: ', $slideData, config.galleryContainerSelector, $slideData.find(config.galleryContainerSelector));

        if (config.voteEnabled) {
          $voteSlides = $('<div>').append($slideData.find(config.galleryContainerSelector));
          debug.log('getAdditionalContent: $voteSlides: ', $voteSlides);
          $slideData = $voteSlides;
        }
        appendSlideData($slideData, currentSlider, slideClass, currentContext);
      });
    }
  }

  function appendSlideData($data, currentSlider, newContentClass, currentContext) {
    debug.log('appendSlideData: ', {
      $data: $data,
      currentSlide: currentSlider,
      newContentClass: newContentClass,
      currentContext: currentContext
    });
    debug.log('appendSlideData: newContent: ', $data.find(newContentClass));
    $data.find(newContentClass).each(function () {
      debug.log('appendSlideData: new slide: ', this);
      currentSlider.appendSlide(this);
      currentContext.broadcast('contentUpdated', {
        newContent: this
      });
    });
  }

  function setupAjaxHandler(type, currentSlider, currentContext, stayAheadAmount, readyToFetch) {
    if (type === 'dynamic') {
      var currentSlide = currentSlider.currSlideId + 1,
          numberOfSlides = currentSlider.numSlides;

      if (numberOfSlides - currentSlide <= stayAheadAmount) {
        if (readyToFetch) {
          currentContext.broadcast('gallery.loadingAdditionalContent');
        }
      } else {
        currentContext.broadcast('gallerydataupdated', {
          readyToFetchMore: true
        });
      }
    }
  }

  function updateCurrentPhotoSearchPage(currentContext, data) {
    currentContext.broadcast('gallerydataupdated', {
      currentSearchResultsPage: data.currentSearchResultsPage
    });
  }

  function setAjaxConfig(currentContext, ajaxUrl, paging, isMobile, searchPage) {
    var url = void 0,
        page = void 0;

    if (paging) {
      if (isMobile) {
        page = searchPage || 1;
        currentContext.broadcast('gallerydataupdated', {
          ajaxPageWeAreOn: page
        });
      } else {
        url = ajaxUrl || window.location.href;
        page = url.substring(url.lastIndexOf('/p/')).split('/p/')[1] || '';
        page = page.split('?')[0];
        if (typeof page === 'undefined' || typeof parseInt(page) !== 'number' || page === '') {
          page = 1;
        }
        currentContext.broadcast('gallerydataupdated', {
          ajaxPageWeAreOn: page
        });
      }
    }
  }

  function getHotspotInstance(currentContext, currentUrl, currentImg, hotspotElement, defaultUrl, single) {
    var img = void 0,
        hotspotUrl = void 0,
        elementUrl = void 0,
        deferredHotspots = void 0;

    img = $(currentImg);
    if (!img.data(hotspotElement)) {
      hotspotUrl = currentUrl;
      deferredHotspots = $.Deferred();
      img.data(hotspotElement, deferredHotspots.promise());
      elementUrl = img.attr('src') || '';
      elementUrl = elementUrl.replace(/\.rend.*/, '');
      currentContext.broadcast('elementUpdated', {
        element: img,
        url: hotspotUrl || defaultUrl,
        imageUrl: elementUrl,
        hotspotShowAll: !single,
        initDeferred: deferredHotspots
      });
    }
  }

  function killItWithFire() {
    $('#overlay_bigbox, #photo_interstitial_wrapper').hide().appendTo('body');
    if (config.interstitialOrientationHandler) {
      window.removeEventListener('orientationchange', config.interstitialOrientationHandler);
    }
    $(document).unbind('keydown.photoGalleryModalKeyFilter');
    $(config.voteReadyBtnSel).off('click.vote-link');
    $(config.nextGalleryLinkSel).off('click.next-gallery-plus-vote');
    $('.nextCat').off('click.vote-link');
    $('[data-type="modal-close"]').off('click.onboard');
    $(document).off('keydown.vote.nextCategory');
    galleryContainer.off('click.vote.nextCategory');
    closeInterstitial(config, galleryContainer, check);
    galleryContainer.find('.rsArrow').off();
    galleryContainer.off();
    slider.destroy();
  }

  function extractData(content) {
    var src = $(content).find('img.rsMainSlideImage').attr('src');
    return {
      imageURL: src
    };
  }

  function setupVote() {
    if ($('body').hasClass('votePage')) {
      config.voteEnabled = true;
      debug.log('setupVote: config.voteElement: ', config.voteElement);
      config.galleryCount = $(config.voteElement).length;
      config.galleryIndex = $galleryElement.data('voteIndex');
      config.galleryParent = $(config.voteElement + '[data-vote-index="' + config.galleryIndex + '"]');
      debug.log('setupVote: galleryParent: ', $(config.voteElement), config.galleryCount, config.galleryParent);
      config.galleryURL = config.galleryParent.data('galleryUrl');
      // config.nextGalleryIndex = config.galleryParent.data('galleryLast') ? 0 : config.galleryIndex+1;
      if ($(config.voteWrapper).filter('[data-vote-voting-allowed]').length) {
        config.voteAllowed = true;
        config.nextGalleryTimeout = 5000;
      }
      if (check.supports('localStorage')) {
        config.rsConfig.loop = JSON.parse(localStorage.getItem('voteLoop'));
        config.loadedState = localStorage.getItem('loadedState');
      }
      if ($(config.voteWrapper).data('nextCategory')) {
        config.rsConfig.loop = false;
      }
      if (config.loadedState === 'vote.ballotState') {
        config.rsConfig.loop = true;
      }
      if (!config.voteAllowed && !$(config.voteWrapper).data('nextCategory')) {
        config.rsConfig.loop = true;
      }
      config.suppressNextGalleryEvent = config.rsConfig.loop;
    }
  }

  function checkAllGalleries() {
    if (config.voteEnabled) {
      $(config.voteElement).each(function () {
        if ($(this).attr('data-gallery-viewed') !== 'true') {
          config.totalPlace++;
          config.nextGalleryIndex = $(this).data('voteIndex');
          return false;
        }
      });
      if (config.totalPlace === $(config.voteElement).size()) {
        config.viewedAllGalleries = true;
      }
    }
  }

  function nextVoteGallery(data) {
    debug.log('nextVoteGallery: data: ', data);
    if (data.$currentParent.attr('data-gallery-viewed') !== 'true') {
      config.numGalleriesViewed++;
      data.$currentParent.data('galleryViewed', true);
      data.$currentParent.attr('data-gallery-viewed', true);
    }
    checkAllGalleries();
    if (config.viewedAllGalleries) {
      context.broadcast('vote.nextCategory', {
        nextCat: data.nextCatUrl
      });
    } else {
      $(config.voteElement + '[data-vote-index="' + data.currentIndex + '"]').attr('data-gallery-viewed', true);
      if (config.ajaxUrl !== $($(config.voteElement + '[data-vote-index="' + config.nextGalleryIndex + '"]')[0]).data('slideshowUrl')) {
        config.ajaxUrl = $($(config.voteElement + '[data-vote-index="' + config.nextGalleryIndex + '"]')[0]).data('slideshowUrl');
        debug.log('nextVoteGallery: loading more content');
        getAdditionalContent(context, config.ajaxUrl, config.ajaxPaging, config.ajaxPageWeAreOn, slider, config.ajaxFetchNumSlides, config.slideClassSelector);
        config.galleryIndex = config.nextGalleryIndex;
        config.galleryParent = $(config.voteElement + '[data-vote-index="' + config.galleryIndex + '"]');
        config.galleryURL = config.galleryParent.data('galleryUrl');
      } else {
        config.viewedAllGalleries = true;
        context.broadcast('vote.nextCategory', {
          nextCat: data.nextCatUrl
        });
      }
    }
  }

  function searchJSONArray(arr, key, val) {
    var $jsonArray = arr;

    for (var i = 0; i < $jsonArray.length; i++) {
      if ($jsonArray[i][key] === val) {
        return $jsonArray[i];
      }
    }

    return false;
  }

  function nextVoteCategory(data) {
    var votes = localStorage.getItem('votes') ? JSON.parse(localStorage.getItem('votes')) : null,
        dupVote = votes !== null ? searchJSONArray(votes, 'voteURL', window.location.href.split('?')[0]) : false,
        headline = $('.assetTitle').find('.headline').text(),
        message = void 0,
        endFrame = void 0;

    if (config.voteEnabled && config.voteAllowed && (votes === null || !dupVote)) {
      message = 'Choose Your Favorite';
    } else {
      message = 'Continue to Next Category';
    }
    endFrame = template.voteEndframe(headline, message);
    if (!config.voteAllowed && !$(config.voteWrapper).data('nextCategory')) {
      config.rsConfig.loop = true;
    } else {
      slider.appendSlide(endFrame);
      if (config.voteEnabled && config.voteAllowed && (votes === null || !dupVote)) {
        context.broadcast('vote.ballotState');
        galleryContainer.on('click.vote.nextCategory', function (e) {
          e.preventDefault();
          e.stopPropagation();
          galleryModal.close('photo-gallery');
          removeGalleryModal('body', context, receivedId);
        });
      } else if (config.voteEnabled && config.voteAllowed && dupVote) {
        galleryContainer.on('click.vote.nextCategory', function (e) {
          e.preventDefault();
          e.stopPropagation();
          window.location.href = $(config.voteWrapper).data('nextCategory');
        });
      }
    }
  }

  function votingModal() {
    if (check.supports('localStorage') && config.voteAllowed) {
      if (!deviceType.isMobile) {
        if (!localStorage.getItem('voteModalShown') || localStorage.getItem('voteModalAlwaysShow')) {
          var onboardMarkup = template.modal({
            id: config.voteModalId,
            heading: 'Please Note',
            body: 'Be sure to view all nominees before casting your vote.',
            actionText: 'Ok, Let\'s Start'
          });
          if (onboardMarkup) {
            $($.parseHTML(onboardMarkup)).appendTo('#photo-gallery');
            localStorage.setItem('voteModalShown', true);

            $('#' + config.voteModalId).find('[data-button-primary], [data-type="modal-close"]').on('click.onboard', function (e) {
              $('#' + config.voteModalId).remove();
              e.preventDefault();
            });
          } else {
            debug.error('There was a problem fetching the onboarding template markup.');
          }
        }
      }
    }
  }

  function removeNextGalleryLink() {
    galleryContainer.find(config.nextGallerySel).remove();
  }

  function bindNextClickEvents() {
    $(config.voteReadyBtnSel).on('click.vote-link', function (e) {
      e.preventDefault();
      e.stopPropagation();
      var votes = localStorage.getItem('votes') ? JSON.parse(localStorage.getItem('votes')) : null,
          dupVote = votes ? searchJSONArray(votes, 'voteURL', window.location.href.split('?')[0]) : false;

      if (config.voteEnabled && config.voteAllowed && (votes === null || !dupVote)) {
        context.broadcast('vote.ballotState');
      }
      galleryModal.close('photo-gallery');
      removeGalleryModal('body', context, receivedId);
    });
    $(config.nextGalleryLinkSel).on('click.next-gallery-plus-vote', function (e) {
      e.preventDefault();
    });
  }

  function _searchJSONArray(arr, key, val) {
    var $jsonArray = arr;
    for (var i = 0; i < $jsonArray.length; i++) {
      if ($jsonArray[i][key] === val) {
        return $jsonArray[i];
      }
    }
    return false;
  }

  function addNextGalleryLink() {
    debug.log('addNextGalleryLink: 3');
    if (isInterstitialShown(config, galleryContainer)) {
      return false;
    }

    var isVoting = config.voteEnabled,
        $galleryOverflow = galleryContainer.find('.rsOverflow'),
        $currentGalleryParent = void 0,
        currentGallery = void 0,
        currentGalleryCollectionIndex = void 0,
        nextGalleryCollectionIndex = void 0,
        galleryCollectionTotal = void 0,
        $nextGalleryParent = void 0,
        nextGalleryTitle = void 0,
        nextGalleryUrl = void 0,
        nextGalleryLinkText = 'Next';

    debug.log(currentGallery, currentGalleryCollectionIndex, galleryCollectionTotal);

    if (isVoting) {
      debug.log('addNextGalleryLink: 3: a');
      $currentGalleryParent = config.galleryParent, currentGallery = isVoting ? $currentGalleryParent.data('slideshowUrl') : window.location.href, currentGalleryCollectionIndex = $currentGalleryParent.data('voteIndex'), nextGalleryCollectionIndex = config.nextGalleryIndex, galleryCollectionTotal = $(config.voteElement).length;
      config.lastGallery = $currentGalleryParent.data('galleryLast');
      if (!config.viewedAllGalleries) {
        debug.log('addNextGalleryLink: 3: b');
        $nextGalleryParent = $(config.voteElement + '[data-vote-index="' + nextGalleryCollectionIndex + '"]');
        nextGalleryTitle = $nextGalleryParent.data('galleryTitle');
        nextGalleryUrl = $nextGalleryParent.data('slideshowUrl');
      }
      if (!nextGalleryTitle) {
        debug.log('addNextGalleryLink: 3: c');
        config.suppressNextGalleryEvent = true;
        return;
      } else {
        debug.log('addNextGalleryLink: 3: d');

        slider.slider.removeClass('m-NextAsset--blur');
        var votes = localStorage.getItem('votes') ? JSON.parse(localStorage.getItem('votes')) : null,
            dupVote = votes ? _searchJSONArray(votes, 'voteURL', window.location.href.split('?')[0]) : false;

        $galleryOverflow.append(template.nextGalleryModal({
          headline: nextGalleryTitle,
          link: nextGalleryUrl,
          subHeadline: nextGalleryLinkText,
          voting: config.voteEnabled && config.voteAllowed && (votes === null || !dupVote)
        }));

        bindNextClickEvents();
      }
    }
  }

  function prepNextVoteGallery() {
    if (config.voteEnabled) {
      debug.log('addNextGalleryLink: 1');
      var $currentGalleryParent = void 0,
          voteGalleryCollectionIndex = void 0,
          voteGalleryCollectionTotal = void 0,
          voteNextCategoryUrl = void 0;

      $currentGalleryParent = config.galleryParent, voteGalleryCollectionIndex = $currentGalleryParent.data('voteIndex'), voteGalleryCollectionTotal = config.galleryCount, voteNextCategoryUrl = $currentGalleryParent.parents(config.voteWrapper).data('nextCategory');

      config.lastGallery = $currentGalleryParent.data('galleryLast');
      config.galleryURL = $currentGalleryParent.data('galleryUrl');

      if (isInterstitialShown(config, galleryContainer)) {
        closeInterstitial(config, galleryContainer, check);
        slider.remove(slider.currSlideId);
        context.broadcast('vote.nextGallery', {
          $currentParent: $currentGalleryParent,
          nextCatUrl: voteNextCategoryUrl,
          totalGalleries: voteGalleryCollectionTotal,
          currentIndex: voteGalleryCollectionIndex,
          nextIndex: voteGalleryCollectionIndex + 1
        });
        addNextGalleryLink();
        return false;
      } else {
        if (!config.voteEnabled) {
          slider.ev.off('rsTryingToAdvancePastLastSlide');
        }
      }
      config.inProgressOfLastSlideAction = config.voteEnabled ? false : true;

      if (config.suppressNextGalleryEvent) {
        return false;
      }

      if (config.voteEnabled) {
        context.broadcast('vote.nextGallery', {
          $currentParent: $currentGalleryParent,
          nextCatUrl: voteNextCategoryUrl,
          totalGalleries: voteGalleryCollectionTotal,
          currentIndex: voteGalleryCollectionIndex,
          nextIndex: voteGalleryCollectionIndex + 1
        });
        removeNextGalleryLink();
      }

      if ($(config.nextGalleryLinkSel).length) {
        $(config.nextGallerySel).html(template.loadingHTML());
        slider.slider.removeClass('m-NextAsset--blur');
      }
    }
  }

  function voteAfterSlide() {
    if (config.voteEnabled) {
      debug.log('addNextGalleryLink: 2');
      if (slider.currSlideId + 1 === slider.numSlides && !config.rsConfig.loop) {
        $('.rsArrowRight.rsArrowDisabled').removeClass('rsArrowDisabled');
        var $currentGalleryParent = config.galleryParent,
            voteGalleryCollectionIndex = $currentGalleryParent.data('voteIndex'),
            voteGalleryCollectionTotal = config.galleryCount,
            voteNextCategoryUrl = $currentGalleryParent.parents(config.voteWrapper).data('nextCategory');

        config.lastGallery = $currentGalleryParent.data('galleryLast');
        config.galleryURL = $currentGalleryParent.data('galleryUrl');
        context.broadcast('vote.nextGallery', {
          $currentParent: $currentGalleryParent,
          nextCatUrl: voteNextCategoryUrl,
          totalGalleries: voteGalleryCollectionTotal,
          currentIndex: voteGalleryCollectionIndex,
          nextIndex: voteGalleryCollectionIndex + 1
        });
        debug.log('addNextGalleryLink: 2: a');
        addNextGalleryLink();
      } else {
        removeNextGalleryLink();
      }
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  module = {

    behaviors: ['shop-this-look', 'social-pinterest', 'hotspot'],

    messages: ['galleryModal.opened', 'gallery.sliderInit', defaults.lastSlideName, defaults.afterSlideName, defaults.beforeAnimName, defaults.beforeSizeName, defaults.afterContentSetName, 'gallery.loadingAdditionalContent', 'gallerydataupdated', 'modal.hidden', 'photos.searchPageUpdated', 'vote.nextGallery', 'vote.nextCategory'],

    init: function init() {
      mdManager = check.exists('mdManager') ? context.getGlobal('mdManager') : false;
      SniAds = context.getGlobal('SniAds');
      setGalleryConfig(defaults, context.getConfig());
      getServices(context);
      setPreloaderHTML(template.preloaderHTML());
      updateConsecutiveGallery(context, metadata, {
        originalGallery: config.originalGallery,
        consecutiveGallery: config.consecutiveGallery
      });
      setGalleryConfig(config, { isMobile: deviceType.isMobile, isTablet: deviceType.isTablet });
      setGalleryPageTypes(context, config.galleryPageTypes);
      setAjaxConfig(context, config.ajaxUrl, config.ajaxPaging, config.isMobile, config.currentSearchResultsPage);
    },

    destroy: function destroy() {
      killItWithFire();
    },

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'galleryModal.opened':
          cacheElements(context, config.galleryContainerSelector);
          checkAdLibrary(context, check);
          setAdConfig(context, config.adLibLoaded, config.galleryAdSetup, config.coldLoad);
          checkStartSlide(context, $galleryElement, data.startingSlide);
          setSliderConfig(context, config.rsConfig, config.isMobile, config.isTablet, config.galleryStartingPosition);
          setReceivedId(data.origin);
          setInterstitialConfig(config);
          setupVote();
          createAdWrapper(config.adLibLoaded, galleryContainer, template);
          createInterstitialContainer(config, galleryContainer, template);
          prepareGallery(galleryContainer, config.galleryLoadingClass);
          createCustomSliderEvents(context, defaults, $.rsProto, $.rsModules);
          startSlider(context, galleryContainer, config.rsConfig);
          break;
        case 'gallery.sliderInit':
          createCustomPrevNextHandling(slider);
          refreshAds(context, config.isMobile, config.adLibLoaded, galleryContainer, config.overlayBigboxName, template);
          handleInterstitial(config, slider, galleryContainer, check);
          processSlideMetadata($(slider.currSlide.content.context), metadata, analytics);
          $slideToolbar = createSlideToolbar(config.isMobile, galleryContainer);
          delegateArrowEvents(galleryContainer, config.previousArrowSelector, config.leftDataType, config.nextArrowSelector, config.rightDataType);
          if (config.voteEnabled) {
            votingModal();
          }
          getHotspotInstance(context, $(slider.currSlide.content.context).data(config.hotspotUrlName), slider.currSlide.content.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, config.galleryPageTypes.singleImage);
          context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content));
          break;
        case defaults.afterSlideName:
          setupAjaxHandler(config.galleryType, slider, context, config.ajaxStayAhead, config.readyToFetchMore);
          refreshAds(context, config.isMobile, config.adLibLoaded, galleryContainer, config.overlayBigboxName, template);
          voteAfterSlide();
          handleInterstitial(config, slider, galleryContainer, check);
          processSlideMetadata($(slider.currSlide.content.context), metadata, analytics);
          incrementOriginalGallery(context, metadata, config);
          updateShopElement(context, slider);
          getHotspotInstance(context, $(slider.currSlide.content.context).data(config.hotspotUrlName), slider.currSlide.content.find(config.hotspotElement), config.hotspotElement, config.hotspotUrlName, window.location.pathname, config.galleryPageTypes.singleImage);
          context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content));
          break;
        case defaults.beforeAnimName:
          removeNextGalleryLink();
          createSlideNumbering(config.galleryType, template, slider, config.photoTraySelector);
          maintainTrayVisibility(slider.currSlide.content.find(config.photoTraySelector), config.hiddenTrayClass, config.visibleTrayClass, config.currentTrayVisiblity, config.isMobile);
          break;
        case defaults.beforeSizeName:
          // setTimeout(function() {
          //   context.broadcast('gallery.sizeSet', {
          //     targetElement: slider.currSlide.content
          //   });
          // }, 200);
          break;
        case defaults.afterContentSetName:
          context.broadcast('gallery.ImageUpdate', extractData(slider.currSlide.content));
          createSlideNumbering(config.galleryType, template, slider, config.photoTraySelector);
          updateShopElement(context, slider);
          break;
        case defaults.lastSlideName:
          prepNextVoteGallery();
          break;
        case 'gallery.loadingAdditionalContent':
          getAdditionalContent(context, config.ajaxUrl, config.ajaxPaging, config.ajaxPageWeAreOn, slider, config.ajaxFetchNumSlides, config.slideClassSelector);
          break;
        case 'gallerydataupdated':
          setGalleryConfig(config, data);
          break;
        case 'modal.hidden':
          removeGalleryModal('body', context, receivedId);
          break;
        case 'photos.searchPageUpdated':
          updateCurrentPhotoSearchPage(context, data);
          break;
        case 'vote.nextGallery':
          nextVoteGallery(data);
          break;
        case 'vote.nextCategory':
          if (config.readyForNextVoteCat) {
            config.readyForNextVoteCat = false;
            nextVoteCategory(data);
          }
          break;
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'modal-close':
          debug.log('modal-close');
          removeGalleryModal('body', context, receivedId);
          break;
        case 'close-mobile-interstitial':
          closeInterstitial(config, galleryContainer, check);
          break;
        case 'toggle-photo-tray':
          setTrayVisibility(context, element, config.hiddenTrayClass, config.visibleTrayClass, config.isMobile);
          break;
        case 'open-next-gallery':
          slider.next();
          break;
        case 'contain-gallery':
          traverseSlideshow(galleryContainer, config, event.pageX, slider, check);
          break;
      }
    },

    onmouseover: function onmouseover(event, element, elementType) {
      switch (elementType) {
        case 'increment-slide':
          setArrowHoverState(galleryContainer, config.hoverLeftClass, config.hoverRightClass, true);
          break;
        case 'decrement-slide':
          setArrowHoverState(galleryContainer, config.hoverLeftClass, config.hoverRightClass, false);
          break;
      }
    },

    onmouseout: function onmouseout(event, element, elementType) {
      switch (elementType) {
        case 'increment-slide':
          removeArrowHoverState(galleryContainer, config.hoverLeftClass, config.hoverRightClass);
          break;
        case 'decrement-slide':
          removeArrowHoverState(galleryContainer, config.hoverLeftClass, config.hoverRightClass);
          break;
      }
    }

  };

  return module;
});

/***/ }),
/* 353 */
/***/ (function(module, exports) {

SNI.Application.addModule('photo-grid', function (context) {

  var cqWCMDisabled = context.getGlobal('cqWCMDisabled'),
      localStorage = context.getGlobal('localStorage'),
      SniAds = context.getGlobal('SniAds'),
      check = context.getService('check'),
      template = context.getService('template'),
      analytics = context.getService('analytics'),
      deviceType = context.getService('device-type'),
      utility = context.getService('utility'),
      ajax = context.getService('ajax'),
      adLibLoaded = check.exists('SniAds'),
      debug = context.getService('logger').create('module.photo-grid');

  var defaults = void 0,
      $element = void 0,
      module = void 0,
      config = void 0,
      currentSize = void 0,
      $switchButtonGroup = void 0,
      $switchButtons = void 0,
      $grid = void 0,
      $gridImages = void 0;

  defaults = {
    loadingHTML: template.loadingHTML(),
    hasLocalStorage: check.supports('localStorage'),
    isMobile: deviceType.isMobile,
    autoLoadMore: false,
    loadMoreTrigger: false,
    loaderSel: '#loadingdot',
    moduleContainer: $('.area[data-sni-area=searchGrid]'),
    wrapper: '.slideshow-wrapper',
    triggerSelector: '.loadmore-trigger',
    buttonGroupSelector: '.switch-grid-view',
    gridSelector: '.search-grid',
    ajaxTarget: 'searchGrid',
    gridImageSelector: '.media img',
    localStorageGridSize: 'grid-size',
    smooth: 'smooth',
    gridSize: 'searchGridSize',
    scrollEvent: 'scroll.lazyload',
    resizeEvent: 'resize.lazyload',
    readyToTrigger: true
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setGridConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function cacheElements(element) {
    $switchButtonGroup = element.find(config.buttonGroupSelector);
    $switchButtons = $switchButtonGroup.find('button');
    $grid = element.find(config.gridSelector);
    $gridImages = $grid.find(config.gridImageSelector);
  }

  function getGridSize() {
    if (config.isMobile) {
      return 'small';
    }
    if (config.hasLocalStorage && localStorage.getItem(config.localStorageGridSize)) {
      return localStorage.getItem(config.localStorageGridSize);
    }
    return 'small';
  }

  function setSwitchButtons() {
    $switchButtons.removeClass('active');
    $switchButtonGroup.find('button[data-search-grid-size=' + self.currentSize + ']').addClass('active');
  }

  function setGridClass() {
    $grid.removeClass('search-grid-small search-grid-large');
    $grid.addClass('search-grid-' + currentSize);
  }

  // need to replace this with lazy-load behavior
  // have to figure out how to handle the currentSize stuff
  function loadImages() {
    $gridImages.each(function () {
      var $img = $(this),
          newSource = $img.attr('data-src-' + currentSize);
      $img.attr('src', newSource);
    });
  }

  function saveGridSize(size) {
    if (config.hasLocalStorage) {
      localStorage.setItem('config.localStorageGridSize', size);
    }
  }

  function setGridSize(el) {
    var newSize = $(el).data(config.gridSize);
    if (currentSize !== newSize) {
      currentSize = newSize;
      saveGridSize(newSize);
      $gridImages.hide();
      setSwitchButtons();
      setGridClass();
      loadImages();
      $gridImages.fadeIn('10');
    }
  }

  function smoothItOut(element, addition) {
    $(window).load(function () {
      element.addClass(addition);
    });
  }

  function setTrigger() {
    if (deviceType.isMobile) {
      config.loadMoreTrigger = initLoadMoreTrigger($element.find(config.triggerSelector));
    }
  }

  function autoLoad(data) {
    var $currentTrigger = void 0,
        ajaxURL = void 0,
        page = void 0;
    if (cqWCMDisabled && config.autoLoadMore) {
      config.readyToTrigger = false;
      $currentTrigger = data.element;
      if (typeof $currentTrigger !== 'undefined') {
        ajaxURL = data.ajaxUrl;
        page = ajaxURL.split('/p/')[1] || '';
        context.broadcast('photos.searchPageUpdated', {
          currentSearchResultsPage: page
        });

        if (!ajaxURL) {
          debug.error('init: Yikes! No URL for next page, exiting');
          return false;
        }

        ajax.loadAreaContent({
          target: config.ajaxTarget,
          suppressLoadAnim: true,
          href: ajaxURL
        });
      } else {
        if (deviceType.isMobile) {
          $(config.loaderSel).remove();
        }
      }
    }
    if (deviceType.isMobile && !config.moduleContainer.data('loaderDots') && typeof config.loadMoreTrigger !== 'undefined') {
      config.moduleContainer.data('loaderDots', true).after(config.loadingHTML);
    }
  }

  function initLoadMoreTrigger($loadMoreTrigger) {
    if (!$loadMoreTrigger.length) {
      return;
    }

    $(window).off(config.scrollEvent + ' ' + config.resizeEvent);
    $(window).on(config.scrollEvent + ' ' + config.resizeEvent, function () {
      if (utility.isInViewport($loadMoreTrigger[0])) {
        $loadMoreTrigger.remove();
        context.broadcast('loadMore.triggered', {
          type: 'loadMore.triggered',
          element: $loadMoreTrigger,
          ajaxUrl: $loadMoreTrigger.data('ajaxUrl')
        });
        if (adLibLoaded) {
          SniAds.appendSlot('.bigbox-' + $loadMoreTrigger.attr('data-pagenum'), 'dfp_bigbox');
        }
      }
    });
    return $loadMoreTrigger;
  }

  module = {
    messages: ['loadMore.triggered', 'ajax.areaContentLoaded'],
    init: function init() {
      setGridConfig(defaults, context.getConfig());
      $element = $(context.getElement());
      cacheElements($element);
      currentSize = getGridSize();
      setSwitchButtons();
      setGridClass();
      loadImages();
      smoothItOut($grid, config.smooth);
      setTrigger();
    },


    updateObject: updateObject,
    setGridConfig: setGridConfig,

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'loadMore.triggered':
          debug.log('loadMore.triggered: data: ', data);
          if (deviceType.isMobile && config.readyToTrigger) {
            autoLoad(data);
          }
          break;
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'set-size':
          setGridSize(element);
          analytics.callDynamicPageview();
          break;
      }
    }
  };

  return module;
});

/***/ }),
/* 354 */
/***/ (function(module, exports) {


/**
  * Pinterest Embed : Profile, Board, or Pin
  * -------------------------------------------------------------
  */
SNI.Application.addModule('pinterest-embed', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.pinterest-embed');
  var $element = $(context.getElement());

  var defaults = {
    'pinURL': 'https://www.pinterest.com/pin/create/button/?',
    'jsURL': '//assets.pinterest.com/js/pinit.js',
    'pintype': 'profile',
    'pinSize': 'small',
    'boardWidth': '596',
    'scaleHeight': '240',
    'scaleWidth': '80'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  function attachPinEmbed($container) {

    var $pinEmbed = buildPinEmbed();
    $container.append($pinEmbed);
  }

  function buildPinEmbed($container) {

    var $pinEmbed = $('<a></a>').attr('data-pin-do', getPinDo()).attr('href', config.pinURL);

    // set attributes are different for pin, same for board and profile
    if (config.pintype === 'board' || config.pintype === 'profile') {
      $pinEmbed.attr('data-pin-board-width', config.boardWidth).attr('data-pin-scale-height', config.scaleHeight).attr('data-pin-scale-width', config.scaleWidth);
    } else if (config.pintype === 'pin') {
      $pinEmbed.attr('data-pin-width', config.pinSize);
    }

    return $pinEmbed;
  }

  // returns the correct value for the data-pin-do attribute based ont
  // the pintype in the config
  function getPinDo() {
    var pinDo = '';

    switch (config.pintype) {
      case 'board':
        pinDo = 'embedBoard';
        break;

      case 'profile':
        pinDo = 'embedUser';
        break;

      case 'pin':
        pinDo = 'embedPin';
        break;
    }

    return pinDo;
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    init: function init() {
      debug.log('Pinterest Embed: Init Start');
      attachPinEmbed($element);
    }
  };
});

/***/ }),
/* 355 */
/***/ (function(module, exports) {

SNI.Application.addModule('point-of-interest', function (context) {

  var element = $(context.getElement()),
      $element = $(element),
      debug = context.getService('logger').create('module.pointofinterest');

  var defaults = {
    websiteClass: '.o-PointOfInterest__a-Button--Website'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  return {
    behaviors: ['maps', 'customer-service', 'call-protocol'],

    config: config,

    init: function init() {
      debug.log('this is point of interest');
      this.updateWebProtocol();
      this.updateButtonLayout();
    },

    updateWebProtocol: function updateWebProtocol() {
      $element.find(config.websiteClass).each(function () {

        var $this = $(this),
            webUrl = $this.attr('href'),
            newWebUrl = void 0;
        if (webUrl.indexOf('http://http://') !== -1) {
          newWebUrl = webUrl.replace('http://http://', 'http://');
          $this.attr('href', newWebUrl);
        }
      });
    },

    updateButtonLayout: function updateButtonLayout() {
      $element.find('[data-button]').each(function () {
        var $this = $(this),
            buttonNumber = $this.children('a').length;

        if (buttonNumber < 3 && buttonNumber > 0) {
          $this.attr('class', 'l-Columns l-Columns--' + buttonNumber + 'up');
        }
      });
    }
  };
});

/***/ }),
/* 356 */
/***/ (function(module, exports) {

SNI.Application.addModule('product-launch', function (context) {
  var lazy = context.getService('lazy-load'),
      modal = context.getService('modal');
  var element = void 0,
      $element = void 0,
      $modal = void 0,
      $carousel = void 0,
      $currentScrollPos = void 0; // Find the hidden carousel markup

  var defaults = {
    modalId: 'default-Modal',
    carousel: '.products-wrapper',
    closeButtonParent: '.o-ProductsOverlay',
    hasTransition: false,
    overrides: {
      backdropAlternate: '',
      noScroll: false,
      deferStop: true,
      clearContents: true
    }
  };

  var settings = context.getConfig();
  var config = $.extend(true, {}, defaults, settings);

  function setLazyLoad() {
    var $images = $carousel.find('img');
    lazy.addImages({
      settings: {
        usePlaceholder: false
      },
      container: $carousel
    });
    lazy.loadImages($images);
  }

  function generateModal() {
    var data = $carousel && $carousel.get(0).outerHTML; //  include the [data-module="carousel"] element
    if (data) {
      $modal = modal.create({
        modalId: config.modalId,
        content: data,
        closeButtonParent: config.closeButtonParent,
        hasTransition: config.hasTransition,
        clearContents: false,
        overrides: {
          backdropAlternate: config.overrides.backdropAlternate,
          noScroll: config.overrides.noScroll,
          deferStop: config.overrides.deferStop,
          clearContents: config.overrides.clearContents
        }
      });
      $modal.show();
    }
  }

  //  Since the carousel is un-initalized and not visible we need to force lazy load images to trigger
  var onclick = function onclick(e, container, dataType) {
    if (dataType === config.modalId) {
      $currentScrollPos = $(document).scrollTop();
      e.preventDefault();
      //  Lazy Load utility should be run before loading to modal
      setLazyLoad();

      // Create the modal
      generateModal();

      if ($currentScrollPos !== null) {
        window.scrollTo(0, $currentScrollPos);
      }
    }
  };

  return {
    behaviors: ['deferred-loader'],
    onclick: onclick,
    init: function init() {
      element = context.getElement();
      $element = $(element);
      $carousel = $element.find(config.carousel); // Find the hidden carousel markup
    }
  };
});

/***/ }),
/* 357 */
/***/ (function(module, exports) {

SNI.Application.addModule('profile-promo', function (context) {

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 358 */
/***/ (function(module, exports) {

SNI.Application.addModule('promo-collage', function (context) {

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 359 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-body', function (context) {

  return {
    behaviors: ['read-more']
  };
});

/***/ }),
/* 360 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-box-nav', function (context) {

  var debug = context.getService('logger').create('module.recipe-box-nav');
  var loadBehaviors = [];

  // Turn new gigya features on or off depending on config
  if (SNI.Config.useGigyaLogin) {
    loadBehaviors.push('gigya/handle-login', 'gigya/login');
    debug.log('Gigya login activated by OSGI setting. Adding behaviors: ' + loadBehaviors.join(', '));
  }

  return {
    behaviors: loadBehaviors
  };
});

/***/ }),
/* 361 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-info', function (context) {

  return {
    behaviors: ['toggle-on-message'],
    init: function init() {
      //console.log('recipeInfo init');
    }
  };
});

/***/ }),
/* 362 */
/***/ (function(module, exports) {

/**
 * Module is managing the list of selected ingredients
 * API (broadcasted events)
 *  'recipeIngredients:selected'    - some ingredient got selected
 *  'recipeIngredients:unselected'  - some ingredient got un-selected
 *  'recipeIngredients:none'        - all ingredients got un-selected
 *  'recipeIngredients:all'         - all ingredients got selected
 *  'recipeIngredients:submit'      - ingredients is submited to brand (recipebox, walmart, instacart etc.)
 *
 */
SNI.Application.addModule('recipe-ingredients', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.recipe-ingredients');

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  var defaults = {
    item: {
      selectorAll: 'input[data-type="list-item"]',
      selectorChecked: ':checked',
      selectorUnchecked: ':not(:checked)',
      activeClass: 'active'
    },
    action: {
      brand: 'recipeBox',
      label: 'Add to Grocery List',
      selector: '[data-type="list-action"]' /*,
                                            activeClass: 'active'*/
    },
    successBox: {
      selector: '.box-shopping-list-success.mrb-module'
    }
  };

  var settings = $.extend(true, {}, defaults, context.getConfig());
  var $element = $(context.getElement());
  var $action = $element.find(settings.action.selector);

  var init = function init() {
    debug.log('Module started', settings);

    getSelection();
  };

  var onchange = function onchange(e, container, type) {
    if (type === 'list-item') {

      var $item = $(container);
      var isSelected = $item.is(settings.item.selectorChecked);

      $item.parent().toggleClass(settings.item.activeClass, isSelected);

      if (isSelected) {
        context.broadcast('recipeIngredients:selected', $item.val());
      } else {
        context.broadcast('recipeIngredients:unselected', $item.val());
      }

      getSelection();

      e.stopPropagation();
    }
  };

  var getSelection = function getSelection() {
    var selectedItems = [];
    var allItems = $element.find(settings.item.selectorAll);

    allItems.filter(settings.item.selectorChecked).each(function () {
      selectedItems.push($(this).val());
    });

    if (selectedItems.length === 0) {
      $action.attr('disabled', 'disabled');
    } else {
      $action.removeAttr('disabled');
    }

    if (selectedItems.length === 0) {
      context.broadcast('recipeIngredients:none', selectedItems);
    } else if (selectedItems.length > 0 && selectedItems.length === allItems.length) {
      context.broadcast('recipeIngredients:all', selectedItems);
    }

    debug.log('Selected items', selectedItems);
    return selectedItems;
  };

  var onclick = function onclick(e, container, type) {
    if (type === 'list-action') {
      e.stopPropagation();
      e.preventDefault();
      context.broadcast('recipeIngredients:submit', { items: getSelection(), settings: settings });
    } else if (type === 'close-success') {
      $element.find(settings.successBox.selector).hide();
    }
  };

  var messageHandlers = {
    'hide-dialog-uncheck-all': function hideDialogUncheckAll() {
      debug.log('hide-dialog-uncheck-all');
      $element.find(settings.successBox.selector).toggle();
      //$element.find('li').removeClass('active');
    }
  };

  return {
    behaviors: [],
    init: init,
    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },

    onchange: onchange,
    onclick: onclick
  }; //end return
});

/***/ }),
/* 363 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-lead', function (context) {

  return {
    behaviors: ['truncate']
  };
});

/***/ }),
/* 364 */
/***/ (function(module, exports) {

/**
 *
 */
SNI.Application.addModule('recipe-method', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.recipe-method');
  var VIDEO_SCROLL_TOP_ELEMENT = '[data-video-scroll-anchor]';
  var ASSET_MULTI_COLLAPSE = '.o-AssetMultiMedia.is-Collapsed';

  var onclick = function onclick(e, container, type) {
    debug.log('WatchHowTo click');
    if (type === 'watchHowTo') {

      debug.log('WatchHowTo scroll');

      var assetVideoId = $('[data-module=video-embed]', '.assetMultimedia').attr('id');
      debug.log('AssetMultimedia Video ID: ' + assetVideoId);

      if (assetVideoId) {
        debug.log('WatchHowTo lightbox expand', { id: assetVideoId });
        $('html, body').animate({ scrollTop: $(VIDEO_SCROLL_TOP_ELEMENT).offset().top }, 'slow');
        if ($(ASSET_MULTI_COLLAPSE).length > 0) {
          context.broadcast('lightbox.expand', { id: assetVideoId });
        } else {
          context.broadcast('lightbox.watchHow', { id: assetVideoId });
        }
      }

      e.stopPropagation();
      e.preventDefault();
    }
  };

  return {
    onclick: onclick
  };
});

/***/ }),
/* 365 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-playlist', function (context) {

  var deviceType = context.getService('device-type');
  var debug = context.getService('logger').create('module.recipe-playlist');

  // make a click on the mobile playlist media strip act like a click on the playlist caorusel:
  function handleClick(evt, elt, etype) {
    if (deviceType.isMobile) {
      debug.log('clicked on a ' + etype);
      switch (etype) {
        case 'slide':
          $(document.body).animate({ scrollTop: $('.lead-sections').offset().top - 80 }, 100);
          context.broadcast('carousel.slide.clicked', {
            slide: elt
          });
      }
    }
  }

  return {

    behaviors: ['lightbox', 'toggle-on-message'],

    onclick: handleClick

  };
});

/***/ }),
/* 366 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-search-form', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var defaults = {
    searchType: 'module search'
  };

  var $element = $(context.getElement());
  var config = Object.assign({}, defaults, context.getConfig());

  var cqWCMDisabled = context.getGlobal('cqWCMDisabled');
  var debug = context.getService('logger').create('module.recipe-search-form');
  var check = context.getService('check').new(debug);

  var $searchInput = void 0;
  var $facetFilter = void 0;
  var HEADER_INPUT_ID = 'searchHeader';
  var PHOTO_INPUT_ID = 'searchPhoto';
  var HEADER_SEARCH_COOKIE = 'headerSearch';
  var PHOTO_SEARCH_COOKIE = 'photoSearch';

  var cookieSvc = context.getService('cookie');

  //Assigns user search term to cookie to be displayed on pages.
  var setCookie = function setCookie(sTerm) {

    var actualInputID = $searchInput.attr('id');

    if (actualInputID === HEADER_INPUT_ID) {
      cookieSvc.set(HEADER_SEARCH_COOKIE, sTerm, false, false, true);
    }

    if (actualInputID === PHOTO_INPUT_ID) {
      cookieSvc.set(PHOTO_SEARCH_COOKIE, sTerm, false, false, true);
    }
  };

  //Displays cookie from user input to remain in search form.
  var applyCookie = function applyCookie() {

    var cookieHeader = cookieSvc.get(HEADER_SEARCH_COOKIE);
    var cookiePhoto = cookieSvc.get(PHOTO_SEARCH_COOKIE);
    var actualInputID = $searchInput.attr('id');

    //Apply header search to form and cookie, clear out photo cookie
    if (actualInputID === HEADER_INPUT_ID && cookieHeader) {
      $searchInput.val(cookieHeader);
    }

    //Apply photo library search to form and cookie, clear out header search and header cookie
    if (actualInputID === PHOTO_INPUT_ID && cookiePhoto) {
      $searchInput.val(cookiePhoto);
    }

    /* need to think about this one....
      //Pass header search cookie to photoLibrary search when viewing search results
      $('.collage').on('click', function() {
        cookieSvc.set(PHOTO_SEARCH_COOKIE, cookieHeader, false, false, true);
        $photoInput.val(cookiePhoto);
      });
    */
  };

  // reset the form (action on hitting reset button)
  var resetInput = function resetInput() {
    $searchInput.val('').focus();
    $element.find('.typeahead-result').remove();
    $element.find('.typeahead-field').removeClass('show-reset');
  };

  // update reset button visibility based on input empty or not
  var ckClrResetBtn = function ckClrResetBtn($input) {
    if ($input.val().length <= 0) {
      $element.find('.typeahead-field').removeClass('show-reset');
    } else {
      $element.find('.typeahead-field').addClass('show-reset');
    }
  };

  var doSubmit = function doSubmit($form) {

    //strip special characters from Url and searchBoxes
    var formAction = $form.attr('action');
    var queryActionSuffix = check.isAuthor() ? '-.html' : '-';
    var formTerm = decodeURI($searchInput.val()).replace(/\%3D/g, '').replace(/\=/g, '').replace(/\%3C/g, '').replace(/</g, '').replace(/\%28/g, '').replace(/\(/g, '').replace(/\%3F/g, '').replace(/\?/g, '').replace(/\"/g, '');

    $searchInput.val(formTerm);

    setCookie(formTerm);

    var searchQueryAction = formTerm.replace(/\-/g, '_').replace(/\s/g, '-').replace(/\%20/g, '-');

    var href = formAction + '/' + searchQueryAction + queryActionSuffix + $facetFilter.val();

    if (check.isAuthor() && cqWCMDisabled) {
      href = href + '?wcmmode=disabled';
    }

    var searchFormMetrics = { 'internalSearchType': config.searchType };

    if (check.supports('localStorage')) {
      localStorage.setItem('searchFormMetrics', JSON.stringify(searchFormMetrics));
    }

    /** If in an iframe, open search in a new window.*/
    if (window.top !== window.self) {
      window.open(href);
    } else {
      /** doing window location here for CQ. If we just change the action and natively submit this form, it will add a querystring (or POST). Either of these methods break CQ caching, so we cannot do it. Because of that, we have to hack a bit with the form submission */
      window.location = href;
    }

    return false;
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  var init = function init() {

    // search input element
    $searchInput = $element.find('[data-type="search-input"]');
    $facetFilter = $element.find('[data-type="facet-filter"]');

    //Apply cookie to search input (header or photo) to stay in form until replaced or exit.
    applyCookie();

    // would rather use the proper T3 event API but typeahead plugin conflicts:
    $element.find('[data-type="reset-btn"]').on('click', function (evt) {
      evt.preventDefault();
      resetInput();
    });

    // assumes module is the form elt; T3 doesn't handle onsubmit well: doesn't pass elt or elt-type)
    $element.on('submit', function (evt) {
      evt.preventDefault();
      doSubmit($element);
    });
  };

  // T3 click is basically useless bc evt swallowed by typeahead plugin (works when typeahead off)
  // let onclick = function(evt, elt, eltType) {
  // };

  // bind showing/hiding of reset button on keyup (input changed)
  var onkeyup = function onkeyup(evt, elt, eltType) {
    if (eltType === 'search-input') {
      ckClrResetBtn($(elt));
    }
  };

  return {

    init: init,

    onkeyup: onkeyup

  };
});

/***/ }),
/* 367 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-shopping-list', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var debug = context.getService('logger').create('module.recipe-box'),
      mdManager = context.getGlobal('mdManager'),
      gigyaService = context.getService('gigya/account'),
      detailId = mdManager.getDetailId();
  var gigyaObject = void 0,
      gigyaUserId = void 0,
      signatureTimestamp = void 0,
      getAccountInfo = void 0,
      uidSignature = void 0,
      shoppingList = void 0,
      customGigyaMsg = '.shopping-list';

  //let config = Object.assign({}, defaults, context.getConfig());
  //const $element = $(context.getElement());

  getAccountInfo = function getAccountInfo() {
    debug.log('getAccountInfo called');
    gigyaService.isLoggedIn(customGigyaMsg);
  };

  function processGigyaUserInfo(eventObj) {
    gigyaObject = eventObj;
    gigyaUserId = gigyaObject.UID;
    signatureTimestamp = gigyaObject.signatureTimestamp;
    uidSignature = encodeURIComponent(gigyaObject.UIDSignature);

    var baseUrl = 'http://recipes.foodnetwork.com/api/shoppingList/add?recipeId=' + detailId + '&gigyaUserId=' + gigyaUserId + '&signatureTimestamp=' + signatureTimestamp + '&uidSignature=' + uidSignature;

    //Do Ajax post
    $.ajax({
      type: 'POST',
      url: baseUrl,
      data: { 'ingredients[]': shoppingList.items },
      success: function success(data) {
        context.broadcast('hide-dialog-uncheck-all', 'Extra data');
      }
    });
  }

  var messageHandlers = {
    'recipeIngredients:submit': function recipeIngredientsSubmit(list) {
      shoppingList = list;
      getAccountInfo();
    },
    'gigya.isloggedIn.shopping-list': function gigyaIsloggedInShoppingList(response) {
      processGigyaUserInfo(response);
    },
    'gigya.isloggedOut.shopping-list': function gigyaIsloggedOutShoppingList() {
      gigyaService.showLoginScreen(true, false, '');
    }
  };

  return {
    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    }
  }; //end return
});

/***/ }),
/* 368 */
/***/ (function(module, exports) {

SNI.Application.addModule('recipe-video', function (context) {

  return {
    behaviors: ['toggle-on-message'],
    init: function init() {
      //console.log('recipeInfo init');
    }
  };
});

/***/ }),
/* 369 */
/***/ (function(module, exports) {

SNI.Application.addModule('related-videos', function (context) {
  return {
    behaviors: ['load-more', 'lazy-load']
  };
});

/***/ }),
/* 370 */
/***/ (function(module, exports) {

SNI.Application.addModule('reviews-that-matter', function (context) {
  'use strict';

  var filters = [];
  var tryList = [];

  var $flist = void 0;
  var filter = void 0;
  var paginationIndex = -1;

  var debug = context.getService('logger').create('module.reviews-that-matter');
  var check = context.getService('check').new(debug);
  var mdManager = check.exists('mdManager') ? context.getGlobal('mdManager') : false;
  var detailId = mdManager ? mdManager.getDetailId() : -1;
  var element = context.getElement();
  var $reviewFilters = $('[data-review-filters]', element);
  var defaults = {
    minReviews: 0,
    maxFilters: 20,
    loading: $('[data-loading]', element),
    global_review_filters: $reviewFilters,
    global_review_template: $('#global_review_template', element).html(),
    global_filter_template: $('#global_filter_template', element).html(),
    global_tryout_template: $('#global_tryout_template', element).html(),
    global_rating_template: $('#global_rating_template', element).html(),
    global_review: null,
    global_filters: null,
    base_url: 'http://api.reviews.foodnetwork.com/api/external/',
    content_class_initial: '.o-ReviewsThatMatter__m-Content',
    content_class_modified: 'm-ContentLoaded'
  };
  var config = Object.assign({}, defaults, context.getConfig());

  function error(msg) {
    config.global_review_filters.parent().hide();
    debug.error(msg);
  }

  function errorF() {
    error('getFilters service did not complete and resulted in error.');
  }

  function errorR() {
    error('getReview service did not complete and resulted in error.');
  }

  function omniture(params) {
    if (mdManager && typeof params !== 'undefined') {
      $.each(params, function (key, value) {
        mdManager.setParameter(key, value);
      });
    }
  }

  function updateUI() {

    $(config.content_class_initial).addClass(config.content_class_modified);

    var $element = $(element);
    var i = config.global_review.index + 1;
    var t = config.global_review.filter.count;

    if (i === 1) {
      $element.find('.btn.prev').addClass('disabled');
    } else if (i === t) {
      $element.find('.btn.next').addClass('disabled');
    }

    config.flist.removeClass('disabled').eq(paginationIndex).addClass('disabled');
  }

  function updateRatings($starMarkup, rating) {
    $starMarkup.slice(0, rating).removeClass('gig-rating-star-empty').addClass('gig-rating-star-full');
  }

  function renderRatings($ratingMarkup) {
    var rating = $ratingMarkup.data('star-rating');

    $ratingMarkup.append(config.global_rating_template);

    updateRatings($ratingMarkup.find('.gig-rating-star'), rating);
  }

  function renderReview() {
    var $content = $('[data-type="content"]', element);

    // clean body
    $content.empty();

    // template populated with a review
    $content.append(config.global_review.markup);

    renderRatings($content.find('[data-star-rating]'));

    updateUI();
  }

  function createReview(object) {
    var index = object.index,
        filter = object.filter,
        review = object.review,
        title = object.title,
        user = object.user;

    var stars = '<div data-star-rating="' + review.ratingCount + '"></div>';

    var markup = config.global_review_template;
    markup = markup.replace(/{{body}}/g, decodeURIComponent(review.text).replace(/\+/g, ' '));
    markup = markup.replace(/{{rating}}/g, stars);
    markup = markup.replace(/{{helpful}}/g, review.helpfulCount);
    markup = markup.replace(/{{displayName}}/g, user.displayName);
    markup = markup.replace(/{{location}}/g, user.location);
    markup = markup.replace(/{{reviewDate}}/g, user.reviewDate);
    markup = markup.replace(/{{avatar}}/g, user.avatar);
    markup = markup.replace(/{{userUrl}}/g, user.userUrl);
    markup = markup.replace(/{{current}}/g, index + 1);
    markup = markup.replace(/{{total}}/g, filter.count);
    markup = markup.replace(/{{name}}/g, filter.name);

    return {
      index: index,
      filter: filter,
      review: review,
      title: title,
      user: user,
      markup: markup
    };
  }

  function successR(response) {
    if (response.status !== 'success') {
      return error('getReviews failed : ' + response.statusMsg);
    }

    config.global_review = createReview({
      'index': filter.query.offset,
      'filter': filter,
      'review': response.reviews[0],
      'title': response.recipeTitle,
      'user': response.reviews[0].userInfo
    });

    renderReview();
  }

  function getReviews(filterIndex, reviewIndex) {
    var url = void 0,
        data = void 0; // eslint-disable-line

    //current filter
    filter = filters[filterIndex];

    // get review at index of what is passed in
    filter.query.offset = reviewIndex || 0;

    // set up params
    data = $.param(filter.query);

    // set up request url
    url = config.base_url + 'getReviews.jsp?' + data;

    // do ajax
    $.ajax({
      url: url,
      cache: true,
      success: successR,
      error: errorR
    });
  }

  function goTo(filter, offset, allowOmnitureOverride) {
    // send omniture
    if (typeof offset === 'undefined' || allowOmnitureOverride) {
      var i = filter + 1;

      /* eslint-disable */
      omniture({
        "Filter": "Recipe Reviews Filter - " + config.global_filters[i].name,
        "Review": "Recipe Reviews Index - " + i + " of " + config.global_filters.length
      });
      /* eslint-enable */
    }

    paginationIndex = filter;

    getReviews(filter, offset);
  }

  function next() {
    var i = config.global_review.index + 1,
        len = config.global_review.filter.count;

    /* eslint-disable */
    // send omniture
    omniture({
      "Filter": "Recipe Reviews Filter - " + config.global_review.filter.name
    });
    /* eslint-enable */

    if (i === len) return false;

    goTo(paginationIndex, i);

    return true;
  }

  function prev() {
    var i = config.global_review.index;

    /* eslint-disable */
    // send omniture
    omniture({
      "Filter": "Recipe Reviews Filter - " + config.global_review.filter.name
    });
    /* eslint-enable */

    if (i === 0) return false;

    goTo(paginationIndex, i - 1);

    return true;
  }

  function createFilter(object) {
    var name = object.name,
        id = object.id,
        count = object.count,
        index = object.index,
        title = object.title,
        url = object.url,
        last = object.last || false,
        first = object.first || false,
        allReviews = object.allReviews || false,


    // building unqiue query obj for this filter
    query = {};

    // making markup available
    var markup = config.global_filter_template;
    markup = markup.replace(/{{name}}/g, name);
    markup = markup.replace(/{{count}}/g, count < 0 ? '' : '(' + count + ')');
    markup = markup.replace(/{{id}}/g, id);
    markup = markup.replace(/{{index}}/g, index);

    query.cqid = detailId;
    query.filterid = id;
    query.sort = 'timestamp';
    query.markup = true;

    return {
      name: name,
      id: id,
      count: count,
      index: index,
      title: title,
      url: url,
      last: last,
      first: first,
      allReviews: allReviews,
      markup: markup,
      query: query
    };
  }

  function getTotalReviews() {
    var count = $.trim($('[itemprop="reviewCount"]').text());

    if (count) {
      if (!isNaN(count)) {
        count -= 0;
      }
    } else {
      count = -1;
    }
    return count;
  }

  function renderFilters(renderTo) {
    var i = void 0;

    var len = filters.length;

    // Get number of columns from the DOM
    var columns = renderTo.find('ul').length;

    // Divide by the number of columns and round up
    var resultsPerColumn = Math.ceil(len / columns);

    // Split filters into (n) number of columns
    for (i = 0; i < columns; i++) {
      var results = '';
      var begin = i * resultsPerColumn;
      var end = begin + resultsPerColumn;
      var arr = filters.slice(begin, end);

      arr.forEach(function (result) {
        results += result.markup;
      });

      // render filter results
      renderTo.find('ul').eq(i).append(results);
    }
  }

  function renderTryLinks() {
    var $content = $('[data-type="content"]', element);

    $content.append(config.global_tryout_template);

    var $tnl = $content.find('ul');

    try {
      //'trynow' param is passed for tracking purposes, so we know when users click on the links presented vs. the main links on top
      $tnl.append($flist.eq(tryList[0]).clone().click(function () {
        goTo(tryList[0], 0, 1);
        return false;
      }));

      $tnl.append($flist.eq(tryList[1]).clone().click(function () {
        goTo(tryList[1], 0, 1);
        return false;
      }));

      $tnl.append($flist.eq(tryList[2]).clone().click(function () {
        goTo(tryList[2], 0, 1);
        return false;
      }));

      $tnl.find('li').removeClass('disabled').addClass('try-now');
    } catch (e) {
      debug.error(e);
    }
  }

  function successF(response) {
    var len = void 0,
        items = void 0;

    var maxFilters = config.maxFilters;

    if (response.status !== 'success') {
      return error('getFilters failed : ' + response.statusMsg);
    }

    items = response.items;
    len = items.length;

    if (len === 0) {
      return error('There are no filters for this recipe.');
    }

    //remove last entry
    if (len >= maxFilters) {
      len = maxFilters - 1;
      items = items.splice(0, len);
    }

    //save try links
    try {
      items[0].try = 0;
      items[1].try = 1;
      items[2].try = 2;
    } catch (e) {
      debug.error(e);
    }

    //sort alphabetically
    items.sort(function (a, b) {
      if (a.name.toLowerCase() > b.name.toLowerCase()) return 1;
      if (a.name.toLowerCase() < b.name.toLowerCase()) return -1;
      return 0;
    });

    var i = void 0,
        item = void 0,
        f1 = void 0,
        f2 = void 0;
    for (i = 0; i < len; i++) {

      item = items[i];
      item.index = i;
      //count += (item.count - 0);
      f1 = createFilter(item);
      filters.push(f1);

      if (item.try >= 0) {
        tryList[item.try] = i; //save filter position
      }
    }

    var count = getTotalReviews();

    if (count >= 0 && count < config.minReviews) {
      config.global_review_filters.parent().hide();
      return;
    }

    //add all reviews to filters
    item.index = i;
    item.name = 'all reviews';
    item.count = count;
    item.allReviews = true;
    item.id = 'allReviews';
    f2 = createFilter(item);
    filters.push(f2);

    renderFilters(config.global_review_filters);

    // on complete
    // SNI.Food.Ellipsis({ bindTo:'.stack [rel=ellipsis]' });

    $flist = config.global_review_filters.find('li');

    //export filters node list
    config.flist = $flist;

    //export filters array
    config.global_filters = filters;

    //select first filter  -- EAT-3289  20150714 no longer do this:
    //      var lnk = $flist.eq(0).addClass("current disabled").find('a');
    //      reviews.Pagination.goTo(lnk.data("index"));
    renderTryLinks();
  }

  function getFilters(base_url, detailId) {
    var parameterPair = {
      cqid: detailId
    };
    var data = $.param(parameterPair);
    var url = base_url + 'getFilters.jsp?' + data;

    $.ajax({
      url: url,
      success: successF,
      error: errorF
    });
  }

  return {
    onclick: function onclick(event, element, elementType) {

      var lnk = void 0;

      switch (elementType) {
        case 'filter':
          event.preventDefault();

          lnk = $(element);

          if (lnk.parent().hasClass('disabled')) {
            return false;
          }

          if (element.id === 'filter_allReviews') {
            //scroll to reviews section
            $('html, body').animate({
              scrollTop: $('#communityReviews').offset().top
            }, 400);
          } else {
            goTo(lnk.data('index'));
          }

          break;

        case 'prevLink':
          event.preventDefault();

          lnk = $(this);

          if (lnk.hasClass('disabled')) {
            return false;
          }

          prev();

          break;

        case 'nextLink':
          event.preventDefault();

          lnk = $(this);

          if (lnk.hasClass('disabled')) {
            return false;
          }

          next();

          break;

        default:
          break;
      }
    },
    init: function init() {
      getFilters(config.base_url, detailId);
    },


    getFilters: getFilters
  };
});

/***/ }),
/* 371 */
/***/ (function(module, exports) {

SNI.Application.addModule('search-filter', function (context) {

  var location = context.getGlobal('location'),
      mdManager = context.getGlobal('mdManager'),
      debug = context.getService('logger').create('module.search-filter'),
      check = context.getService('check').new(debug),
      localStorage = check.supports('localStorage') ? context.getGlobal('localStorage') : false;

  var module = void 0,
      defaults = void 0,
      config = void 0;

  defaults = {
    filterField: 'filter',
    removalString: 'remove:',
    refinementString: 'refinement:'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setFilterConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function getMDMParameter(val) {
    return mdManager.getParameterString(val);
  }

  function updateString(updated, existing) {
    var insert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var updatedString = void 0;
    if (insert) {
      updatedString = existing.replace(/(refinement\:)(.+)/g, '$1remove:$2');
    } else {
      updatedString = updated + existing;
    }
    return updatedString;
  }

  function setRemovalKey(val) {
    if (localStorage) {
      localStorage.setItem('removedFilter', val);
    }
  }

  module = {
    behaviors: ['hover-intent'],

    init: function init() {
      setFilterConfig(defaults, context.getConfig());
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'remove-single-facet':
          event.preventDefault();
          setRemovalKey(updateString(config.refinementString + config.removalString, $(element).text()));
          location.href = $(element).attr('href');
          break;
        case 'clear-all-facets':
          event.preventDefault();
          setRemovalKey(updateString(config.removalString, getMDMParameter(config.filterField), true));
          location.href = $(element).attr('href');
          break;
      }
    },

    updateObject: updateObject,
    setFilterConfig: setFilterConfig,
    getMDMParameter: getMDMParameter,
    updateString: updateString,
    setRemovalKey: setRemovalKey
  };

  return module;
});

/***/ }),
/* 372 */
/***/ (function(module, exports) {

SNI.Application.addModule('search-filters', function (context) {

  //let debug = context.getService('logger').create('module.search-filters');
  var $ele = $(context.getElement());
  var device = context.getService('device-type');
  var statsSel = '.o-SearchStatistics';

  if (device.isMobile) {
    $ele.find('[data-refine-button]').first().each(function () {
      var $btn = $(this);
      $(statsSel).css({ paddingRight: $btn.outerWidth(true) });
      $btn.on('click', function () {
        $btn.toggleClass('is-Opened');
        $ele.find('[data-refine-options]').toggle();
      });
    });
    $ele.find('input[data-href-on][data-href-off]').on('change', function () {
      window.location.href = $(this).attr('data-href-' + ($(this).is(':checked') ? 'on' : 'off'));
    });
  }
  return {};
});

/***/ }),
/* 373 */
/***/ (function(module, exports) {

SNI.Application.addModule('select-button', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  var init = function init() {

    var $element = $(context.getElement());

    $element.on('change', function () {
      if ($element.val() !== '') {
        document.location = $element.val();
      }
    });
  };

  return {

    init: init

  };
});

/***/ }),
/* 374 */
/***/ (function(module, exports) {

SNI.Application.addModule('shopping-embed', function (context) {

  var lazy = context.getService('lazy-load');
  var shopping = context.getService('track-shopping');
  var debug = context.getService('logger').create('module.shopping-embed');
  var $element = void 0;
  var componentMetadata = void 0;
  var parentMetadata = void 0;
  var clonesLazyLoaded = false;
  var config = void 0;
  var $carousel = void 0;
  var lazySettings = {
    placeholder: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
    trigger: 'inview',
    usePlaceholder: true
  };
  var defaults = {
    carouselSelector: '.m-Carousel',
    slideSelector: '.m-Carousel__m-Slide',
    activeClass: '.active'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function getMetaData() {
    var metadata1 = $element.data('mdm') || {},
        metadata2 = {};

    if (!$carousel.length) {
      metadata2 = $(config.carouselSelector, context.getElement()).find('[data-mdm]').data('mdm');
    } else {
      metadata2 = $carousel.find(config.activeClass).find('[data-mdm]').data('mdm');
    }

    return updateObject(metadata1, metadata2);
  }

  function getParentMetaData() {
    var slideMetadata = $carousel.find(config.activeClass).find('[data-mdm]').data('mdm');

    return updateObject(parentMetadata, slideMetadata);
  }

  return {
    behaviors: ['lazy-load'],

    init: function init() {
      debug.log('init');
      $element = $(context.getElement());
      $carousel = $element.find('[data-module="carousel"]');
      setConfig(defaults, context.getConfig());
      componentMetadata = $element.data('mdm');
      parentMetadata = updateObject($element.data('product-count'), {
        componentname: config.parentComponent
      });
    },


    onmessage: {
      'carousel.loaded': function carouselLoaded(data) {
        $element.addClass('is-Loaded');
        if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id')) {
          shopping.trackProductImpression(getParentMetaData());
        }
      },
      'carousel.changing': function carouselChanging(data) {
        if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id') && !clonesLazyLoaded) {
          lazy.addImages({
            container: $element,
            settings: lazySettings
          });
          lazy.forceScroll();
          clonesLazyLoaded = true;
        }
      },
      'carousel.slideUpdated': function carouselSlideUpdated(data) {
        var metadata = void 0;

        if (config.parentComponent) {
          metadata = getParentMetaData();
        } else {
          metadata = getMetaData();
        }

        if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id')) {
          shopping.trackProductImpression(metadata);
        }
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'product-link':
          var slideMetadata = $(element).closest(config.slideSelector).data('mdm'),
              _componentMetadata = config.parentComponent ? parentMetadata : componentMetadata,
              metadata = updateObject(_componentMetadata, slideMetadata);

          shopping.trackProductClick(metadata);
          break;
        default:
          break;
      }
    }
  };
});

/***/ }),
/* 375 */
/***/ (function(module, exports) {

SNI.Application.addModule('shopping-lead', function (context) {
  var debug = context.getService('logger').create('module.shopping-lead');
  var shopping = context.getService('track-shopping');
  var defaults = {
    carouselSelector: '.m-Carousel',
    slideSelector: '.m-Carousel__m-Slide',
    activeClass: '.active'
  };
  var $element = void 0;
  var $carousel = void 0;
  var config = void 0;
  var parentMetadata = void 0;

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function getMetaData() {
    var slideMetadata = $carousel.find(config.activeClass).find('[data-mdm]').data('mdm');

    return updateObject(parentMetadata, slideMetadata);
  }

  return {
    init: function init() {
      debug.log('init');
      $element = $(context.getElement());
      $carousel = $element.find('[data-module="carousel"]');
      setConfig(defaults, context.getConfig());
      parentMetadata = updateObject($element.data('product-count'), {
        componentname: config.parentComponent
      });
    },


    onmessage: {
      'carousel.loaded': function carouselLoaded(data) {
        $element.addClass('is-Loaded');
        if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id')) {
          shopping.trackProductImpression(getMetaData());
        }
      },
      'carousel.slideUpdated': function carouselSlideUpdated(data) {
        if (data.carouselId && data.carouselId === $element.find('[data-module="carousel"]').attr('id')) {
          shopping.trackProductImpression(getMetaData());
        }
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'product-link':
          var slideMetadata = $(element).closest(config.slideSelector).data('mdm'),
              metadata = updateObject(parentMetadata, slideMetadata);

          shopping.trackProductClick(metadata);
          break;
        default:
          break;
      }
    }
  };
});

/***/ }),
/* 376 */
/***/ (function(module, exports) {

SNI.Application.addModule('shopping-promo', function (context) {
  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 377 */
/***/ (function(module, exports) {

SNI.Application.addModule('show-more', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var debug = context.getService('logger').create('module.show-more');
  var $element = $(context.getElement());
  var elementID = $element.attr('id');
  var maxHeight = 0;
  var $showMoreContainer = $element.find('.show-more-container');

  var defaults = {
    moreText: 'more',
    lessText: 'less'
  };

  var config = Object.assign({}, defaults, context.getConfig());

  function showMore() {
    $element.css('max-height', maxHeight);
    if (config.clearParentStyleSel) {
      $element.closest(config.clearParentStyleSel).removeAttr('style');
    }
  }

  function showLess() {
    $element.css('max-height', '');
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  return {

    showMore: showMore,
    showLess: showLess,
    elementID: elementID,

    behaviors: ['toggle-proxy'],

    init: function init() {

      debug.log('Show More: Init Start');

      var showMoreLink = void 0,
          showLessLink = void 0;

      showMoreLink = $('<span>').addClass('show-link show-more-link').text(config.moreText);
      showLessLink = $('<span>').addClass('show-link show-less-link').text(config.lessText);

      // add in the show less link inside the last child so it appears inline
      $element.children().last().append(showLessLink);

      // show more link is at the bottom right corner by default so it lives as the last child
      $element.append(showMoreLink);

      // Calculate what the max-height of this container should be. We can't use an arbitrary, large value (e.g. 1000px) because
      // there are CSS transitions applied and a large value causes transition delays. This will take the height of the <ul> and
      // add 34px padding for the <h6> and the show/hide <span> elements.
      if ($showMoreContainer.length) {
        maxHeight = $showMoreContainer.height();
      } else {
        maxHeight = $element.find('ul').height() + 34;
      }
    },


    messages: ['toggledOn', 'toggledOff'],

    onmessage: function onmessage(name, containerID) {
      if (containerID === elementID) {
        if (name === 'toggledOn') {
          showMore();
        } else if (name === 'toggledOff') {
          showLess();
        }
      }
    }

  };
});

/***/ }),
/* 378 */
/***/ (function(module, exports) {

SNI.Application.addModule('show-promo', function (context) {

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 379 */
/***/ (function(module, exports) {

SNI.Application.addModule('site-search-results', function (context) {

  return {
    behaviors: ['truncate']
  };
});

/***/ }),
/* 380 */
/***/ (function(module, exports) {

// To support legacy JSP migration to the new social-share behavior
SNI.Application.addModule('social-share', function (context) {
  return {
    behaviors: ['social-share']
  };
});

/***/ }),
/* 381 */
/***/ (function(module, exports) {

SNI.Application.addModule('story-promo', function (context) {

  return {
    behaviors: ['lazy-load', 'multi-component-dynamic-ad', 'collapse-empty-dynamic-slots']
  };
});

/***/ }),
/* 382 */
/***/ (function(module, exports) {

SNI.Application.addModule('sub-navigation', function (context) {

  //let debug = context.getService('logger').create('module.sub-navigation');

  return {
    behaviors: ['dropdown-menu']
  };
});

/***/ }),
/* 383 */
/***/ (function(module, exports) {

SNI.Application.addModule('super-lead-hero', function (context) {
  'use strict';

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 384 */
/***/ (function(module, exports) {

SNI.Application.addModule('tabbed-mobile-search', function (context) {

  return {

    behaviors: ['tab']

  };
});

/***/ }),
/* 385 */
/***/ (function(module, exports) {

SNI.Application.addModule('theme-selector', function (context) {

  return {
    behaviors: ['theme-selector']
  };
});

/***/ }),
/* 386 */
/***/ (function(module, exports) {

SNI.Application.addModule('tweet-embed', function (context) {

  var debug = context.getService('logger').create('module.tweet-embed');

  var module = void 0,
      element = void 0,
      defaults = void 0,
      twttr = void 0,
      config = void 0;

  defaults = {
    tweetURL: '',
    jsURL: '//platform.twitter.com/widgets.js',
    embedURL: 'https://api.twitter.com/1/statuses/oembed.json',
    embedName: 'twitter',
    hideConversation: false,
    hideMedia: false
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setEmbedConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function loadEmbed() {
    var apiPath = config.embedURL,
        url = config.tweetURL,
        hideConversation = config.hideConversation,
        hideMedia = config.hideMedia;

    //Make the API request
    $.ajax({
      url: apiPath,
      dataType: 'jsonp',
      data: {
        url: url,
        hide_thread: hideConversation,
        align: 'center',
        hide_media: hideMedia,
        omit_script: true
      },
      context: this
    }).done(function (response) {
      element.html(response.html);
      twttr.widgets.load();
    }).fail(function (xhr, response) {
      debug.warn('loadEmbed: tweet GET failed: ', response);
    });
  }

  module = {
    init: function init() {
      setEmbedConfig(defaults, context.getConfig());
      element = $(context.getElement());
      twttr = context.getGlobal('twttr');
      loadEmbed();
    },


    updateObject: updateObject,
    setEmbedConfig: setEmbedConfig
  };

  return module;
});

/***/ }),
/* 387 */
/***/ (function(module, exports) {

/**
  * Video Launcher module
  *
  * launches the video overlay
  */

SNI.Application.addModule('video-launcher', function (context) {
  'use strict';

  // let debug = context.getService('logger').create('module.video-launcher');

  var utility = context.getService('utility'),
      modal = context.getService('modal'),
      router = context.getService('router'),
      $element = $(context.getElement()),
      video = context.getService('video'),
      deviceType = context.getService('device-type'),
      mdManager = context.getGlobal('mdManager'),
      currentScrollPos = null;

  var defaults = {
    videoModal: 'video-gallery',
    videoModalId: '#video-gallery'
  };
  var config = $.extend(true, {}, defaults, context.getConfig());

  function bindLauncher() {
    var videoNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var videoModal = void 0;
    var previousURL = window.location.href;
    var timestamp = new Date().getTime();
    var resetScroll = false;

    context.broadcast('previousUrlChanged', {
      previousURL: previousURL
    });

    context.broadcast('stateChanged', {
      gallery: timestamp,
      href: previousURL
    });

    currentScrollPos = $(document).scrollTop();

    /** find the slideshow queue in DOM. We are queuing up the formatted HTML for the current page slideshow */
    var $videoQueue = $element.find('.video-overlay-hidden');

    // Persist which video should be played next
    video.setNext(videoNumber);

    context.broadcast('videoNumberToPlay', {
      playerId: $element.attr('id'),
      videoNumberToPlay: videoNumber
    });

    //INSERT INTO HTML
    var clickVideoHTML = $videoQueue.find('.o-VideoPlaylistEmbed__m-CarouselContainer').find('[data-vid-num]').eq(videoNumber).find('.video-metadata').html();

    $videoQueue.find('.m-VideoMeta').html(clickVideoHTML);

    // clone the element to get ready to start the slideshow
    var $videoOverlay = $videoQueue.clone(true);
    // let $videoPlaylist  = $videoQueue.find('.overlay-playlist').contents().clone(true);
    var videoContainer = $videoOverlay.find('[data-videoplayer-container]');
    var $videoContainer = $(videoContainer);
    var videoModule = $videoOverlay.find('[data-module=video]').get();
    var videoConfig = utility.getModuleConfig(videoModule);

    // no longer a queue
    $videoOverlay.removeClass('video-overlay-hidden');
    $videoContainer.attr({ 'id': 'video-player' });

    /** Renaming the ad slot to match what fw will be looking for.
        This is to avoid duplicate ID's, which originally allowed
        fw to use the original slot, which is not seen by the user **/

    if (videoConfig && videoConfig.syncAdSelector && videoConfig.syncAdStaticId) {
      $videoOverlay.find('#' + videoConfig.syncAdStaticId).attr({
        'id': utility.getIdFromSelector(videoConfig.syncAdSelector)
      });
    }

    if (videoModal === undefined) {

      $videoContainer.attr('id', config.player.containerId);
      if (mdManager.getParameterString('type') === 'fullwidthpage' && !deviceType.isMobile) {
        resetScroll = true;
      }
      // dump it into the modal, the modal will have the controller init the module, which will start the slideshow
      videoModal = modal.open(config.videoModal, $videoOverlay, true, undefined, resetScroll); // the last argument is to tell the modal that a video player is using it
      //$(config.videoModalId).find('[data-videoplayer-container]').attr('id', config.player.containerId);
    } else {
      // $(config.videoModalId).find('.overlay-playlist').html( $videoPlaylist ).end()
      //     .find('.overlay-meta-data section.video-data').html( clickVideoHTML );
      videoModal.show();
    }

    $('body').addClass('full-overlay-modal-open');

    $(window).off('popstate.videoBackButton');
    $(window).one('popstate.videoBackButton', function () {
      videoModal.hide();
    });
  }

  var messageHandlers = {

    'modal.hidden': function modalHidden(_ref) {
      var modal = _ref.modal;


      if (modal.settings.modalId === config.videoModal) {

        /**
             * When we hide the modal we want to restore where we were.
             * This includes scrolling to where we were, showing the site, and switching back the URL
             *
             * The URL handling is kind of dirty, but it gets us around all the use cases which involve dealing with back button and Esc
             */
        $('body').removeClass('full-overlay-modal-open');

        // replace the URL with what was in here when we opened the modal. Its possible that we were replacing URLs and had
        // a totally different URL in the bar
        var timestamp = new Date().getTime();
        var previousUrlModal = router.getPreviousURL();
        context.broadcast('stateChanged', {
          gallery: timestamp,
          href: previousUrlModal
        });

        // in IOS 7.x the History.back was not
        // returning the page to its scroll position
        // added this call to make sure it returns to correct spot
        if (currentScrollPos !== null) {
          window.scrollTo(0, currentScrollPos);
        }
      }
    }

  };

  return {

    config: config,
    defaults: defaults,

    behaviors: ['lazy-load'],

    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },


    onclick: function onclick(event, element, elementType) {
      if (elementType === 'video-launcher') {
        event.preventDefault();
        bindLauncher($(element).attr('data-video-no'));
      }
    }

  };
});

/***/ }),
/* 388 */
/***/ (function(module, exports) {

/**
 * This module is used on pages which have playing video.  It tracks seen videos and subsequently
 * filters seen videos from the endframe and related videos module
 */

SNI.Application.addModule('video', function (context) {

  var modUtil = context.getService('utility');
  var debug = context.getService('logger').create('module.video');
  var check = context.getService('check').new(debug);
  var metadata = context.getService('metadata');
  var mdManager = context.getGlobal('mdManager');
  var analytics = context.getService('analytics');
  var video = context.getService('video');
  var deviceType = context.getService('device-type');
  var sharebar = context.getService('social/sharebar');

  var player = void 0,
      containerId = void 0;

  var defaults = {
    playlistItemSelector: '.o-VideoPlaylistPromo__m-Carousel .m-Carousel__m-Slide .m-MediaBlock',
    relatedVideosSelector: '.related-videos-list', //TODO: fix this selector.  no markup exists with this class anymore.
    syncAdSelector: '#bigbox',
    videoMetaDataSelector: '.video-meta-data',
    videoDataSelector: '.video-data',
    videoDataTitleSelector: '.infoTitle',
    videoInfoSelector: '.video-info',
    socialSharingSelector: '.video-social-sharing-space',
    carouselVideoMetaDataSelector: '.video-metadata',
    processVideoMetadataSelector: '#video-gallery #video-meta-data',
    isSingleVideo: true,
    hideEndCard: false,
    updateTitle: false,
    scrollToVideo: false
  };
  var config = Object.assign({}, defaults, context.getConfig());
  var $element = $(context.getElement());

  /**
   * When the modal is opened, we wait for a second and if the player already exists we will try to play the video that the launcher set
   * this is used in the use case that the player already exists and it just got re-shows on the page. We would rather not use the timeout
   * but we do not have an event we can tie into. There is no "player just got shown" event. So we wait for the overlay to open and then just
   * a touch more to make sure the player is visually happy
   *
   * when we hide the modal, the player is still around. Go ahead and pause it, but leave it and do not destroy it. Still needs to be there
   * if the user tries to open the overlay again
   */
  var messageHandlers = {
    'modal.hidden': function modalHidden(_ref) {
      var modal = _ref.modal;

      if (modal.$container.attr('id') === 'video-gallery') {
        debug.log('modal is hidden, pausing video');
        player.pause();
        player.$container.detach();
        debug.log('Player being detached because of modal.hidden');
      }
    }

  }; //end messageHandlers

  /**
   * function: bindVideoPlayerPlaylist()
   *
   * When user clicks on an item in 'videos in this playlist' module, play the respective video ...
   */
  function bindVideoPlayerPlaylist() {

    $(config.playlistItemSelector).bind('click tap', function (e) {

      e.preventDefault();

      if (config.scrollToVideo) {
        if ($('#video-gallery').length > 0) {
          $('#video-gallery').animate({ scrollTop: 0 }, 500);
        } else {
          var mobileOffset = deviceType.isMobile ? sharebar.getHeight() : 0;
          $('html, body').animate({
            scrollTop: $('#' + containerId).offset().top - mobileOffset
          }, 500);
        }
      }

      var $playlistSelector = $(this);

      debug.log('bindVideoPlayerPlaylist() $playlistSelector', $playlistSelector);

      var activeVid = parseInt($playlistSelector.attr('data-vid-num')); // + === parseInt;

      //play user clicked video
      player.play(activeVid);

      updateVideoMetadata(player.currentVideoIdx);
    });
  }

  /**
   * function: pickupSeenVideosFromLS()
   *
   * pick up any seen videos from sessionStorage. If there is no, we assume we dont have any
   */
  function handleSeenVideos() {
    var endframe = config.endframe,
        $related = $(config.relatedVideosSelector),
        $getRelatedVid = function $getRelatedVid(url) {
      return $related.children('[data-release-url="' + url + '"]');
    },
        seenVideos = void 0;

    if (!check.supports('sessionStorage')) {
      seenVideos = [];
    } else {
      seenVideos = sessionStorage.getItem('seenVideos');

      if (seenVideos) {
        seenVideos = sessionStorage.getItem('seenVideos').split('|');
      } else {
        seenVideos = [];
      }
    }

    endframe = endframe && endframe.assets && endframe.assets.length ? endframe : false;

    if (endframe) {
      for (var _video in seenVideos) {
        for (var i = 0; i < endframe.assets.length; i++) {
          if (endframe.assets[i].releaseUrl === seenVideos[_video]) {
            if ($related.children(':visible').length > 3) {
              /** remove seen videos from UI, unless we have less than 3 in the list */
              $getRelatedVid(endframe.assets[i].releaseUrl).remove();
            }
            endframe.assets.splice(i, 1); /** remove seen video from json */
          }
        }
      }
      //ensure the video that will be played next is first in the related videos list
      if (endframe.assets.length > 0 && endframe.assets[0].releaseUrl) {
        $getRelatedVid(endframe.assets[0].releaseUrl).prependTo($related);
      }
    }

    // show the related videos now
    $related.show();

    if (endframe) {
      config.endframe = endframe;
    }

    /** When video ends, add video URL to Array of seen videos */
    SNI.Video.Events.addEventListener('OnMediaEnd', function (ev) {

      /** do not add repeats */
      if (seenVideos.indexOf(player.currentVideo.releaseUrl) > -1) {
        return false;
      }

      seenVideos.push(player.currentVideo.releaseUrl);
      sessionStorage.setItem('seenVideos', seenVideos.join('|'));
    }, containerId);
  }

  function handleFreewheelAd() {

    var bigBoxEmbed = $(config.syncAdSelector); // related to advertisement for single video embed
    debug.log('handleFreewheelAd() bigBoxEmbed', bigBoxEmbed);

    if (bigBoxEmbed.length) {
      SNI.Video.Events.addEventListener('OnMediaStart', function (ev) {
        setTimeout(function () {
          bigBoxEmbed.css('max-height', '300px');
        }, 1000);
      }, containerId);
    }
  }

  function updateVideoPlaylistMetadata() {
    if (!config.isSingleVideo) {
      updateVideoMetadata(player.currentVideoIdx);
      /* process meta data */
      processVideoMetadata($(config.processVideoMetadataSelector).find(config.videoInfoSelector));
    }
  }

  /**
   * @function updateVideoMetadata()
   * @param    {int}
   *
   * Updated video metadata below player with correct video description. Part of metadata is the social sharing
   */
  function updateVideoMetadata(videoIndex) {

    var videoCount = $('.load-more-container li.block').length - 1;

    /** Show more videos if necessary */
    if (videoIndex > videoCount) {
      $('.load-more > button').trigger('click');
    }

    var $videoModal = $('#video-gallery'),
        $newVideoMetadataRoot = void 0,
        $currentVideoMetadata = void 0,
        $newMetadata = void 0,
        videoUrl = void 0;

    var $socialSharingSpace = void 0;

    // if we are in a video modal, we will get our new meta data from inside of it, otherwise, just grab it from the main content area
    if ($videoModal.length) {
      $newVideoMetadataRoot = $videoModal.find(config.playlistItemSelector);
      $currentVideoMetadata = $videoModal.find('.m-VideoMeta');
      $socialSharingSpace = $videoModal.find(config.socialSharingSelector);
    } else {
      $newVideoMetadataRoot = $(config.playlistItemSelector);
      $currentVideoMetadata = $(config.videoMetaDataSelector + ' ' + config.videoDataSelector);
      $socialSharingSpace = $(config.videoMetaDataSelector + ' ' + config.socialSharingSelector);
    }

    // bail out if metadata already reflects selected video:
    var newVidId = $newVideoMetadataRoot.eq(videoIndex).find(config.carouselVideoMetaDataSelector).attr('data-video-id');
    if ($currentVideoMetadata.attr('data-video-id') === newVidId) {
      debug.log('not updating video metadata', newVidId);
      return;
    } else {
      debug.log('updating video metadata', newVidId);
      $currentVideoMetadata.attr('data-video-id', newVidId);
    }
    // gather the new meta data we need
    $newMetadata = $newVideoMetadataRoot.removeClass('active').eq(videoIndex).addClass('active').find(config.carouselVideoMetaDataSelector).clone();

    if (config.updateTitle) {
      var infoTitleHtml = $newMetadata.find(config.videoDataTitleSelector).contents();
      $(config.updateTitle).html(infoTitleHtml);
    }

    // drop it into the current video metadata container
    $currentVideoMetadata.html($newMetadata.html());

    // sometimes the video URL is absolute vs relative
    videoUrl = $newMetadata.find('meta[itemprop="videoUrl"]').attr('content');
    if (videoUrl.indexOf('http') === -1) {
      videoUrl = 'http://' + window.location.hostname + videoUrl;
    }

    // setup share values from the new metadata and drop in the social sharing component
    var shareValues = {
      description: $newMetadata.find('p.caption').text(),
      title: $newMetadata.find('h1.name span').text(),
      url: videoUrl,
      image: 'http://' + window.location.hostname + $newMetadata.find('meta[itemprop="thumbnailUrl"]').attr('content')
    };

    if ($socialSharingSpace.length) {
      context.broadcast('socialShare.requested', {
        target: $socialSharingSpace,
        data: shareValues,
        source: true
      });
    }

    $.event.trigger({ type: 'update.metadata' });
    context.broadcast('update.metadata');
  }

  /**
   * Parses the 'data-mdm' meta off the current slide
   * then hands it over as JSON to the metadata manager util
   * @$slide: Needs a jQuery(wrapped) slide element
   */
  function processVideoMetadata($slide) {
    /* the [0] is necessary as slide data mdm is in an array */
    var mdmData = $slide.data('mdm') || false,
        $overlay = $('#video-gallery');

    if (check.exists('mdManager')) {
      mdManager.setParameter('CurrentRoom', player.currentVideo.title);
    }

    debug.log('processVideoMetadata() mdmData', mdmData);

    if (mdmData) {
      metadata.updateFromString(mdmData);
    } else {
      debug.log('MDM data missing');
    }

    if ($overlay.length && !$overlay.data('launched')) {
      $overlay.data('launched', true);
      analytics.callDynamicPageview();
    }
  }

  function skipToVideo(hashTag) {
    var videoNumber = void 0;
    var queryStart = hashTag.indexOf('?');

    if (queryStart > -1) {
      hashTag = hashTag.slice(0, queryStart);
    }

    if (hashTag.indexOf('#video-') > -1) {
      videoNumber = hashTag.replace('#video-', '');
    }
    if (hashTag.indexOf('#item-') > -1) {
      videoNumber = hashTag.replace('#item-', '');
    }

    // call function that determines if hash tag value is
    // the video number or the psaid
    videoNumber = getVideoNumber(videoNumber);

    if (videoNumber > 0) {
      videoNumber = videoNumber - 1;
      player.play(videoNumber, false);
    }
    updateVideoPlaylistMetadata();
  }

  function getVideoNumber(psaidOrVideoNumber) {
    var $videoPlaylist = void 0,
        videoNumber = void 0;

    // gather the playlist from the page
    // it contains each video in the list
    // with the psaid and video number for each
    $videoPlaylist = $(config.playlistItemSelector);

    // as long as the playlist isn't blank check to see if the number
    // passed in matches any of the psaids in the playlist
    // if it does match, grab the corresponding number in the list
    if ($videoPlaylist.length > 0) {
      videoNumber = $videoPlaylist.addBack().find('li[data-vid-psaid="' + psaidOrVideoNumber + '"], div[data-vid-psaid="' + psaidOrVideoNumber + '"]').attr('data-vid-num');
    }

    // if the video number was not found
    // assum the value passed in is the video number
    if (!videoNumber) {
      videoNumber = psaidOrVideoNumber;
    } else {
      // the video number stored in the playlist is actually
      // the index, so add one to that number to make sure
      // the correct video plays
      videoNumber = parseInt(videoNumber, 10) + 1;
    }

    return videoNumber;
  }

  return {

    behaviors: ['social-share'],

    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    },


    /**
     * function: init()
     */
    init: function init() {

      if (!config.isSingleVideo) {
        updateVideoMetadata(0);
      }

      if (window.location.search.match(/[?|&]novideo(&|$)/)) {
        debug.warn('Video player disabled by query string param');
        return;
      }

      // we are ready for more than one video player on the page. Currently the video player does not support it
      // but we will leave this code in here
      // grab the settings from what the JSP dropped and check for any overrides
      var videoUrlHash = location.hash;
      containerId = config.player.containerId;

      // setup the hideEndCard and isSingleVideo settings. These have to be here
      // as we have to parse body classes and also check stuff out of JSP data attributes
      // if the player is embedded it uses the same JSP as a single video page
      // if its in an overlay, different JSP so this setting is false
      if (config.embeddedPlayer) {
        if ($('.singleVideoPageOneColumn').length === 0) {
          config.hideEndCard = true;
          config.isSingleVideo = false;
        }
      } else {
        config.isSingleVideo = false;
      }

      // if we are supposed to hide the end doooo it.
      if (config.hideEndCard) {
        config.embed = { 'enabled': false };
      }

      // pick up videos from sessionStorage and setup events to parse through related videos but only if we are on single video
      if (config.isSingleVideo) {
        // FIXME: shouldn't be passed the module element, but the video-playlist-container
        handleSeenVideos($element);
      }

      // there is the possibility that we will run through this multiple times during a page. Right now the player breaks
      // if we try to instantiate more than one. The biggest use case for this right now is if a user keeps on closing and
      // reopening the overlay.
      // The video module will get inited again, but the player already exists.
      // Update: this was a problem for 1.1, but the 1.4 Universal Player handles this just fine.
      // Please read https://sni-digital.atlassian.net/wiki/display/VPC/Working+with+the+player+in+a+Modal

      if (config.player.containerId in SNI.Video.Players) {
        player = SNI.Video.Players[config.player.containerId];
        $element.find('[data-videoplayer-container]').remove();
        $element.append(player.$container);
      }

      // only re-init the video if the video player doesn't exist or if the video player doesn't match the element's ID
      config.freewheel = {
        enabled: !window.location.href.match(/[?|&]nopreroll/)
      };
      //point freewheel to the correct slot
      if (config.syncAdSelector) {
        config.freewheel.adContainerId = modUtil.getIdFromSelector(config.syncAdSelector);
      }

      if (player) {
        setTimeout(function () {
          player.play(video.getNext());
        }, 1000);
      } else {
        if (config.channels && config.channels[0]) {
          config.channels[0].start = video.getNext() || config.channels[0].start;
        }
        player = new SNI.Video.Player(config);
      }
      debug.log('player: ', player);

      handleFreewheelAd();

      SNI.Video.Events.addEventListener('OnMediaStart', updateVideoPlaylistMetadata, containerId);

      if (mdManager.getParameterString('type') === 'fullwidthpage') {
        var close = $element.closest('.o-Modal').find('.o-Modal__a-Button--Close').detach();
        $element.closest('.o-VideoPlaylistEmbed').prepend(close);
      }

      player.subscribe('PlayerReady', function () {
        // looks for has in the url ex: #video-4
        if (videoUrlHash !== undefined) {
          skipToVideo(location.hash);
        }
        $('[data-hidden-until-video-play]').removeClass('is-Hidden');
      });

      bindVideoPlayerPlaylist();
    },
    destroy: function destroy() {}
  };
});

/***/ }),
/* 389 */
/***/ (function(module, exports) {

/**
 * simple "view more" functionality: reveal hidden content on click
 *   data-type='control-view-more'  clicked user control 
 *   data-type='content-view-more'  revealed content, assumed initially syled with display: none
 * 
 */

SNI.Application.addModule('view-more', function (context) {

  var $element = $(context.getElement());

  function handleClick(evt, elt, eltType) {
    if (eltType === 'control-view-more') {
      $element.find('[data-type="content-view-more"]').show();
      $(elt).hide();
      evt.preventDefault();
    }
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {

    // init,

    onclick: handleClick

  };
});

/***/ }),
/* 390 */
/***/ (function(module, exports) {

SNI.Application.addModule('vine-embed', function (context) {

  var debug = context.getService('logger').create('module.vine-embed');

  var module = void 0,
      element = void 0,
      defaults = void 0,
      instance = void 0,
      config = void 0;

  defaults = {
    jsURL: '//platform.vine.co/static/scripts/embed.js',
    embedURL: 'https://vine.co/oembed.json',
    embedName: 'vine'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setEmbedConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function loadEmbed() {
    var url = config.apiPath,
        vineFormat = config.format || 'simple',
        dimension = void 0;

    if (typeof url !== 'undefined' && typeof vineFormat !== 'undefined') {
      dimension = element.outerWidth();
      url = url + '/embed/' + vineFormat;
      element.html('<iframe src="' + url + '" width="' + dimension + '" height="' + dimension + '" frameborder="0"></iframe>');
    } else {
      debug.warn('loadEmbed: invalid embed parameters: unable to load vine embed!');
    }
  }

  module = {
    init: function init() {
      setEmbedConfig(defaults, context.getConfig());
      element = $(context.getElement());
      instance = element.attr('id');
      loadEmbed();
      $(window).off('resize.vine.' + instance).on('resize.vine.' + instance, function () {
        element.find('iframe').attr('width', element.outerWidth());
        element.find('iframe').attr('height', element.outerWidth());
      });
    },


    updateObject: updateObject,
    setEmbedConfig: setEmbedConfig
  };

  return module;
});

/***/ }),
/* 391 */
/***/ (function(module, exports) {

SNI.Application.addModule('vote', function (context) {

  var $voteElements = void 0,
      $element = $(context.getElement()),
      debug = context.getService('logger').create('module.vote'),
      check = context.getService('check').new(debug),
      device = context.getService('device-type'),
      mdManager = context.getGlobal('mdManager'),
      gigya = check.exists('gigya.socialize') ? context.getGlobal('gigya') : false,
      analytics = context.getService('analytics'),
      template = context.getService('template'),
      loadingHTML = template.loadingHTML(),
      modalVote = context.getService('modal'),
      metadata = context.getService('metadata'),
      voteError = false,
      voteModuleSel = '[data-vote-module]',
      voteLabelSel = '[data-vote-voted-label]',
      afterVoteHideSel = '[data-vote-hide-after]',
      initialHideSel = '[data-vote-hide-on-initial]',
      resourceLabelSel = '[data-vote-resource-label]',
      voteElementSel = '[data-vote-gallery-thumb]',
      voteButtonSel = '[data-vote-cast-button]',
      voteHideSel = '[data-vote-hide-whilst]',
      viewPhotoSel = '[data-vote-view-photos-link]',
      voteInstructSel = '[data-vote-instruction-copy]',
      ssQueueSel = '.slideshow-queue',
      loadingCls = 'loading',
      hiddenCls = 'is-Hidden',
      shownCls = 'is-Shown',
      subNavSel = '.o-SubNavigation',
      voteGridSel = '.l-Columns';

  var defaults = {
    voteType: 'gallery',
    cid: '',
    barId: '',
    voteIndex: 0,
    nextCategoryUrl: '',
    baseVoteUrl: '',
    sweepsTitle: '',
    sweepsUrl: '',
    totalVoteElements: 0,
    numVoteElementsLoaded: 0,
    currentIndex: '',
    previousIndex: '',
    freshVote: '',
    voteReactions: [],
    elementsLoaded: false,
    ballotState: false
  };

  var settings = Object.assign({}, defaults, context.getConfig());

  function toggleStateClass(state) {
    var $el = $(voteModuleSel);
    var classes = $el[0].className.split(' ');
    var newClasses = [];
    for (var i = 0; i < classes.length; i++) {
      var cls = classes[i].trim();
      if (cls.substring(0, 3) !== 'is-') {
        newClasses.push(cls);
      }
    }
    $el[0].className = newClasses.join(' ');
    $el.addClass('is-' + state.charAt(0).toUpperCase() + state.slice(1));
  }

  function getColumnsClass(count) {
    return 'l-Columns--' + count.toString() + 'up';
  }

  function fetchSlideshowQueue() {
    $(voteElementSel).each(function () {
      var slideshowUrl, countOfHTML, lastHTML, $voteBlock;

      if ($(this).data('slideshowUrl') === '') {
        debug.log('No SLIDESHOW URL specified, cannot AJAX');
        return false;
      }

      $(this).find(voteElementSel).prepend(loadingHTML);
      slideshowUrl = $(this).data('slideshowUrl');
      countOfHTML = slideshowUrl.match(/.html/g) || 0;

      //if on mobile author
      if (device.isMobile && check.isAuthor()) {
        slideshowUrl = slideshowUrl.replace(/\.slideshow\.html/, '.mobile.slideshow.html');
      }

      if (countOfHTML.length > 1) {
        lastHTML = slideshowUrl.lastIndexOf('.html');
        slideshowUrl = slideshowUrl.substring(0, lastHTML);
      }

      if (check.isLocalhost() || check.isAuthor()) {
        slideshowUrl += '?wcmmode=disabled';
      }

      $voteBlock = $(this);
      $.get(slideshowUrl, function (data) {
        var $queue = $('<div>').append(data);
        appendSlideshowQueue($queue, $voteBlock);
      }).done(function (data) {
        $voteBlock.find(ssQueueSel).attr('data-vote-index', $voteBlock.data('voteIndex'));
        $voteBlock.removeClass(loadingCls);
        $voteBlock.find('[data-ui-loader]').remove();
        settings.numVoteElementsLoaded++;
        if (settings.numVoteElementsLoaded === settings.totalVoteElements) {
          context.broadcast('vote.elementsLoaded', {
            items: $voteElements
          });
        }
      });
    });
  }

  function appendSlideshowQueue($slideshowQueue, $voteElement) {
    $voteElement.append($slideshowQueue.html());
  }

  function preventVoteClick() {
    $(voteElementSel).each(function () {
      var $currBlock = $(this);
      $currBlock.find('a').on('click', function (e) {
        if ($(this).hasClass(loadingCls)) {
          e.preventDefault();
        }
      });
    });
  }

  //wat? need data- attribs instead of tags
  function setColor() {
    $(voteInstructSel).find('b, strong').css('color', $(subNavSel).css('background-color'));
  }

  function preventGalleryLaunch() {
    $voteElements.each(function () {
      var $currVoteElement = $(this),
          $currVoteImage = $(this).find(voteElementSel),
          $viewLink = $(this).find(viewPhotoSel);
      $currVoteImage.on('click.vote', function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).find(voteButtonSel).trigger('click.vote');
      });
      debug.log($viewLink, $currVoteElement);
    });
  }

  function titleGalleryLaunch() {
    $voteElements.each(function () {
      var $currVoteElement = $(this),
          $galleryTitleLink = $currVoteElement.find('[data-vote-gallery-title]');
      debug.log($galleryTitleLink);
    });
  }

  function removeVote() {
    $voteElements.each(function () {
      var $currVoteImage = $(this).find(voteElementSel),
          $viewLink = $(this).find(viewPhotoSel);
      $currVoteImage.off('click.vote');
      $viewLink.off('click.vote').hide();
    });
  }

  function setupVote() {
    preventGalleryLaunch();

    if (!gigya) {
      debug.error('Cannot properly setup vote since gigya is not defined.');
    }

    $(voteButtonSel).each(function () {
      $(this).on('click.vote', function (e) {
        e.preventDefault();
        e.stopPropagation();
        var $currentElement = $(this).parents(voteElementSel),
            currentButton = $currentElement.data('galleryTitle'),
            largeImage = $currentElement.find('[data-vote-gallery-launch] img').attr('data-large-rendition'),
            currentImage = $currentElement.find('[data-vote-gallery-launch] img').attr('src');

        if (gigya) {
          gigya.socialize.incrementReactionsCount({
            barID: settings.barId,
            buttonID: currentButton,
            cid: settings.cid,
            count: 1
          });

          gigya.socialize.getReactionsCount({
            barID: settings.barId,
            callback: printReactions
          });
        }

        if (!voteError) {
          context.broadcast('vote.voted', {
            galTitle: currentButton,
            galImage: currentImage,
            largeImage: largeImage
          });
        } else {
          errorModal();
        }
      });

      var galleryID = $(this).parents(voteElementSel).data('galleryTitle');
      galleryID = galleryID.replace(/,/g, '');

      var reactionObj = {
        text: galleryID,
        ID: galleryID
      };

      settings.voteReactions.push(reactionObj);
    });
    if (gigya) {
      var voteAction = new gigya.socialize.UserAction();
      voteAction.setTitle('I voted for stuff!');
      voteAction.setLinkBack('//' + window.location.hostname);

      gigya.socialize.showReactionsBarUI({
        barID: settings.barId,
        containerID: 'reactionBarWrapper',
        reactions: settings.voteReactions,
        userAction: voteAction,
        showCounts: 'top',
        noButtonBorders: true,
        cancelReactions: false,
        multipleReactions: false,
        promptShare: false,
        cid: settings.cid
      });
    }
  }

  function printReactions(response) {
    if (response.errorCode === 0) {
      var myCounts = response.counts;
      if (null !== myCounts && myCounts.length > 0) {
        //sweet Yoda conditional
        var msg = 'Reaction Counts: \n';
        for (var index in myCounts) {
          msg += myCounts[index].buttonId + ': ' + myCounts[index].count + '\n';
        }
        debug.log('printReactions: ', msg);
      } else {
        debug.log('printReactions: No Counts were returned');
      }
    } else {
      debug.log('printReactions: Error :', response.errorMessage);
      voteError = true;
    }
  }

  function hideElements(hideIt, group) {
    $(group).each(function () {
      $(this).removeClass(hiddenCls + ' ' + shownCls).addClass(hideIt ? hiddenCls : shownCls);
    });
  }

  function transform(newLayout, oldLayout) {
    $(voteGridSel).addClass(newLayout).removeClass(oldLayout);
  }

  function errorModal() {
    var id = 'vote-modal-error',
        eM = new modalVote.create({ modalId: id }),
        errorContent;

    errorContent = {
      modalId: id,
      body: 'We experienced a technical glitch and we\'re very sorry about that. Please close this message and try again.',
      heading: 'Sorry, your vote was not cast.',
      actionText: 'Close & Try Again'
    };

    eM.loadContent(errorContent);
    eM.show();

    $('#' + id + ' [data-button-primary]').off().on('click', function () {
      eM.hide();
    });
  }

  function votingModal(data) {
    var id = 'vote-modal',
        m = new modalVote.create({ modalId: id });

    m.loadContent({
      modalId: id,
      body: {
        html: template.voteResultModalBody({
          mobile: device.isMobile,
          title: data.galTitle,
          image: device.isMobile ? data.largeImage : data.galImage
        })
      },
      header: {
        title: 'Got It, Thanks!',
        subtitle: 'Be sure to come back and vote again tomorrow.'
      },
      footer: {
        actionText: settings.nextCategoryUrl ? 'Continue to Next Category' : 'Close',
        cancelText: settings.sweepsTitle ? 'Enter our ' + settings.sweepsTitle : ''
      }
    });
    m.show();

    addSocialShare(data, { mobileIcons: true, shareSource: 'ogDataTags' }, $('#' + id + ' [vote-share-container]'));

    if (!settings.nextCategoryUrl) {
      $('#' + id + ' [data-button-primary]').off().on('click', function () {
        m.hide();
      });
    }

    $('[data-modal-footer] [data-button-primary]').on('click.nextCategory', function (e) {
      if (settings.nextCategoryUrl) {
        e.preventDefault();
        window.location.href = settings.nextCategoryUrl;
      }
    });

    if (!settings.sweepsUrl) {
      $('[data-modal-footer] span').remove();
    } else {
      $('[data-modal-footer] [data-button-secondary]').on('click.sweeps', function (e) {
        e.preventDefault();
        e.stopPropagation();
        window.location.href = settings.sweepsUrl;
      });
    }
  }

  function retrieveSocialDataFromGallery(data) {
    var galleryURL = window.location.href,
        siteURL = galleryURL.replace(/https?:\/\//i, ''),
        slideImage = data.galImage,
        hubText = settings.cid ? ' in ' + settings.cid : '',
        pageTitle = mdManager.getParameterString('Title');

    function toTitleCase(str) {
      return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    }

    pageTitle = toTitleCase(pageTitle);

    var shareValues = {
      title: 'I voted for ' + data.galTitle + hubText,
      description: 'Visit ' + siteURL + ' to vote for your favorite ' + pageTitle,
      url: galleryURL,
      image: slideImage
    };

    return shareValues;
  }

  function addSocialShare(data, config, $shareContainer) {
    context.broadcast('socialShare.requested', {
      target: $shareContainer,
      data: retrieveSocialDataFromGallery(data),
      config: config
    });
  }

  function searchJSONArray(arr, key, val) {
    var $jsonArray = arr;

    for (var i = 0; i < $jsonArray.length; i++) {
      if ($jsonArray[i][key] === val) {
        return $jsonArray[i];
      }
    }

    return false;
  }

  function checkStorage() {
    var ls = localStorage.getItem('votes'),
        votes = ls ? JSON.parse(ls) : null,
        dupVote = ls ? searchJSONArray(votes, 'voteURL', window.location.href.split('?')[0]) : false;

    debug.log('dupVote', dupVote);

    if (check.supports('localStorage')) {
      var now = new Date().getTime(),
          voteTime = localStorage.getItem('voteTime');
      if (voteTime === null) {
        settings.freshVote = true;
        debug.log('checkStorage: freshVote');
      } else if (voteTime - now > 0 && votes !== null && dupVote) {
        settings.freshVote = false;
        debug.log('checkStorage: oldVote');
        context.broadcast('vote.voted');
      } else if (voteTime - now <= 0) {
        debug.log('checkStorage: resetVote');
        localStorage.removeItem('voteTime');
        localStorage.removeItem('voteState');
        localStorage.removeItem('votes');
      }
    } else {
      debug.log('checkStorage: no localstorage, exiting');
    }
  }

  function getPathFromUrl(url) {
    return url.split('?')[0];
  }

  function setStorage(data) {
    if (check.supports('localStorage')) {
      var midnight = new Date().setHours(23, 59, 59, 999),
          state = 'vote.voted',
          voteData = {},
          votes = localStorage.getItem('votes') ? JSON.parse(localStorage.getItem('votes')) : [],
          currUrl = window.location.href;

      currUrl = getPathFromUrl(currUrl);

      localStorage.setItem('voteTime', midnight);
      localStorage.setItem('voteState', state);
      voteData.votedGallery = data.galTitle;
      voteData.voteURL = currUrl;
      debug.log('setStorage: votes: ', votes);
      votes.push(voteData);
      debug.log('setStorage: votes: ', votes);
      localStorage.setItem('votes', JSON.stringify(votes));
    } else {
      debug.log('checkStorage: no localstorage, exiting');
    }
  }

  function setItem(key, val) {
    if (check.supports('localStorage')) {
      localStorage.setItem(key, val);
    }
  }

  function disableLoop() {
    if (check.supports('localStorage')) {
      localStorage.setItem('voteLoop', false);
    } else {
      debug.log('checkStorage: no localstorage, exiting');
    }
  }

  function showVotedLabel() {
    var votes = localStorage.getItem('votes'),
        voteObj = votes ? searchJSONArray(JSON.parse(votes), 'voteURL', window.location.href.split('?')[0]) : false,
        galleryText = votes && voteObj && voteObj.votedGallery ? voteObj.votedGallery : '';

    $(voteLabelSel).addClass(hiddenCls).remove(shownCls);

    if (galleryText.length) {
      $(voteModuleSel + ' [data-gallery-title="' + galleryText + '"] ' + voteLabelSel).removeClass(hiddenCls).addClass(shownCls);
    }
  }

  function removeBorder(border, type) {
    $(voteGridSel).css(border, type);
  }

  function elementsLoaded() {
    setItem('loadedState', 'vote.elementsLoaded');
    setColor();
    titleGalleryLaunch();
  }

  function startBallot() {
    if (!device.isMobile) {
      transform(getColumnsClass(3), getColumnsClass(2));
    }
    setItem('loadedState', 'vote.ballotState');
    setupVote();
    toggleStateClass('voteEnabled');
    hideElements(false, initialHideSel);
    hideElements(true, voteHideSel);
    $(viewPhotoSel).show();
    metadata.updateFromString(JSON.stringify({ Type: 'ballotPage', UniqueID: mdManager.getParameterString('UniqueID').replace(/voteOverlay/g, 'ballotPage'), Url: settings.baseVoteUrl }));
    // analytics.setProp(9, analytics.getProp(9).replace(/voteOverlay/g, 'ballotPage'));
    analytics.callDynamicPageview();
    analytics.setProp(9, '');
    analytics.setProp(10, '');
    debug.log('startBallot: Type: ', mdManager.getParameterString('Type'));
    setTimeout(function () {
      $(window).scrollTop($(voteInstructSel + ':first').offset().top);
    }, 100);
  }

  function registerVote(data) {
    debug.log('registerVote: votedState entered');
    setItem('loadedState', 'vote.voted');
    localStorage.setItem('voteLoop', true);
    transform(getColumnsClass(2), getColumnsClass(3));
    hideElements(false, voteHideSel);
    hideElements(true, afterVoteHideSel);
    hideElements(true, resourceLabelSel);
    toggleStateClass('voted');
    if (data) {
      votingModal(data);
      setStorage(data);
    }
    removeVote();
    showVotedLabel();
    removeBorder('border-top', 'none');
  }

  function hiddenState() {
    var currentState = 'votePage',
        stateObject = {};
    if (localStorage.getItem('loadedState') === 'vote.elementsLoaded') {
      currentState = 'votePage';
    } else if (localStorage.getItem('loadedState') === 'vote.ballotState') {
      currentState = 'ballotPage';
    }
    stateObject.Type = currentState;
    metadata.updateFromString(JSON.stringify(stateObject));
    mdManager.setParameter('Url', settings.baseVoteUrl);
    setTimeout(function () {
      $(window).scrollTop($(voteGridSel).offset().top);
    }, 100);
  }

  return {
    messages: ['galleryModal.closed', 'vote.elementsLoaded', 'vote.ballotState', 'vote.voted', 'modal.hidden'],
    init: function init() {
      var $modules = $('[data-module="' + $element.attr('data-module') + '"]');
      if ($modules.length > 1 && !$element.is($modules.eq(0))) {
        debug.log('init: Only one vote module per page allowed, exiting');
        return;
      }

      settings.cid = $element.data('cid');
      settings.barId = $element.data('barId');
      settings.nextCategoryUrl = $element.data('nextCategory');
      settings.sweepsTitle = $element.data('sweepstakes-title');
      settings.sweepsUrl = $element.data('sweepstakes-url');
      settings.baseVoteUrl = check.exists('mdManager') ? mdManager.getParameterString('Url') : window.location.href.split('?')[0];
      debug.log('init: sweeps {}: ', settings.sweepsTitle, settings.sweepsUrl);

      $voteElements = $element.find(voteElementSel);
      settings.totalVoteElements = $(voteElementSel).length;

      preventVoteClick($voteElements);

      fetchSlideshowQueue();
      disableLoop();
      checkStorage();
      hideElements(true, initialHideSel);
    },

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'galleryModal.closed':
          break;
        case 'vote.elementsLoaded':
          if (!settings.elementsLoaded) {
            settings.elementsLoaded = true;
            elementsLoaded();
          }
          break;
        case 'vote.ballotState':
          if (!settings.ballotState) {
            settings.ballotState = true;
            startBallot();
          }
          break;
        case 'vote.voted':
          registerVote(data);
          break;
        case 'modal.hidden':
          hiddenState();
          break;
      }
    }
  };
});

/***/ }),
/* 392 */
/***/ (function(module, exports) {

SNI.Application.addModule('we-recommend', function (context) {

  return {
    behaviors: ['lazy-load']
  };
});

/***/ }),
/* 393 */
/***/ (function(module, exports) {

/**
 * @fileoverview Affix Behavior
 * @author Jonathan Kemp
 */

/*
 * Sticks a specified element to the top of the browser window on scroll.
 */
SNI.Application.addBehavior('affix', function (context) {
  'use strict';

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var SniAds = context.getGlobal('SniAds');
  var element = context.getElement();
  var defaults = {
    endAffix: '.directions',
    affixClass: 'affix',
    fadeOutClass: 'fadeOutUp',
    fadeInClass: 'fadeInDown',
    animatedClass: 'animated',
    leaderboardSelector: 'dfp_leaderboard',
    pushdownSelector: 'dfp_pushdown_brandscape'
  };
  var config = Object.assign({}, defaults, context.getConfig());
  var deviceType = context.getService('device-type');
  var debug = context.getService('logger').create('behavior.affix');
  var check = context.getService('check').new(debug);
  var isMobile = deviceType.isMobile;

  var $stickElement = void 0,
      startStickHeight = void 0,
      $stopElement = void 0,
      stopHeight = void 0,
      stopDistance = void 0,
      pauseStickElement = void 0,
      down = false;

  function maintainHeight() {
    if (!$stickElement.data('heightMaintainer')) {
      var $heightMaintainer = $('<div data-affix-behavior-height-maintainer />').height($stickElement.outerHeight(true));
      $stickElement.wrap($heightMaintainer).data('heightMaintainer', $heightMaintainer);
    }
  }
  function cleanupHeight() {
    if ($stickElement.data('heightMaintainer')) {
      $stickElement.unwrap('[data-affix-behavior-height-maintainer]').removeData('heightMaintainer');
    }
  }

  /**
   * Stick and unstick the specified element. The element should fade out/in at a specified point.
   */
  function makeItStick() {
    var $document = $(document);
    var affixClass = config.affixClass;

    // Stick element
    if ($document.scrollTop() >= startStickHeight) {
      $stickElement.addClass(affixClass);
    }

    // unstick element
    if ($document.scrollTop() <= startStickHeight) {
      $stickElement.removeClass(affixClass);
    }

    // fade out pre-next buttons
    if (pauseStickElement - $document.scrollTop() < 0) {
      $stickElement.removeClass(config.fadeInClass).addClass(config.fadeOutClass);

      down = true;
    }

    // fade back in pre-next buttons
    if (pauseStickElement - $document.scrollTop() > 0) {
      // this flag is set after element fades in bottom so fadeInDown only happens on the way up and not on DOM load
      if (down) {
        $stickElement.removeClass(config.fadeOutClass).addClass(config.fadeInClass);
      }
    }
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    init: function init() {
      $stickElement = $(element);
      debug.log('$stickElement: ', $stickElement);
      startStickHeight = $stickElement.offset().top;
      debug.log('startStickHeight: ', startStickHeight);
      $stopElement = $(config.endAffix);

      if ($stopElement.length) {
        stopHeight = $stopElement.height();
        stopDistance = $stopElement.offset().top;
        pauseStickElement = stopDistance + stopHeight;
      }

      if (check.exists('SniAds.Event')) {
        if (!isMobile) {
          SniAds.Event.subscribe('slotRenderComplete', function (slot) {
            // if ad unit exist add height to the start of the sticky spot
            if (slot.slot.getSlotElementId().indexOf(config.leaderboardSelector) > -1 && !slot.isEmpty) {
              startStickHeight = startStickHeight + $('#' + config.leaderboardSelector).height();
              debug.log('startStickHeight: leaderboard rendered: ', startStickHeight, $('#' + config.leaderboardSelector).height());
            }

            if (slot.slot.getSlotElementId().indexOf(config.pushdownSelector) > -1 && !slot.isEmpty) {
              if ($('#' + config.pushdownSelector).height() <= 66) {
                startStickHeight = startStickHeight + 66;
              } else {
                startStickHeight = startStickHeight + $('#' + config.pushdownSelector).height();
                debug.log('startStickHeight: pushdown rendered: ', startStickHeight, $('#' + config.pushdownSelector).height());
              }
            }
          });
        }
      }

      $stickElement.addClass(config.animatedClass);
      maintainHeight();

      $(document).on('scroll', makeItStick);
    },
    destroy: function destroy() {
      $stickElement = null;
      startStickHeight = null;
      $stopElement = null;
      stopHeight = null;
      stopDistance = null;
      pauseStickElement = null;

      cleanupHeight();
      $(document).off('scroll', makeItStick);
    },


    makeItStick: makeItStick
  };
});

/***/ }),
/* 394 */
/***/ (function(module, exports) {

/**
 *
 * This behavior converts any http protocol to tel protocol for mobile,
 * thereby providing the ability to invoke the phone number for the dialer .
 *
 **/
SNI.Application.addBehavior('call-protocol', function (context) {

  var defaults = {
    phoneNumber: false
  };

  var element = context.getElement();
  var $element = $(element);

  var debug = context.getService('logger').create('behavior.call-protocol');
  var config = Object.assign({}, defaults, context.getConfig());

  function updateCallProtocol() {

    $element.find('[data-caller]').each(function () {

      var $this = $(this),
          callNumber = $this.attr('href'),
          callProtocol = void 0;

      if (callNumber) {
        callProtocol = callNumber.replace('http://', 'tel:');
        $this.attr('href', callProtocol);
      }
    });
  }

  return {

    config: config,

    init: function init() {
      debug.log('Call Protocol Convert: Init Start');
      updateCallProtocol();
    }
  };
});

/***/ }),
/* 395 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('collapse-empty-dynamic-slots', function (context) {
  var ads = context.getService('ads');

  return {
    init: function init() {
      ads.collapseSlots(ads.getDynamicSlots($(context.getElement()).parent()).map(function (slot) {
        return slot.id;
      }));
    }
  };
});

/***/ }),
/* 396 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('customer-service', function (context) {

  var mdManager = context.getGlobal('mdManager');
  var defaults = {
    basePath: '.custhelp.com/app/ask',
    currentProtocol: 'http://'
  };

  var config = Object.assign({}, defaults, context.getConfig('customerService'));
  var element = context.getElement();

  function constructCustomerServiceLink(currentSite) {
    var finalLink = void 0;
    switch (currentSite) {
      case 'hgtv':
        finalLink = '' + config.currentProtocol + currentSite + config.basePath;
        break;
      case 'diy':
        finalLink = '' + config.currentProtocol + currentSite + 'network' + config.basePath;
        break;
      case 'gac':
        finalLink = config.currentProtocol + 'gactv' + config.basePath;
        break;
      case 'travel':
        finalLink = '' + config.currentProtocol + currentSite + 'channel' + config.basePath;
        break;
      case 'food':
        finalLink = '' + config.currentProtocol + currentSite + 'network' + config.basePath;
        break;
      case 'cook':
        finalLink = '' + config.currentProtocol + currentSite + 'ingchanneltv' + config.basePath;
        break;
      default:
        finalLink = '' + config.currentProtocol + currentSite + config.basePath;
        break;
    }
    return finalLink;
  }

  function appendCustomerServiceLink(finalUrl, element) {
    var $element = $(element);
    $element.find('a:contains(\'Report This Listing\')').attr('href', finalUrl);
  }

  return {
    init: function init() {
      config.site = mdManager.getParameterString('site');
      appendCustomerServiceLink(constructCustomerServiceLink(config.site), element);
    },


    constructCustomerServiceLink: constructCustomerServiceLink,
    appendCustomerServiceLink: appendCustomerServiceLink
  };
});

/***/ }),
/* 397 */
/***/ (function(module, exports) {

/**
 *
 * This behavior converts any data-daferred-module attributes to data-module as it's initialized,
 * thereby providing the ability to defer starting a module until a later point.
 *
 **/
SNI.Application.addBehavior('deferred-loader', function (context) {

  var deferAttr = 'data-deferred-module';
  var debug = context.getService('logger').create('behaviors.deferred-loader');

  var element = context.getElement();
  var $element = $(element);

  return {
    init: function init() {

      $element.find('[' + deferAttr + ']').each(function (index, el) {
        var $el = $(el);

        debug.log($el.attr('data-module', $el.attr('' + deferAttr)).removeAttr('' + deferAttr));
      });
    }
  };
});

/***/ }),
/* 398 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('dropdown-menu', function (context) {
  var $element = $(context.getElement());
  var deviceType = context.getService('device-type');
  var debug = context.getService('logger').create('behavior.dropdown-menu');

  var defaults = {
    openClass: 'is-Open',
    openOnClick: deviceType.isMobile || deviceType.isTablet
  };

  var config = Object.assign({}, defaults, context.getConfig('dropdownMenu'));

  return {

    config: config,

    init: function init() {

      if (!config.openOnClick) {
        debug.warn('config.openOnClick is false, exiting.');
        return false;
      }
    },

    onclick: function onclick(event, element, elementType) {

      if (!config.openOnClick) return false;

      var $this = $(element);
      var dropdownmenu = '[data-type="dropdown-menu"]';
      var $items = $element.find('[data-type=sub-navigation-item]');
      var $openItem = function $openItem() {
        return $items.filter('.' + config.openClass);
      };

      function msg() {
        debug.log(($openItem().length ? 'opened' : 'closed') + ' dropdown in ' + $element.attr('id'));
      }

      if (elementType !== '') {
        if (!$this.hasClass(config.openClass) && $this.find(dropdownmenu).length) {
          event.preventDefault();
        }
        //if a top level item links to #, don't follow the link, and close any open menus
        if ($this.children('a[href="#"]').length) {
          event.preventDefault();
          if ($openItem().length) {
            $items.removeClass(config.openClass);
            msg();
            return false;
          }
        }
      }

      if (elementType === 'sub-navigation-item') {
        // close menu if the target of the click isn't the nav item nor a descendant of it
        $(document).off('mouseup.dropdown-menu').on('mouseup.dropdown-menu', function (e) {
          if (!$this.is(e.target) && $this.has(e.target).length === 0) {
            $this.removeClass(config.openClass);
            $(document).off('mouseup.dropdown-menu');
            msg();
          }
        });

        if (deviceType.isMobile && $this.find(dropdownmenu).length) {
          $this.toggleClass(config.openClass);
          msg();
        } else {
          debug.log('this is device tablet: ' + deviceType.isTablet);
          if ($this.find(dropdownmenu).length && !$this.hasClass(config.openClass)) {
            $this.addClass(config.openClass).siblings().removeClass(config.openClass);
            msg();
            return false;
          }
        }
      }
    }

  };
});

/***/ }),
/* 399 */
/***/ (function(module, exports) {

/**
* Login and logout Handler
* Handle log in / log out events for the header
* When the page loads, the gigya/login behavior will request the user's logged in state.  This behavior listens for the
* result and will display the logged in menu or the logged out menu.  It also handles nickname truncation requirement.
* The logged in event can also be triggered by the header menus and this behavior will listen for those events as well.
*/
SNI.Application.addBehavior('gigya/handle-login', function (context) {

  var debug = context.getService('logger').create('behavior.gigya.login'),
      element = context.getElement(),
      $element = $(element),
      moderation = context.getService('gigya/moderation'),
      tracking = context.getService('gigya/tracking');

  function getNickName(userData) {
    var nickname = void 0,
        tempNickName = void 0,
        profile = userData.profile,
        data = userData.data;

    tempNickName = data.temp && data.temp.profile && data.temp.profile.nickname || profile.nickname;

    if (typeof tempNickName === 'undefined' || !tempNickName || userData.newUser) {
      tempNickName = profile.email.split('@')[0];
    }

    nickname = tempNickName.slice(0, 10) + (tempNickName.length > 10 ? '...' : '');

    return { nickname: nickname, tempNickName: tempNickName }; // nickname is displayed to the user and may be truncated; tempNickName is the calculated nickname without truncation
  }

  var $loggedEles = [];

  function toggleLoggedVisuals(state) {
    var origKey = 'sni-old-display';
    var inAtt = 'data-logged-in';
    var outAtt = 'data-logged-out';
    if ($loggedEles.length === 0) {
      $loggedEles = $('[' + inAtt + '],[' + outAtt + ']').each(function () {
        $(this).data(origKey, $(this)[0].hasAttribute(inAtt) ? inAtt : outAtt);
      });
    }
    $loggedEles.each(function () {
      var orig = $(this).data(origKey);
      $(this).removeAttr(state ? inAtt : outAtt);
      if (!state && orig === inAtt || state && orig === outAtt) {
        $(this).attr(orig, false);
      }
    });
  }

  /** @buildState builds login or logout state in header
  * @param state: true = logged in || false = logged out
  * get gigyaData data
  * push data into template
  * attache to DOM
  */
  var buildState = function buildState(state, response) {
    var userInfo = { nickname: '', tempNickName: '' };
    if (!state) {
      debug.log('buildstate ran show logout state');
    } else {
      var $nickName = $element.find('[data-social-nickname]');
      userInfo = getNickName(response);

      if (userInfo.nickname) $nickName.text(userInfo.nickname);

      debug.log('buildstate ran show login state');
    }
    tracking.setLoginState({ state: state, nickname: userInfo.tempNickName, response: response });
    toggleLoggedVisuals(state);
  };

  /** @messageHandlers
  * messageHandlers are broacasted from other parts of the application
  * we are listening for them and acting on once we heard them
  */
  var messageHandlers = {
    'gigya.isloggedIn': function gigyaIsloggedIn(response) {
      if (response) {
        var newUser = response.newUser,
            source = response.source;

        var isRegistration = newUser && source === 'showScreenSet';
        if (isRegistration) {
          moderation.processRegistration(response);
        }
        tracking.setFirstVisitedTimeStamp(isRegistration, response);
      }
      buildState(true, response);
    },
    'gigya.isloggedOut': function gigyaIsloggedOut() {
      debug.log('Not logged in');
      buildState(false, {});
    }
  };

  return {
    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(message, data) {
      messageHandlers[message](data);
    }
  };
});

/***/ }),
/* 400 */
/***/ (function(module, exports) {

/**
* Gigya initialize events
* Global page wide methods or services
* behavior calls gigya.account.addEventHandles to make login and logout calls global
*/
SNI.Application.addBehavior('gigya/init', function (context) {
  var debug = context.getService('logger').create('behavior.gigya.init');
  var check = context.getService('check').new(debug);

  /** @addEventHandlers
  * this registers login and logout globaly as callbacks when those actions are taken
  * exported and used inside of behaviors/gigya/init.js
  */
  function addEventHandlers() {
    var gigya = check.exists('gigya.accounts') ? context.getGlobal('gigya') : false;

    if (gigya) {
      gigya.accounts.addEventHandlers({
        onLogin: onLogin,
        onLogout: onLogout
      });
    }
  }

  /** @onLogout
  * Automaticly called after every logout initalized from @addEventHandlers
  * broadcast a message that anyone can listen to and use as an event listener
  */
  function onLogout() {
    context.broadcast('gigya.isloggedOut');
  }

  /** @onLogin
  * Automaticly called after every login initalized from @addEventHandlers
  * broadcast a message that anyone can listen to and use as an event listener
  */

  function onLogin(response) {

    // broacast login
    context.broadcast('gigya.isloggedIn', response);
  }

  return {
    init: function init() {
      addEventHandlers();
    }
  };
});

/***/ }),
/* 401 */
/***/ (function(module, exports) {

/**
* Login and logout Behavior
* behavior makes a call to gigya and handles click events for header/nav menus
*/
SNI.Application.addBehavior('gigya/login', function (context) {

  var gigyaSvc = context.getService('gigya'),
      // Gigya T3 Service
  debug = context.getService('logger').create('behavior.gigya.login'),
      moderation = context.getService('gigya/moderation'),
      config = context.getConfig(),
      check = context.getService('check'),
      modURL = void 0;

  if (config) {
    // reads the header x-config
    modURL = config.moderationURL || '';
    moderation.setModURL(modURL, 'profile');
    gigyaSvc.configGS('reg_promo_text', config.regPromoText || '', 'hash_encode');
  }

  if (!check.exists('gigya')) {
    debug.error('Gigya is not defined -- API is not initialized');
  } else {
    debug.log('Init Gigya accounts');
  }

  function preventNavClose(o) {
    $('#' + o.currentScreen).on('click', function (e) {
      e.stopPropagation();
    });
  }

  /** @clickHandlers
  * these are events attached to pieces of the DOM
  * click handlers are added for both login and logout button
  * One way we handle Event Delegation in t3
  */
  var clickHandlers = {
    'gigya-login': function gigyaLogin(event, element) {
      event.preventDefault();
      event.stopPropagation();
      gigyaSvc.account.showLoginRegScreen(event, false, false, preventNavClose);
    },
    'gigya-logout': function gigyaLogout(event, element) {
      event.preventDefault();
      event.stopPropagation();
      gigyaSvc.account.logOut();
    },
    'gigya-register': function gigyaRegister(event, element) {
      event.preventDefault();
      event.stopPropagation();
      gigyaSvc.account.showLoginRegScreen(event, true, false, preventNavClose);
    }
  };

  return {
    init: function init() {
      gigyaSvc.account.isLoggedIn();
    },
    onclick: function onclick(event, element, elementType) {
      if (elementType in clickHandlers) {
        clickHandlers[elementType](event, element);
      }
    }
  };
});

/***/ }),
/* 402 */
/***/ (function(module, exports) {

/**
* Profile screen behaviors
*/

SNI.Application.addBehavior('gigya/profile', function (context) {

  var gigyaSvc = context.getService('gigya');

  return {
    onclick: function onclick(event, element, elementType) {

      switch (elementType) {
        case 'gigya-core-change-pwd':
          event.preventDefault();
          event.stopPropagation();
          gigyaSvc.account.showLoginRegScreen({}, false, 'gigya-password-change-required-screen');
          break;
      }
    }
  };
});

/***/ }),
/* 403 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('gigya/remove-inline-styles', function (context) {
  var _context$getService = context.getService('remove-inline-styles'),
      removeDynamicInlineStyles = _context$getService.removeDynamicInlineStyles;

  var defaultConfig = {
    filters: ['.gig-composebox', '.gig-comment']
  };
  var config = Object.assign({}, defaultConfig, context.getConfig('gigya'));

  return {
    init: function init() {
      removeDynamicInlineStyles(config.filters, { pollRate: 1000 });
    }
  };
});

/***/ }),
/* 404 */
/***/ (function(module, exports) {

/**
* Registration screen behaviors
*/

SNI.Application.addBehavior('gigya/screens', function (context) {

  //let debug = context.getService('logger').create('service.gigya.account');
  var device = context.getService('device-type');

  function daysInMonth(month, year) {
    return new Date(year, month, 0).getDate();
  }

  return {
    onclick: function onclick(event, element, elementType) {
      var $elem = $(context.element),
          diagTarget = device.isMobile ? '.gigya-screen-dialog-mobile' : '.gigya-screen-dialog',
          $diag = $(diagTarget),
          diag = $diag.get(0),
          coords = diag.getBoundingClientRect(),
          top = coords.top + 0;
      //  scroll = window.scrollY;

      switch (elementType) {
        case 'email-registration':
          event.preventDefault();
          event.stopPropagation();
          $elem.find('#register-site-login').show();
          $elem.find('#gigya-core-signuplink').hide();
          $elem.find('#gigya-core-signuptext').show();

          var newTop = top - 200 > 0 ? top - 200 : top;
          $diag.css({ top: newTop }); // move the screen up
      }
    },
    onchange: function onchange(event, element, elementType) {
      /*
          Handles event types for: COPA data changes and gender selection updates
          removes error classes when possible.  For COPA day/month selections it
          will adjust the number on days on the drop down based on the month.
          Hence, a selection of Month==2 will limit the drop down to show 28 days only
      */

      var $elem = $(element),
          $parent = void 0,
          $day = void 0,
          day = void 0,
          $month = void 0,
          month = void 0,
          $year = void 0,
          year = void 0,
          numDays = void 0,
          j = void 0;

      if (elementType === 'registration-gender' || elementType === 'registration-month' || elementType === 'registration-day') {
        $parent = $elem.closest('form');
      } else {
        return;
      }

      if (elementType === 'registration-gender') {
        $parent.find('[data-type="registration-gender"]').removeClass('gigya-error');
      }
      if (elementType === 'registration-month' || elementType === 'registration-day') {
        $day = $parent.find('.registration-birthDay');
        $month = $parent.find('.registration-birthMonth');
        $year = $parent.find('.registration-birthYear');
        month = Number($month.val());
        year = Number($year.val());
        day = Number($day.val());

        if (elementType === 'registration-month') {
          if (month && year) {
            numDays = daysInMonth(month, year);
            var count = $day.children().length - 1;
            if (count !== numDays) {
              $day.children().remove();
              $day.append('<option value>DD</option>');
              for (j = 0; j < numDays; j++) {
                $day.append('<option value="' + (j + 1) + '" ' + (day <= numDays && day === j + 1 ? 'selected' : '') + '>' + (j + 1) + '</option>');
              }
              $('#registration-monthday-alert').show();
            }
          }
        }
        if (month && day) {
          $('#registration-monthday-alert').hide();
        } else {
          $('#registration-monthday-alert').show();
        }
      }
    }
  };
});

/***/ }),
/* 405 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('hotspot', function (context) {
  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var behavior = void 0,
      hotspotService = void 0,
      template = void 0,
      debug = context.getService('logger').create('behavior.hotspot'),
      check = context.getService('check').new(debug),
      device = void 0,
      config = void 0,
      location = void 0,
      attentionCount = void 0,
      defaults = void 0,
      hotspotToggleDefaults = void 0,
      hotspotToggleConfig = void 0;

  if (!check.jqueryPlugin('tooltip')) return {};

  defaults = {
    hotspotWidth: 0,
    hotspotHeight: 0,
    hotspotShowHide: true,
    hotspotShowAll: true,
    hotspotClass: '',
    hotspotHref: '#',
    hotspotTitle: '',
    tooltipPosition: 'top',
    collectionHotspots: false,
    elementHotspots: false,
    scrollOffset: 0,
    element: '',
    url: '',
    imageUrl: '',
    hotspotMessages: {
      dataUpdated: 'hotspotDataUpdated',
      contentUpdated: 'elementUpdated',
      viewportUpdated: 'viewportUpdated',
      hotspotsFound: 'hotspotsFound',
      hotspotsShown: 'hotspotsShown',
      hotspotsHidden: 'hotspotsHidden',
      productModalShown: 'hotspotProductModalShown'
    },
    dom: {},
    initDeferred: false,
    classContainer: 'hotspotContainer',
    classAttention: 'hotspotAttention',
    classHide: 'hotspotHide',
    attentionMax: 2,
    attentionTimeout: 500,
    isMobile: false,
    pageTypes: {
      inline: false,
      photoLibrary: false,
      vertical: false
    }
  };

  hotspotToggleDefaults = {
    position: 'top right'
  };

  function getServices(currentContext) {
    device = currentContext.getService('device-type');
    hotspotService = context.getService('hotspot');
    template = context.getService('template');
  }

  function getGlobalVars(currentContext) {
    location = currentContext.getGlobal('location');
    attentionCount = 0;
  }

  function setDeviceType(currentContext, updateName, deviceService) {
    var currentDevice = deviceService.isMobile;
    currentContext.broadcast(updateName, {
      isMobile: currentDevice
    });
  }

  function setPageTypes(currentContext, updateName) {
    var newTypes = {
      inline: $('.container-site').hasClass('inline-horizontal'),
      photoLibrary: $('body').hasClass('photoLibraryViewerPage'),
      vertical: $('.container-site').hasClass('vertical')
    };
    currentContext.broadcast(updateName, {
      pageTypes: newTypes
    });
  }

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setHotspotConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function setHotspotToggleConfig(oldSettings, newSettings) {
    hotspotToggleConfig = updateObject(oldSettings, newSettings);
  }

  function broadcastConfigChange(currentContext, update, currentData) {
    currentContext.broadcast(update, currentData);
  }

  function getHotspots(currentContext, updateName, showName, foundName, service, currentUrl, currentImageUrl, deferred, el) {
    if (deferred) {
      service.get({
        url: currentUrl
      }).done(function (data) {
        var currentHotspots = void 0;
        currentContext.broadcast(updateName, {
          collectionHotspots: data
        });
        currentHotspots = data[currentImageUrl];
        if (currentHotspots && currentHotspots.length > 0) {
          currentContext.broadcast(updateName, {
            elementHotspots: currentHotspots
          });
          currentContext.broadcast(foundName, {
            elem: el
          });
          currentContext.broadcast(showName);
        } else {
          debug.warn('getHotspots: no hotspots for this image');
          deferred.fail();
        }
      }).fail(function () {
        debug.warn('getHotspots: hotspot service failed to fetch hotspots from: ', currentUrl);
        deferred.fail();
      });
    }
  }

  function createContainer(currentContext, currentDom, containerClass, customClass, type, updateName) {
    var positionType = void 0,
        hotspotDom = void 0;

    positionType = type;
    hotspotDom = currentDom;

    hotspotDom.container = $('<div>').addClass(containerClass).css({
      position: positionType,
      left: 0,
      top: 0,
      display: 'none'
    });

    if (customClass) {
      hotspotDom.container.addClass(customClass);
    }

    currentContext.broadcast(updateName, {
      dom: hotspotDom
    });
  }

  function appendContainer(currentContainer, currentElement) {
    debug.log('appendContainer: currentContainer: ', currentContainer);
    debug.log('appendContainer: currentElement: ', currentElement);
    currentContainer.insertAfter(currentElement);
  }

  function appendElementHotspots(currentContext, updateName, currentDom, currentElementHotspots, getCurrentHref, getCurrentTitle, getCurrentPosition, positionType) {
    $.each(currentElementHotspots, function () {
      var href = void 0,
          title = void 0,
          currentPosition = void 0,
          updatedDom = void 0;

      href = getCurrentHref(this);
      title = getCurrentTitle(this);
      currentPosition = getCurrentPosition(this.x, this.y);
      updatedDom = currentDom;

      $('<a>').attr({
        href: href,
        title: title,
        'data-trigger': 'hover focus',
        'data-placement': currentPosition,
        'data-animation': true,
        'data-delay': 300,
        'data-type': 'launch-product-modal'
      }).tooltip().data('hotspot', this).css({
        position: positionType,
        left: this.x + '%',
        top: this.y + '%'
      }).appendTo(updatedDom.container);

      currentContext.broadcast(updateName, {
        tooltipPosition: currentPosition,
        hotspotHref: href,
        hotspotTitle: title,
        dom: updatedDom
      });
    });
  }

  function createHotspotToggle(show, templateService, inline, mobile, currentElement) {
    var hotspotToggle = void 0;

    if (show) {
      hotspotToggle = $(templateService.hotspotToggle(hotspotToggleConfig));

      if (inline && !mobile) {
        hotspotToggleConfig.newTemplate ? currentElement.parent().append(hotspotToggle) : currentElement.parent().parent().append(hotspotToggle);
      } else {
        currentElement.parent().append(hotspotToggle);
      }
    }
  }

  function updateToggleText(toggleLink) {
    var hotspotToggleLink = toggleLink;
    hotspotToggleLink.html() === 'Hide' ? hotspotToggleLink.html('Show') : hotspotToggleLink.html('Hide');
  }

  function toggle(currentContext, showName, hideName, currentDom, hiddenClass) {
    if (!currentDom.hasClass(hiddenClass)) {
      currentDom.addClass(hiddenClass);
    } else {
      currentDom.removeClass(hiddenClass);
    }
  }

  function show(currentContext, updateName, currentDom, hiddenClass, count, max, currentAttention, attentionClass, time) {
    currentDom.container.removeClass(hiddenClass).show();
    if (count++ < max) {
      currentAttention(currentDom, attentionClass, time);
    }
    // element shown event ? is it needed
    currentContext.broadcast(updateName, {
      dom: currentDom
    });
  }

  function hide(currentContext, updateName, currentDom, hiddenClass) {
    currentDom.container.addClass(hiddenClass);
    currentContext.broadcast(updateName, {
      dom: currentDom
    });
    // element hide event ? is it needed
  }

  function attention(currentDom, attentionClass, time) {
    currentDom.container.addClass(attentionClass);
    setTimeout(function () {
      currentDom.container.removeClass(attentionClass);
    }, time);
  }

  function doClick(currentContext, name, currentHotspot, checkService, allHotspots, settings) {
    var renderer = currentHotspot.renderer,
        legacy_s = context.getGlobal('s'),
        mdManager = context.getGlobal('mdManager'),
        eID = void 0,
        eName = void 0,
        room = void 0,
        hText = void 0;

    if (checkService.exists(['s', 'mdManager'])) {
      eID = mdManager.getParameterString('EditorialTracking').replace(/[^a-z0-9\s]/gi, '') + ' Photo Gallery Hotspots', eName = mdManager.getParameterString('Title').replace(/[^a-z0-9\s]/gi, ''), room = mdManager.getParameterString('CurrentRoom').replace(/[^a-z0-9\s]/gi, '') + ' Pictures', hText = currentHotspot.title.replace(/[^a-z0-9\s]/gi, '');

      legacy_s.linkTrackVars = 'prop1,prop2,eVar46,eVar47,eVar48,events';
      legacy_s.linkTrackEvents = 'event47';
      legacy_s.events = 'event47';
      legacy_s.eVar46 = eID;
      legacy_s.eVar47 = eID + ':' + hText;
      legacy_s.eVar48 = eID + ':Photos:' + eName + ':' + room + ':' + hText;
      legacy_s.tl(this, 'o', eID + ':Hotspot Click');
      legacy_s.eVar46 = '';
      legacy_s.eVar47 = '';
      legacy_s.eVar48 = '';
    }

    if (renderer) {
      renderer.display(currentHotspot, allHotspots, settings);
      currentContext.broadcast(name);
    }
  }

  function getTooltipPosition(x, y) {
    var buffer = 10,
        min = void 0,
        max = void 0,
        pos = void 0;

    min = buffer;
    max = 100 - buffer;

    if (x < min) {
      pos = 'right';
    } else if (x > max) {
      pos = 'left';
    } else if (y < min) {
      pos = 'bottom';
    } else {
      pos = 'top';
    }

    return pos;
  }

  /**
   * Adjusts hotspot container dimensions according to current content size.
   */
  function updateContainerSize(targetElement, container) {
    container.css({
      top: 0,
      width: targetElement.width(),
      height: targetElement.height()
    });
  }

  /**
   * Sets initial hotspot container size and updates config state.
   */
  function setSize(currentContext, updateName, width, height, currentElement, currentDom) {
    if (currentDom && currentDom.container) {
      updateContainerSize(currentElement, currentDom.container);
      currentContext.broadcast(updateName, {
        hotspotWidth: currentElement.width(),
        hotspotHeight: currentElement.height(),
        dom: currentDom
      });
    }
  }

  function getHref(hotspot) {
    var renderer = hotspot.renderer,
        href = void 0;

    if (renderer) {
      href = renderer.getHref(hotspot);
    } else {
      href = '#';
    }

    return href;
  }

  function getTooltip(hotspot) {
    var renderer = hotspot.renderer,
        title = void 0;

    if (renderer) {
      title = renderer.getTitle(hotspot);
    } else {
      title = '';
    }

    return title;
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  behavior = {

    messages: [defaults.hotspotMessages.dataUpdated, defaults.hotspotMessages.contentUpdated, defaults.hotspotMessages.viewportUpdated, defaults.hotspotMessages.hotspotsFound, defaults.hotspotMessages.hotspotsShown, defaults.hotspotMessages.hotspotsHidden, defaults.hotspotMessages.productModalShown],

    init: function init() {
      config = Object.assign({}, defaults, context.getConfig('hotspots'));
      hotspotToggleConfig = Object.assign({}, hotspotToggleDefaults, context.getConfig('hotspot-toggle'));
      hotspotToggleConfig.newTemplate = context.getConfig().hasOwnProperty('newTemplate') ? context.getConfig().newTemplate : false;
      getServices(context);
      getGlobalVars(context);
      setDeviceType(context, defaults.hotspotMessages.dataUpdated, device);
      setPageTypes(context, defaults.hotspotMessages.dataUpdated);
      broadcastConfigChange(context, defaults.hotspotMessages.dataUpdated, {
        url: location.pathname
      });
    },

    getServices: getServices,
    getGlobalVars: getGlobalVars,
    setDeviceType: setDeviceType,
    setPageTypes: setPageTypes,
    updateObject: updateObject,
    setHotspotConfig: setHotspotConfig,
    setHotspotToggleConfig: setHotspotToggleConfig,
    broadcastConfigChange: broadcastConfigChange,
    getHotspots: getHotspots,
    getHref: getHref,
    getTooltip: getTooltip,
    getTooltipPosition: getTooltipPosition,
    createContainer: createContainer,
    appendContainer: appendContainer,
    setSize: setSize,
    appendElementHotspots: appendElementHotspots,
    createHotspotToggle: createHotspotToggle,
    updateToggleText: updateToggleText,
    toggle: toggle,
    show: show,
    hide: hide,
    attention: attention,
    doClick: doClick,

    onmessage: function onmessage(name, data) {
      switch (name) {
        case defaults.hotspotMessages.dataUpdated:
          setHotspotConfig(config, data);
          break;
        case defaults.hotspotMessages.contentUpdated:
          broadcastConfigChange(context, defaults.hotspotMessages.dataUpdated, data);
          getHotspots(context, defaults.hotspotMessages.dataUpdated, defaults.hotspotMessages.hotspotsShown, defaults.hotspotMessages.hotspotsFound, hotspotService, config.url, config.imageUrl, config.initDeferred, data.element);
          break;
        // Adjusts hotspot container dimensions when device orientation is changed,
        // so hotspots will remain on the same place.
        case defaults.hotspotMessages.viewportUpdated:
          var container = data.element.next();
          if (container && container.hasClass(config.classContainer)) {
            updateContainerSize(data.element, container);
          }
          break;
        case defaults.hotspotMessages.hotspotsFound:
          createContainer(context, config.dom, config.classContainer, config.hotspotClass, 'absolute', defaults.hotspotMessages.dataUpdated);
          appendContainer(config.dom.container, data.elem);
          setSize(context, defaults.hotspotMessages.dataUpdated, config.hotspotWidth, config.hotspotHeight, data.elem, config.dom);
          appendElementHotspots(context, defaults.hotspotMessages.dataUpdated, config.dom, config.elementHotspots, getHref, getTooltip, getTooltipPosition, 'absolute');
          createHotspotToggle(config.hotspotShowHide, template, config.pageTypes.inline, config.isMobile, data.elem);
          config.initDeferred.resolve();
          break;
        case defaults.hotspotMessages.hotspotsShown:
          show(context, defaults.hotspotMessages.dataUpdated, config.dom, config.classHide, attentionCount, config.attentionMax, attention, config.attentionClass, config.attentionTimeout);
          break;
        case defaults.hotspotMessages.hotspotsHidden:
          hide(context, defaults.hotspotMessages.dataUpdated, config.dom, config.classHide);
          break;
        case defaults.hotspotMessages.productModalShown:
          break;
      }
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'toggle-hotspot':
          event.preventDefault();
          event.stopPropagation();
          var hotCon = config.isMobile ? $(element).siblings('.hotspotContainer') : $(element).parent('.pv-photo-wrapper').find('.hotspotContainer'); //$(element).parent().find('.hotspotContainer')
          hotCon = hotspotToggleConfig.newTemplate ? $(element).parent().find('.hotspotContainer') : hotCon;
          toggle(context, defaults.hotspotMessages.hotspotsShown, defaults.hotspotMessages.hotspotsHidden, hotCon, config.classHide);
          updateToggleText($(element).find('a'));
          break;
        case 'launch-product-modal':
          event.preventDefault();
          event.stopPropagation();
          doClick(context, defaults.hotspotMessages.productModalShown, $(element).data('hotspot'), check, config.collectionHotspots, config);
          break;
        case 'close-product-modal':
          break;
        case 'open-more-info':
          break;
        case 'show-all-products':
          break;
        case 'close-all-products':
          break;
      }
    }

  };

  return behavior;
});

/***/ }),
/* 406 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('lazy-load', function (context) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var $element = $(context.getElement());
  var service = context.getService('lazy-load').init();
  //let debug     = context.getService('logger').create('behavior.lazy-load');

  var defaults = {
    placeholder: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', // 1x1 transparent gif
    trigger: 'inview', // 'scroll', 'inview'
    usePlaceholder: true
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    init: function init() {
      service.addImages({
        container: $element,
        settings: Object.assign({}, defaults, context.getConfig('lazyLoad'))
      });
    },
    destroy: function destroy() {
      service.destroy();
    }
  };
});

/***/ }),
/* 407 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('lightbox', function (context) {
  var _context$getService = context.getService('common-handlers'),
      eventHandler = _context$getService.eventHandler;

  var el = context.getElement();
  var $el = $(el);
  var debug = context.getService('logger').create('behavior.lightbox');
  var store = context.getService('state').createStore(el.id + '-lightbox', {
    data: {
      expanded: false
    },
    methods: {
      expand: function expand() {
        this.expanded = true;
      },
      collapse: function collapse() {
        this.expanded = false;
      }
    },
    watch: {
      expanded: function expanded(expand) {
        if (expand) {
          $el.addClass('is-Expanded').removeClass('is-Collapsed');
        } else {
          $el.addClass('is-Collapsed').removeClass('is-Expanded');
        }
      }
    },
    watchAll: function watchAll(key, val) {
      debug.log('Updated state', key, val);
    }
  });

  Object.assign(store, context.getConfig('lightbox'));

  return {
    onmessage: {
      'lightbox.expand': function lightboxExpand() {
        return store.expand();
      },
      'lightbox.collapse': function lightboxCollapse() {
        return store.collapse();
      }
    },
    onclick: eventHandler({
      'lightbox.expand': function lightboxExpand() {
        return context.broadcast('lightbox.expand');
      },
      'lightbox.collapse': function lightboxCollapse() {
        return context.broadcast('lightbox.collapse');
      }
    }, true)
  };
});

/***/ }),
/* 408 */
/***/ (function(module, exports) {

/**
 * Load More Behavior
 */

SNI.Application.addBehavior('load-more', function (context) {

  var debug = context.getService('logger').create('behavior.load-more');
  var defaults = {
    loadTechique: 'ajax', // not implemented yet but it would be nice to be able to AJAX content...
    loadButtonClass: '.load-more button',
    loadContainer: '.load-more-container',
    loadDataSource: '.list-load-more',
    limit: 0
  };
  var lazyLoad = context.getService('lazy-load');
  var config = Object.assign({}, defaults, context.getConfig('loadMore'));
  var $element = $(context.getElement());
  var $dataSource = $element.find(config.loadDataSource);
  var $loadButton = $element.find(config.loadButtonClass);
  var $loadContainer = $element.find(config.loadContainer);

  return {
    config: config,
    init: function init() {
      debug.log('Load More Behavior: Init Start');
    },

    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'load-more-btn':
          debug.log('Load More Behavior: Load More Button Clicked');
          this.loadMoreItems();
          break;
      }
    },


    loadMoreItems: function loadMoreItems() {
      if (config.limit !== 0) {
        $loadContainer.append($dataSource.children().slice(0, config.limit));
      } else {
        $loadContainer.append($dataSource.contents());
      }

      lazyLoad.forceScroll();

      //hide button when appending last set of results
      if ($dataSource.children().length === 0) {
        $loadButton.parent().hide();
      }
    }

  };
});

/***/ }),
/* 409 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('maps', function (context) {

  var defaults = {
    title: '',
    street1: '',
    street2: '',
    street3: '',
    city: '',
    state: '',
    zip: '',
    iOS: false,
    iOSBase: 'https://maps.apple.com/?daddr=',
    defaultBase: 'https://maps.google.com/?q='
  };

  var debug = context.getService('logger').create('behavior.maps');
  var device = context.getService('device-type');
  var config = Object.assign({}, defaults, context.getConfig('maps'));
  var element = context.getElement();

  function constructDefaultMapsURL() {
    var base = config.defaultBase,
        title = config.title === '' ? '' : '' + config.title,
        st1 = config.street1 === '' ? '' : config.street1 + '+',
        st2 = config.street2 === '' ? '' : config.street2 + '+',
        st3 = config.street3 === '' ? '' : config.street3 + '+',
        cty = config.city === '' ? '' : config.city + '+',
        st = config.state === '' ? '' : config.state + '+',
        z = config.zip === '' ? '' : '' + config.zip,
        country = config.country === '' ? '' : config.country === 'US' ? '' : '+' + config.country;
    title = title.replace(/\&/ig, '%26');
    var defaultUrl = '' + base + title + '+near+' + st1 + st2 + st3 + cty + st + z + country;
    return defaultUrl;
  }

  function constructAppleMapsURL() {
    var base = config.iOSBase,
        st1 = config.street1 === '' ? '' : config.street1 + ',',
        st2 = config.street2 === '' ? '' : config.street2 + ',',
        st3 = config.street3 === '' ? '' : config.street3 + ',',
        cty = config.city === '' ? '' : config.city + ',',
        st = config.state === '' ? '' : config.state + ',',
        z = config.zip === '' ? '' : '' + config.zip;
    var iOSUrl = '' + base + st1 + st2 + st3 + cty + st + z;
    return iOSUrl;
  }

  function constructMapsURL(isApple) {
    var mapsUrl = void 0;

    if (isApple) {
      mapsUrl = constructAppleMapsURL();
    } else {
      mapsUrl = constructDefaultMapsURL();
    }

    return mapsUrl;
  }

  function insertMapsURL(finalUrl, element) {
    var $element = $(element);
    // $element.find('a').attr('href', finalUrl);
    if (device.isMobile) {
      $element.find('a:contains(\'Get Directions\')').hide();
    } else {
      $element.find('a:contains(\'Get Directions\')').attr('href', finalUrl);
    }
    $element.find('a:contains(\'Directions\')').attr('href', finalUrl);
  }

  return {
    init: function init() {
      debug.log('device.isIOS: ', device, device.isIOS);
      config.iOS = device.isIOS;
      insertMapsURL(constructMapsURL(config.iOS), element);
    },


    constructMapsURL: constructMapsURL,
    constructDefaultMapsURL: constructDefaultMapsURL,
    constructAppleMapsURL: constructAppleMapsURL,
    insertMapsURL: insertMapsURL
  };
});

/***/ }),
/* 410 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('media-stream', function (context) {
  'use strict';

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var behavior = void 0;

  var mediaStreamService = context.getService('media-stream');
  var messageHandlers = {
    'mediaStream.readyForNextSS': function mediaStreamReadyForNextSS() {
      mediaStreamService.gotoSS('next');
    },
    'mediaStream.readyForPreviousSS': function mediaStreamReadyForPreviousSS() {
      mediaStreamService.gotoSS('previous');
    },
    'ajax.areaContentLoading': function ajaxAreaContentLoading() {
      mediaStreamService.lowerCurtain();
    },
    'ajax.areaContentLoaded': function ajaxAreaContentLoaded() {
      mediaStreamService.raiseCurtain();
    },
    'ajax.modulesInitialized': function ajaxModulesInitialized(data) {
      mediaStreamService.initializeNewContent(data);
    }
  };

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  behavior = {
    messages: Object.keys(messageHandlers),
    onmessage: function onmessage(msg, data) {
      messageHandlers[msg](data);
    }
  };

  return behavior;
});

/***/ }),
/* 411 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('multi-component-dynamic-ad', function (context) {
  var ads = context.getService('ads');
  var SniAds = ads.adLib;
  var debug = context.getService('logger').create('behavior.multi-component-dynamic-ad');

  return {
    init: function init() {
      ads.getDynamicSlots($(context.getElement()).parent()).forEach(function (slot) {
        SniAds.ready(function () {
          SniAds.appendSlot(slot.id, slot.type, {}, true); // lazy-load dynamic slots
          debug.log('SniAds.appendSlot(slot.id, slot.type, {});', slot.id, slot.type);
        });
      });
    }
  };
});

/***/ }),
/* 412 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('popover', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var debug = context.getService('logger').create('behavior.popover');
  var check = context.getService('check').new(debug);
  if (!check.jqueryPlugin('popover')) return {};

  var $element = $(context.getElement());

  var defaults = {
    name: 'popover',
    placement: 'right',
    trigger: 'focus',
    content: '',
    title: 'test',
    container: $element,
    target: false,
    html: true,
    template: 'Popover template is not defined'
  };

  var config = Object.assign({}, defaults, context.getConfig('popover'));
  var target = config.target ? $element.find(config.target) : $element;

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {
    init: function init() {
      debug.log('Initialize', $element, config);

      var template = $element.find('#' + config.name + '-template');
      var content = $element.find('#' + config.name + '-content');

      if (template.size()) {
        config.template = template.html();
      }

      if (content.size()) {
        config.content = content.html();
      }

      debug.log(config);
      target.popover(config);
    },


    onclick: function onclick(event, element, elementType) {

      switch (elementType) {

        case 'toggle-popover':
          target.popover('toggle');
          break;

        case 'close-popover':
          target.popover('hide');
          break;

        default:
          debug.log(event, element, elementType);
          break;
      }
    }

  };
});

/***/ }),
/* 413 */
/***/ (function(module, exports) {

/**
 * @fileoverview Popup Behavior
 * @author Jonathan Kemp
 */

/*
 * Opens up a new window on click
 */
SNI.Application.addBehavior('popup', function (context) {
  'use strict';

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var windowObjectReference = null;

  var defaults = {
    popupWidth: '1100',
    popupHeight: '700'
  };
  var config = Object.assign({}, defaults, context.getConfig());

  function openPopup(href) {
    if (windowObjectReference === null || windowObjectReference.closed) {
      windowObjectReference = window.open(href, 'SNIWindowName', 'resizable,scrollbars,width=' + config.popupWidth + ',height=' + config.popupHeight);
    } else {
      windowObjectReference.focus();
    }
  }

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------
  return {
    onclick: function onclick(event, element, elementType) {
      if (elementType === 'popup') {
        event.preventDefault();

        openPopup(element.href);
      }
    }
  };
});

/***/ }),
/* 414 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('product-list', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var messages = ['product.clicked', 'product.displayed'],
      shopping = context.getService('track-shopping');

  function onmessage(name, data) {
    switch (name) {
      case 'product.clicked':
        shopping.trackShopping(data, 'click');
        break;
      case 'product.displayed':
        shopping.trackShopping(data, 'impression');
        break;
      default:
        break;
    }
  }

  //-----------------------------------------------------------
  // Public API
  //-----------------------------------------------------------

  return {
    messages: messages,
    onmessage: onmessage
  };
});

/***/ }),
/* 415 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('router', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var routingService = context.getService('router');

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {

    messages: ['stateChanged', 'previousUrlChanged'],

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'stateChanged':
          routingService.handleStateChange(data);
          break;
        case 'previousUrlChanged':
          routingService.setPreviousUrl(data.previousURL);
          break;
      }
    },

    onclick: function onclick(event) {

      if (event.target.tagName.toLowerCase() === 'a') {
        routingService.routeClickHandling(event);
      }
    }

  };
});

/***/ }),
/* 416 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('shop-this-look', function (context) {
  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var deviceType = void 0,
      analytics = void 0,
      template = void 0,
      isMobile = void 0,
      isTablet = void 0,
      shopContainer = void 0,
      analyticsContainer = void 0,
      shopOverlay = void 0,
      productManager = void 0,
      overlayType = void 0,
      photoViewerScrollOffset = void 0,
      defaults = void 0,
      config = void 0,
      shopping = void 0,
      dynamicGalleryType = void 0,
      debug = void 0;

  defaults = {
    shopOverlayClass: '.shop-overlay',
    overlayCloseEventName: 'click.closeShop',
    closeOverlaySel: '[data-shop-this-look-close]',
    containerSelector: '.slideshow-wrapper',
    shopInsertionSelector: '.slide-container',
    shoppableElement: '.slide',
    shopBtnSelector: '.a-ShopButton',
    productHeaderSelector: '.shop-overlay .products-header',
    stlEnabled: 'productEnabled',
    dynamicSTL: false,
    maxSTLCheck: 'curated',
    maxSTLPreLoad: 3,
    productsInSet: 6,
    vendorCode: 'vendor1',
    disableSets: false, // Disable the fetching of batch product sets
    productListContainer: '.o-PhotoGalleryPromo__m-ProductsList',
    partnerText: 'partner;wayfair/shop_this_look',
    shopNamespace: 'ShopThisLook',
    container: '#photo-gallery'
  };

  function createOverlay(currentContext, productId, overlay, oType, mobile, overlayClass, closer, eventName, currentSelector, wrapper) {
    appendOverlay(overlay);

    if (mobile) {
      $(wrapper).addClass('no-scroll');
    }

    setScrollPoints(oType, true);

    $(overlayClass).find(closer).on(eventName, function () {
      removeOverlay(oType, overlayClass, closer, wrapper);
    });

    currentContext.broadcast('stl.updateClickTracking', {
      sel: currentSelector
    });
  }

  function removeOverlay(oType, sel, eventName, wrapper) {
    $(sel).off(eventName);

    deleteOverlay(sel);

    if (isMobile) {
      if (oType === 'mobile-overlay') {
        $(wrapper).removeClass('no-scroll');
      } else {
        $(wrapper).removeClass('no-scroll').css('position', 'relative');
      }
    }

    setScrollPoints(oType, false);
  }

  function appendOverlay(overlay) {
    $(document.body).append(overlay);
  }

  function deleteOverlay(selector) {
    $(document.body).find(selector).remove();
  }

  function getGalleryType() {
    var libraryViewerClass = 'photoLibraryViewerPage',
        inlineClass = 'inline-horizontal',
        verticalClass = 'vertical',
        siteContainerSelector = '.container-site';

    if (($('body').hasClass(libraryViewerClass) || $(siteContainerSelector).hasClass(inlineClass)) && isTablet) {
      return 'tablet-viewer';
    } else if (($('body').hasClass(libraryViewerClass) || $(siteContainerSelector).hasClass(inlineClass) || $(siteContainerSelector).hasClass(verticalClass)) && isMobile) {
      return 'mobile-scroll';
    } else if ($('body').hasClass(libraryViewerClass) || $(siteContainerSelector).hasClass(inlineClass) || $(siteContainerSelector).hasClass(verticalClass)) {
      return 'desktop-gallery';
    } else if (!$(siteContainerSelector).hasClass(verticalClass) && isMobile) {
      return 'mobile-overlay';
    } else {
      return false;
    }
  }

  function setTabletScroll() {
    $('body').addClass('pv-no-scroll');
    $('.shop-overlay').addClass('pv-shop-overlay');
    $('.products').addClass('pv-products');
  }

  function removeTabletScroll() {
    $('body').removeClass('pv-no-scroll');
    $('.shop-overlay').removeClass('pv-shop-overlay');
    $('.products').removeClass('pv-products');
  }

  function setMobileScroll() {
    photoViewerScrollOffset = $(window).scrollTop();
    $(window).scrollTop(0);
    $('body').addClass('no-scroll');
  }

  function removeMobileScroll() {
    $('body').removeClass('no-scroll');
    $(window).scrollTop(photoViewerScrollOffset);
    photoViewerScrollOffset = 0;
  }

  function setDesktopScroll() {
    photoViewerScrollOffset = $(window).scrollTop();
    $(window).scrollTop(0);
    $('body').addClass('pv-no-scroll');
    $('body').css('overflow', 'hidden');
    $('.shop-overlay').addClass('pv-shop-overlay');
    $('.products').addClass('pv-products');
  }

  function removeDesktopScroll() {
    $('body').removeClass('pv-no-scroll');
    $('body').css('overflow', 'auto');
    $('.shop-overlay').removeClass('pv-shop-overlay');
    $('.products').removeClass('pv-products');
    $(window).scrollTop(photoViewerScrollOffset);
    photoViewerScrollOffset = 0;
  }

  function setScrollPoints(type, isAdd) {
    switch (type) {
      case 'tablet-viewer':
        if (isAdd) {
          setTabletScroll();
        } else {
          removeTabletScroll();
        }
        break;
      case 'mobile-scroll':
        if (isAdd) {
          setMobileScroll();
        } else {
          removeMobileScroll();
        }
        break;
      case 'desktop-gallery':
        if (isAdd) {
          setDesktopScroll();
        } else {
          removeDesktopScroll();
        }
        break;
    }
  }

  function shop() {
    shopContainer = $(context.getElement()).find(config.shoppableElement);
    if (SNI.Config.isEnabled('shopThisLook')) {
      var productIds = [],
          $deferred = void 0,
          addSet = void 0;
      shopContainer.each(function () {
        var currentSlide = $(this),
            currentSlideContainer = $(this).find(config.shopInsertionSelector),
            currentProductId = currentSlide.data('productId'),
            productEnabled = currentSlide.data('productEnabled');
        if (!config.dynamicSTL) {
          addShopButton(currentSlide, isMobile, currentSlideContainer, currentProductId);
        } else {
          if (productEnabled) {
            productIds.push(currentProductId);
          }
        }
      });
      if (productIds.length > 0 && (isMobile || !config.disableSets)) {
        // Has products & isMobile or has products and is not requesting sets
        addSet = productManager.addSet(productIds); // Add products in bulk whenever possible
        var checkMax = config.maxSTLCheck,
            max = dynamicGalleryType === checkMax || checkMax === 'both' ? config.maxSTLPreLoad : null; // limit the number of pre-loaded product slides
        if (isMobile) {
          $deferred = addSet.$deferred;
          $deferred.then(function (data) {
            return setUpAllProds(data, max);
          }).fail(function (result) {
            debug.log('Unable to retrieve product from Vendor API');
          }); //?
        }
      }
    }
  }

  function addShopButton($shopElement, mobile, container, productId) {
    if ($shopElement.data('productEnabled')) {
      if (mobile) {
        $(container).prepend(template.shopButton(productId));
      } else {
        $(container).append(template.shopButton(productId));
      }
    }
  }

  function formatCurrency(price) {
    var fixed = Number(price).toFixed(2);
    return Number.isNaN(fixed) ? price : '$' + fixed;
  }

  function formatPrices(item) {
    var unit_price = item['unit_list_price'],
        sale_price = item['sale_price'];
    if (unit_price) {
      item['formatted_price'] = formatCurrency(unit_price); // If formatting fails return the original value
    }
    if (sale_price) {
      item['formatted_sale_price'] = formatCurrency(sale_price);
    }
    return item;
  }

  function renderProductList(data) {
    var prodList = data.map(formatPrices).map(template.shopItemDesktop);
    return prodList;
  }

  function setUpAllProds() {
    var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var max = arguments[1];

    var Ids = Object.keys(result);
    if (Ids.length > 0) {
      Ids.forEach(function (itemId) {
        var itemData = result[itemId] && result[itemId]['data'];
        if (itemData && itemData.length && itemData.length > 0) {
          generateProductMarkup(itemData, itemId, false, max);
          debug.log('Set up product data (initial)', itemId);
        }
      });
    }
  }

  function setUpProdData(resultSet, isItem) {
    var manager = productManager,
        item = manager.getProduct(manager.activeProduct),
        data = item && item.data;

    if (data) {
      if (data && data.length && data.length > 0) {
        debug.log('active product', manager.activeProduct);
        debug.log('Product is item', isItem);
        generateProductMarkup(data);
        return true; // return otherwise hide the list
      }
    }
    hideProductList();
  }

  function hideProductList(hideOnMobile) {
    var hideClasses = hideOnMobile ? '' : 'has-Products is-Loaded';
    if (isMobile) {
      // needs to check hideonmobile?
      return false; // Product list is already hidden on mobile
    }
    var $productListElement = $(config.productListContainer);
    $productListElement.removeClass(hideClasses);
  }

  function trackSTLImpression(data) {
    // Concat product names separated by ,; into one string
    function concatProdTitles(str, product) {
      var prodWithVendor = config.vendor + '|' + product.name;
      return str ? str += ',;' + prodWithVendor : prodWithVendor;
    }

    // Format data for tracking
    var metadata = {
      partner: config.vendor,
      title: data.reduce(concatProdTitles, null),
      imagecount: context.getGlobal('mdManager').getParameter('imageCount') || 'n/a',
      productcount: data.length
    };

    // Track data
    shopping.trackProductImpression(metadata);
  }

  function generateProductMarkup(data, activeId, doMobileImpression, max) {
    var html = renderProductList(data),
        $productListElement = void 0,
        $productListTarget = void 0,
        id = activeId || productManager.activeProduct,
        $mobileContainer = void 0,
        index = void 0;
    if (isMobile && id) {
      /*  On mobile we need to target the specific container  */
      $mobileContainer = $('[data-product-id="' + id + '"]');
      index = $mobileContainer.data('card-index');
      if (max && index > max) {
        return; // skip any further loads
      }
      $productListElement = $mobileContainer.find(config.productListContainer);
      $productListTarget = $mobileContainer.find(config.productListTarget);
    } else {
      $productListElement = $(config.productListContainer);
      $productListTarget = $(config.productListTarget);
      $productListTarget.parent().scrollTop(0);
    }

    $productListTarget.html(html);
    $productListElement.addClass('has-Products is-Loaded');
    productManager.addProductShown(id);
  }

  function updateProductList(content, galleryType) {
    var $shopElement = $(content.newElement.context),
        productId = $shopElement.data('productId'),
        productEnabled = $shopElement.data('productEnabled'),
        productImpression = $shopElement.data('mdmImpression'),
        doMobileImpression = false,
        manager = productManager,
        product = void 0,
        isItem = void 0,
        isShown = manager.isProductShown(productId);

    manager.activeProduct = productId;

    if (productId && productEnabled) {
      if (isMobile && isShown) {
        if (productImpression) {
          debug.log(productId + ' is shown.');
          return false; // bail out early on mobile
        } else {
          doMobileImpression = galleryType !== 'curated';
          $shopElement.data('mdmImpression', doMobileImpression); // if it is curated then skip impressions for now.  Add back to scroll
        }
      }
      product = productManager.getAsyncProduct(productId); // return a product or deferred
      isItem = product['singleItem'];
      //   Render/request list
      if (product['received'] && product['data']) {
        debug.log('active product in memory ', product);
        product['$deferred'] = null; // minor cleanup
        var prodData = product['data'];
        if (prodData && prodData.length && prodData.length > 0) {
          generateProductMarkup(product.data, null, doMobileImpression);
          if (!isMobile || isMobile && doMobileImpression) {
            trackSTLImpression(product.data);
          }
        } else {
          hideProductList();
        }
      } else if (product['$deferred']) {
        //  If addSet was called then a deferred will be returned
        $.when(product.$deferred).then(productManager.responseHandler).then(function (data) {
          debug.log('Set up product data (inner)', data);
          setUpProdData(data, isItem); // passing isItem in case we need to test for single item in the future
        }).fail(function (result) {
          debug.log('Unable to retrieve product from Vendor API', manager.activeProduct);
        });
      }
    } else {
      // HIDE Product List
      hideProductList();
    }
  }

  function updateSTLMetadata(content) {
    var $shopElement = $(content.newElement.context),
        $elementContainer = void 0,
        partnerTag = config.partnerText,
        mdmData = void 0,
        metadata = {},
        taggroup = void 0;

    if (content.type && content.type === 'dynamic') {
      $elementContainer = $(content.newElement);
    } else {
      $elementContainer = $(content.newElement).find(config.shopInsertionSelector);
    }

    if (!$elementContainer.length) {
      debug.error('updateSTLMetadata: $elementContainer is empty');
    }

    if ($shopElement.data('productEnabled')) {
      mdmData = $elementContainer.data('mdm');
      if (overlayType === 'mobile-scroll' && content.type && content.type === 'dynamic') {
        mdmData = mdmData || '';
      } else {
        mdmData = mdmData || $elementContainer.parents(config.shoppableElement).data('mdm');
      }
      try {
        metadata = JSON.parse(mdmData);
      } catch (e) {
        debug.log('Could not parse Photo metadata');
      }
      debug.log('updateSTLMetadata: metadata: ', metadata);
      taggroup = metadata.TagGroup1;
      if (typeof taggroup !== 'undefined' && !taggroup.includes(partnerTag)) {
        taggroup = partnerTag + ',' + taggroup;
        metadata.TagGroup1 = taggroup;
        if (overlayType === 'mobile-scroll' && content.type && content.type === 'dynamic') {
          $elementContainer.data('mdm', JSON.stringify(metadata));
        } else {
          $elementContainer.parents(config.shoppableElement).data('mdm', JSON.stringify(metadata));
        }
      }
    }
  }

  function setupClickTracking(analyticsService, currentSelector, currentNamespace) {
    analyticsService.attachClickTracking({
      selector: currentSelector,
      namespace: currentNamespace
    });
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {

    messages: ['shopElementChanged', 'contentUpdated', 'stl.updateClickTracking'],

    init: function init() {
      deviceType = context.getService('device-type');
      template = context.getService('template');
      analytics = context.getService('analytics');
      debug = context.getService('logger').create('behavior.shop-this-look');
      config = Object.assign({}, defaults, context.getConfig('shop-this-look'));
      dynamicGalleryType = context.getConfig('galleryType');
      productManager = context.getService('product-manager');
      shopping = context.getService('track-shopping');
      debug.log('config: ', config);
      isMobile = deviceType.isMobile;
      isTablet = deviceType.isTablet;
      productManager.updateConfig({
        endpoint: config.vendorAPI,
        vendor: config.vendorCode,
        productsInSet: config.productsInSet
      });
      shop();
      overlayType = getGalleryType();
      analyticsContainer = config.dynamicSTL ? config.productListTarget : config.shopInsertionSelector;
      setupClickTracking(analytics, analyticsContainer, config.shopNamespace);
    },
    destroy: function destroy() {
      removeOverlay(overlayType, config.shopOverlayClass, config.overlayCloseEventName, config.container);
    },
    onclick: function onclick(event, element, elementType) {
      switch (elementType) {
        case 'open-shop-overlay-btn':
          var prodID = $(element).data('productId');
          shopOverlay = template.shopOverlay(isMobile, prodID);
          createOverlay(context, prodID, shopOverlay, overlayType, isMobile, config.shopOverlayClass, config.closeOverlaySel, config.overlayCloseEventName, config.productHeaderSelector, config.container);
          break;
        case 'close-shop-overlay-btn':
          removeOverlay(overlayType, config.shopOverlayClass, config.overlayCloseEventName, config.container);
          break;
      }
    },
    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'shopElementChanged':
          if (config.dynamicSTL) {
            updateProductList(data, '');
          }
          updateSTLMetadata(data);
          break;
        case 'contentUpdated':
          var prodId = $(data.newContent).data('productId');
          if (config.dynamicSTL) {
            productManager.addSet(prodId); // only adding one but should add a set
          } else {
            addShopButton($(data.newContent), isMobile, $(data.newContent).find(config.shopInsertionSelector), $(data.newContent).data('productId'));
          }
          break;
        case 'stl.updateClickTracking':
          var sel = config.dynamicSTL ? analyticsContainer : data.sel;
          setupClickTracking(analytics, sel, config.shopNamespace);
          break;
      }
    }
  };
});

/***/ }),
/* 417 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('social-pinterest', function (context) {

  var config = void 0,
      pinScriptReady = void 0;
  var $element = $(context.getElement());
  var debug = context.getService('logger').create('module.social-pinterest');
  var check = context.getService('check').new(debug);
  var deviceType = context.getService('device-type');
  var templates = context.getService('template');
  var defaults = {
    pageURL: window.location.href,
    description: $('meta[property="og:description"]').attr('content'),
    addWhere: 'append',
    position: 'top left',
    imageURL: false,
    insertToChild: false,
    useNewLogo: false,
    img: '//assets.pinterest.com/images/pidgets/pinit_fg_en_rect_gray_28.png',
    pinRound: false
  };

  config = Object.assign({}, defaults, context.getConfig('social-pinterest'));

  if (!check.exists('PinUtils')) {
    debug.log('start loading Pinit js');
    // TODO: Move to separate service across all Pinterest functionality
    pinScriptReady = $.getScript('//assets.pinterest.com/js/pinit.js').done(function (script, textStatus) {
      debug.log('Pinit js loaded! It was a ' + textStatus);
    }).fail(function () {
      debug.log('Pinit js error!');
    });
  } else {
    pinScriptReady = $.Deferred();
    pinScriptReady.resolve();
  }

  function setPinButton(data) {
    var $slide = void 0;
    var pinitElement = void 0;
    var proceed = data.hasOwnProperty('proceed') ? data.proceed : true;

    if (proceed) {
      pinitElement = templates.socialPinterest({
        media: encodeURIComponent(data.imageURL),
        url: encodeURIComponent(config.pageURL),
        description: encodeURIComponent(config.description),
        img: config.img,
        useNewLogo: config.useNewLogo,
        pinRound: config.pinRound,
        position: config.position
      });

      $slide = data.element ? $element.find(data.element).find(config.insertToChild) : $element.find(config.insertToChild);

      // ----------------------------------------------------------
      if ($slide.size > 0 || deviceType.isMobile) {
        addButton($slide, pinitElement);
      } else {
        var targetNode = document.getElementById($element[0].id);
        var obsConfig = {
          childList: true,
          subtree: true
        };

        var obsCallback = function obsCallback(mutations) {
          var $updatedSlide = data.element ? $element.find(data.element).find(config.insertToChild) : $element.find(config.insertToChild);
          if ($updatedSlide.size() > 0) {
            addButton($updatedSlide, pinitElement);
            this.disconnect();
          }
        };

        var observer = new MutationObserver(obsCallback);
        if (targetNode) {
          observer.observe(targetNode, obsConfig);
        } else {
          debug.warn('Unable to observe targetNode: ', targetNode);
        }
      }
      // ----------------------------------------------------------
    }
  }

  function addButton(slide, pinitElement) {
    slide.remove('[data-type="pin-element"]');

    /* Add Pinit button(anchor) to the element */
    if (slide.data('processed') !== true) {
      if (config.addWhere === 'prepend') {
        slide.prepend(pinitElement);
      } else {
        slide.append(pinitElement);
      }
      slide.attr('data-processed', true);
    }

    // Set event handlers for the newly created button
    // https://github.com/pinterest/widgets/blob/master/pinit_main.js
    if (check.exists('PinUtils')) {
      context.getGlobal('PinUtils').build();
    }
  }

  return {
    messages: ['gallery.ImageUpdate', 'gallery.directPin'],
    config: config,
    init: function init() {
      debug.log('config', config);
      if (!$element) {
        debug.error('No elements provided to put Pinit buttons into.');
        return false;
      }
    },
    onmessage: function onmessage(name, data) {
      //debug.log(name, data);
      switch (name) {
        case 'gallery.directPin':
        case 'gallery.ImageUpdate':
          pinScriptReady.then(function () {
            setPinButton(data);
          });
          break;
      }
    }
  };
});

/***/ }),
/* 418 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('tab', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var $element = $(context.getElement());
  var activeClass = 'is-Active';
  var debug = context.getService('logger').create('behavior.tab');
  var check = context.getService('check').new(debug);

  /* ========================================================================
   * Bootstrap: tab.js v3.1.1
   * http://getbootstrap.com/javascript/#tabs
   * ========================================================================
   * Copyright 2011-2014 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  var _registerPlugin = function _registerPlugin($) {

    var Tab = function Tab(element) {
      this.element = $(element);
    };

    Tab.prototype.show = function ($elt) {
      var $ul = $elt.closest('ul:not(.dropdown-menu)');
      var selector = $elt.data('target');

      if (!selector) {
        selector = $elt.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); //strip for ie7
      }

      if ($elt.parent('li').hasClass(activeClass)) return;

      var previous = $ul.find('.' + activeClass + ':last a')[0];

      var $target = $(selector);

      this.activate($elt.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $elt.trigger({
          type: 'tab.shown',
          relatedTarget: previous
        });
      });
    };

    Tab.prototype.activate = function (element, container, callback) {
      var $active = container.find('> .' + activeClass);
      var transition = callback && check.jqueryPlugin('emulateTransitionEnd') && $.support.transition && $active.hasClass('fade');

      function next() {
        $active.removeClass(activeClass).find('> .dropdown-menu > .' + activeClass).removeClass(activeClass);

        element.addClass(activeClass);

        if (transition) {
          element[0].offsetWidth; // reflow for transition
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }

        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass(activeClass);
        }

        callback && callback();
      }

      transition ? $active.one($.support.transition.end, next).emulateTransitionEnd(150) : next();

      $active.removeClass('in');
    };

    var old = $.fn.tab;
    $.fn.tab = function (option, $elt) {
      var data = $element.data('bs.tab');
      if (!data) $element.data('bs.tab', data = new Tab(this));
      if (typeof option === 'string') data[option]($elt);
    };

    $.fn.tab.Constructor = Tab;

    // TAB NO CONFLICT
    // ===============
    $.fn.tab.noConflict = function () {
      $.fn.tab = old;
      return this;
    };
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  var init = function init() {
    if (!$.fn.tab) {
      _registerPlugin($);
    }
  };

  var onclick = function onclick(evt, elt, eltType) {
    if (!check.jqueryPlugin('tab')) return;
    if (eltType === 'tab-ctrl') {
      evt.preventDefault();
      $element.tab('show', $(elt));
    }
  };

  return {

    init: init,

    onclick: onclick

  };
});

/***/ }),
/* 419 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('theme-selector', function (context) {
  var debug = context.getService('logger').create('behavior.theme-selector');
  var util = context.getService('utility');
  var device = context.getService('device-type');

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var selectBoxName = 'sni-theme-selector-theme-sel';
  var $fonts = $('link[data-sni-css-fonts]');
  var $v2Css = $('link[data-sni-css-v2]');
  var v2Css = $v2Css.attr('href');
  var initialBrand = $v2Css.attr('data-sni-css-v2');

  if (!$v2Css.length) {
    debug.warn('cannot find v2 css in the page.  aborting.');
    return;
  }

  var themes = {
    'white-label': 'White Label',
    'hgtv': 'HGTV',
    'diy': 'DIY Network',
    'gac': 'Great American Country',
    'food': 'Food Network',
    'cctv': 'Cooking Channel',
    'travel': 'Travel Channel'
  };

  var queryString = util.getUrlParam(window.location.href, 'themeSelect');
  var existingTheme = queryString ? queryString : localStorage.getItem('theme');

  if (themes[initialBrand]) {
    themes[initialBrand] = themes[initialBrand] + ' (page default)';
  }

  function loadCss($el, uri, callback, fonts) {
    var $link = $el.clone().attr('href', uri).on('load', function () {
      $el.remove();
      if (fonts) {
        $fonts = $link;
      } else {
        $v2Css = $link;
      }
      if (typeof callback === 'function') {
        callback();
      }
    }).on('error', function () {
      $link.remove();
      alert('Could not load:\n ' + (window.location.protocol + '//' + window.location.hostname + uri));
    }).each(function () {
      if (this.complete) $link.trigger('load');
    }).insertAfter($el);
  }

  function setStyleSheet(brandName) {
    function cssPath(brand) {
      return '/v2/css/' + brand;
    }
    function getNewCssPath(oldBrand, newBrand) {
      var output = '';
      if (newBrand === 'white-label') {
        output = cssPath(newBrand) + '-' + (device.isMobile ? 'mobile' : 'desktop') + '.css';
      } else {
        var re = RegExp(cssPath(oldBrand) + '(.*)\.css', 'g');
        output = v2Css.replace(re, cssPath(newBrand) + '$1.css');
        output = output.replace('-rest.css', '.css'); //support critical styles properly
      }
      return output;
    }
    var themeStyle = getNewCssPath(initialBrand, brandName);
    if (util.getUrlParam(window.location.href, 'bust')) {
      themeStyle = themeStyle + (themeStyle.indexOf('?') !== -1 ? '&' : '?') + 'bust=' + new Date().getTime();
    }
    if ($fonts.length) {
      var thisFont = $fonts.attr('href').replace(/[^\/]*\-fonts\./g, brandName + '-fonts.');
      loadCss($fonts, thisFont, false, true);
    }
    loadCss($v2Css, themeStyle, function () {
      debugActive();
      $('[data-sni-css-critical]').remove();
      lazyLoadHelper($v2Css[0]);
      context.broadcast('theme-changed', { theme: brandName });
    });
  }

  function isHomeBrand(brand) {
    return brand === 'hgtv' || brand === 'diy' || brand === 'gac';
  }

  function debugActive() {
    setTimeout(function () {
      var $activeSheets = $('link[rel=stylesheet]:not([href*="about:"])');
      debug.log($activeSheets.length + ' active stylesheets:');
      $activeSheets.each(function () {
        debug.log('      ' + $(this).attr('href'));
      });
    }, 1);
  }

  //needed because of all the weird shifting around that happens during page load when using the theme selector
  function lazyLoadHelper(linkEl) {
    var fi = setInterval(function () {
      try {
        linkEl.sheet.cssRules;
        debug.log('triggering scroll for lazy load fix');
        $(window).trigger('scroll resize');
        clearInterval(fi);
      } catch (e) {
        return;
      }
    }, 10);
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  function init() {
    if (context.getGlobal('cqWCMDisabled') || context.getGlobal('cqWCMshowThemeSelector')) {
      insert([createSel()]);
    } else {
      debug.log('disabled in author mode');
    }
  }

  function createSel() {
    var selector = document.createElement('select');
    $(selector).on('change', function () {
      var selectedValue = this.options[this.options.selectedIndex].value;
      localStorage.setItem('theme', selectedValue);
      setStyleSheet(selectedValue);
    });

    var _loop = function _loop(key) {
      var value = themes[key];
      var option = document.createElement('option');
      option.setAttribute('value', key);
      if (key === existingTheme) {
        option.setAttribute('selected', 'selected');
        setTimeout(function () {
          setStyleSheet(key);
        }, 2000);
      }
      option.appendChild(document.createTextNode(value));
      selector.appendChild(option);
    };

    for (var key in themes) {
      _loop(key);
    }
    return $(selector).addClass(selectBoxName).css({
      'width': 220,
      marginRight: 12,
      padding: 3,
      font: '15px Arial',
      background: 'white',
      border: '1px solid gray',
      outline: 'none'
    })[0];
  }

  function insert(items) {
    var container = document.createElement('div');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        if (item) {
          container.appendChild(item);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    $(container).css({
      position: 'fixed',
      top: 0,
      right: 0,
      padding: 8,
      zIndex: 9999999999,
      background: 'white',
      boxShadow: '0 0 7px rgba(0,0,0,.4)',
      width: '100%'
    }).prependTo('body');

    if (queryString) {
      if (isHomeBrand(existingTheme)) {
        setStyleSheet(existingTheme);
      }
      $(container).hide();
    }

    $('.' + selectBoxName).val(localStorage.getItem('theme') || initialBrand);

    if (!queryString) {
      //prevent from visually covering the top part of the page
      $('body').css({ marginTop: $(container).outerHeight() });
    }
  }

  return {
    init: init
  };
});

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(135);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 421 */
/***/ (function(module, exports) {

/**
  * Toggle Proxy
  * Author: jpencola
  * This utility allows you to take element A (proxy) and have it toggle a
  * classname on element B (toggle) based on an event.
  * This allows for a basic wrapper around jQuery's toggleClass
  * with capability of a dis-jointed toggle and other
  * features like "hover intent" through the `toggleDelay` setting.
  * -------------------------------------------------------------
  * Broadcasts:
  *   toggledOn
  *   toggledOff
  */

SNI.Application.addBehavior('toggle-proxy', function (context) {

  // let _supports = {}; //private cache of feature support
  var debug = context.getService('logger').create('service.toggle-proxy');
  var $element = $(context.getElement());
  var $proxyEl = void 0,
      $targetEl = void 0;

  var defaults = {
    toggleID: null,
    toggleState: 0, // the current state of the toggle. 0 = off, 1 = on
    toggleDelay: 0, // the delay in ms before the proxy will trigger the toggling
    proxySelector: false, // $selector for 1-many nodes that cause the toggling (defaults to module target)
    targetSelector: '.toggleable', // $selector for 1-many target nodes that will be toggled
    toggleOnEvent: 'mouseenter.tog', // the namespaced event the proxy element is bound to, which triggers toggling-on of the target
    toggleOffEvent: 'mouseleave.tog', // the namespaced event the proxy element is bound to, which triggers toggling-off of the target
    offClassname: 'toggledOff', // the classname the target is given when toggled-off
    onClassname: 'toggledOn' // the classname the target is given when toggled-on
  };
  var config = Object.assign({}, defaults, context.getConfig('toggleProxy'));

  function init() {

    debug.log('toggle-proxy init');

    $proxyEl = config.proxySelector ? $element.find(config.proxySelector) : $element;
    $targetEl = $element.find(config.targetSelector);

    config.toggleID = $element.attr('id');

    if (config.toggleDelay) config.toggleDelay = 100; // this has been VERY carefully chosen by design. Don't screw it up.
    if ($targetEl.length === 0) $targetEl = $element; // when targetEl isn't found, module & target are the same

    unbindEvents();
    bindEvents();
  }

  function unbindEvents() {
    $proxyEl.off(config.toggleOnEvent);
    $proxyEl.off(config.toggleOffEvent);
  }

  function bindEvents() {

    // When the on and off events are the same, we only bind once
    var bindSingle = config.toggleOnEvent === config.toggleOffEvent;
    $proxyEl.each(function () {
      if (bindSingle) {
        $(this).on(config.toggleOnEvent, function () {
          toggle();
        });
      } else {
        $(this).on(config.toggleOnEvent, function () {
          toggleOn();
        });
        $(this).on(config.toggleOffEvent, function () {
          toggleOff();
        });
      }
    });
  }

  // Calls to this method will manage toggle between on/off for you
  function toggle() {
    if (config.toggleState) {
      toggleOff();
    } else {
      toggleOn();
    }
  }

  // Explicitly toggles ON
  function toggleOn() {

    clearTimeout($(this).data('timerId'));

    var timerId = setTimeout(function () {
      config.toggleState = 1;
      $proxyEl.removeClass(config.offClassname).addClass(config.onClassname);
      $targetEl.removeClass(config.offClassname).addClass(config.onClassname);
      context.broadcast('toggledOn', config.toggleID);
    }, config.toggleDelay);

    $(this).data('timerId', timerId);
  }

  // Explicitly toggles OFF
  function toggleOff() {

    clearTimeout($(this).data('timerId'));

    config.toggleState = 0;
    $proxyEl.removeClass(config.onClassname).addClass(config.offClassname);
    $targetEl.removeClass(config.onClassname).addClass(config.offClassname);
    context.broadcast('toggledOff', config.toggleID);
  }

  return {

    init: init,
    toggle: toggle,
    toggleOn: toggleOn,
    toggleOff: toggleOff

  };
});

/***/ }),
/* 422 */
/***/ (function(module, exports) {

SNI.Application.addBehavior('track-shopping', function (context) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  var $element = void 0,
      $shoppingModules = void 0,
      config = void 0;

  var modUtil = context.getService('utility'),
      debug = context.getService('logger').create('behavior.track-shopping'),
      shopping = context.getService('track-shopping'),
      defaults = {
    carouselSelector: '.m-Carousel',
    activeClass: '.active',
    inspirationOrganism: 'o-InspirationalProduct',
    productListBodySelector: '.o-ProductList__m-Body'
  };

  function updateObject(existing, updated) {
    return Object.assign({}, existing, updated);
  }

  function setConfig(oldSettings, newSettings) {
    config = updateObject(oldSettings, newSettings);
  }

  function getMetaData(el) {
    var $el = $(el),
        metadata1 = $el.data('mdm') || {},
        metadata2 = {};

    if (!$el.find('[data-module="carousel"]').length) {
      metadata2 = $(config.carouselSelector, el).find('[data-mdm]').data('mdm');
    } else {
      metadata2 = $el.find('[data-module="carousel"]').find(config.activeClass).find('[data-mdm]').data('mdm');
    }

    return updateObject(metadata1, metadata2);
  }

  function trackProductDisplayOnScroll() {
    $shoppingModules.each(function (i, el) {
      var trackedEl = el.className.includes(config.inspirationOrganism) ? $(el).find(config.productListBodySelector)[0] : el;
      var inView = modUtil.isInViewport(trackedEl, 'partial');

      if (inView) {
        var metadata = getMetaData(el);

        shopping.trackProductImpression(metadata);

        $shoppingModules = $shoppingModules.not($(el));

        $(el).attr('data-viewed', 1);
      }
    });
  }

  function getShoppingModules($context) {
    $shoppingModules = $context.find('[data-module="shopping"],[data-module="shopping-embed"]').not('[data-viewed="1"]');
  }

  function init() {
    debug.log('init');

    var handler = modUtil.throttle(trackProductDisplayOnScroll, 100);

    $element = $(context.getElement());
    setConfig(defaults, context.getConfig());

    if ($element.has('[data-module|="shopping"]').length) {
      getShoppingModules($element);

      $(window).on('scroll.shopping', handler);
    }
  }

  //-----------------------------------------------------------
  // Public API
  //-----------------------------------------------------------

  return {
    messages: ['scroll-tracker.viewed'],

    init: init,

    onmessage: function onmessage(name, data) {
      switch (name) {
        case 'scroll-tracker.viewed':
          if ($element.has('[data-module|="shopping"]').length) {
            getShoppingModules($element);
          }
          break;
      }
    }
  };
});

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! Kefir.js v3.7.4
 *  https://github.com/rpominov/kefir
 */

(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Kefir = global.Kefir || {})));
}(this, (function (exports) { 'use strict';

function createObj(proto) {
  var F = function () {};
  F.prototype = proto;
  return new F();
}

function extend(target /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0,
      prop = void 0;
  for (i = 1; i < length; i++) {
    for (prop in arguments[i]) {
      target[prop] = arguments[i][prop];
    }
  }
  return target;
}

function inherit(Child, Parent /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0;
  Child.prototype = createObj(Parent.prototype);
  Child.prototype.constructor = Child;
  for (i = 2; i < length; i++) {
    extend(Child.prototype, arguments[i]);
  }
  return Child;
}

var NOTHING = ['<nothing>'];
var END = 'end';
var VALUE = 'value';
var ERROR = 'error';
var ANY = 'any';

function concat(a, b) {
  var result = void 0,
      length = void 0,
      i = void 0,
      j = void 0;
  if (a.length === 0) {
    return b;
  }
  if (b.length === 0) {
    return a;
  }
  j = 0;
  result = new Array(a.length + b.length);
  length = a.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = a[i];
  }
  length = b.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = b[i];
  }
  return result;
}

function find(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (arr[i] === value) {
      return i;
    }
  }
  return -1;
}

function findByPred(arr, pred) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
}

function cloneArray(input) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = input[i];
  }
  return result;
}

function remove(input, index) {
  var length = input.length,
      result = void 0,
      i = void 0,
      j = void 0;
  if (index >= 0 && index < length) {
    if (length === 1) {
      return [];
    } else {
      result = new Array(length - 1);
      for (i = 0, j = 0; i < length; i++) {
        if (i !== index) {
          result[j] = input[i];
          j++;
        }
      }
      return result;
    }
  } else {
    return input;
  }
}

function map(input, fn) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = fn(input[i]);
  }
  return result;
}

function forEach(arr, fn) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    fn(arr[i]);
  }
}

function fillArray(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    arr[i] = value;
  }
}

function contains(arr, value) {
  return find(arr, value) !== -1;
}

function slide(cur, next, max) {
  var length = Math.min(max, cur.length + 1),
      offset = cur.length - length + 1,
      result = new Array(length),
      i = void 0;
  for (i = offset; i < length; i++) {
    result[i - offset] = cur[i];
  }
  result[length - 1] = next;
  return result;
}

function callSubscriber(type, fn, event) {
  if (type === ANY) {
    fn(event);
  } else if (type === event.type) {
    if (type === VALUE || type === ERROR) {
      fn(event.value);
    } else {
      fn();
    }
  }
}

function Dispatcher() {
  this._items = [];
  this._spies = [];
  this._inLoop = 0;
  this._removedItems = null;
}

extend(Dispatcher.prototype, {
  add: function (type, fn) {
    this._items = concat(this._items, [{ type: type, fn: fn }]);
    return this._items.length;
  },
  remove: function (type, fn) {
    var index = findByPred(this._items, function (x) {
      return x.type === type && x.fn === fn;
    });

    // if we're currently in a notification loop,
    // remember this subscriber was removed
    if (this._inLoop !== 0 && index !== -1) {
      if (this._removedItems === null) {
        this._removedItems = [];
      }
      this._removedItems.push(this._items[index]);
    }

    this._items = remove(this._items, index);
    return this._items.length;
  },
  addSpy: function (fn) {
    this._spies = concat(this._spies, [fn]);
    return this._spies.length;
  },


  // Because spies are only ever a function that perform logging as
  // their only side effect, we don't need the same complicated
  // removal logic like in remove()
  removeSpy: function (fn) {
    this._spies = remove(this._spies, this._spies.indexOf(fn));
    return this._spies.length;
  },
  dispatch: function (event) {
    this._inLoop++;
    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
      spies[i](event);
    }

    for (var _i = 0, items = this._items; _i < items.length; _i++) {
      // cleanup was called
      if (this._items === null) {
        break;
      }

      // this subscriber was removed
      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
        continue;
      }

      callSubscriber(items[_i].type, items[_i].fn, event);
    }
    this._inLoop--;
    if (this._inLoop === 0) {
      this._removedItems = null;
    }
  },
  cleanup: function () {
    this._items = null;
    this._spies = null;
  }
});

function Observable() {
  this._dispatcher = new Dispatcher();
  this._active = false;
  this._alive = true;
  this._activating = false;
  this._logHandlers = null;
  this._spyHandlers = null;
}

extend(Observable.prototype, {
  _name: 'observable',

  _onActivation: function () {},
  _onDeactivation: function () {},
  _setActive: function (active) {
    if (this._active !== active) {
      this._active = active;
      if (active) {
        this._activating = true;
        this._onActivation();
        this._activating = false;
      } else {
        this._onDeactivation();
      }
    }
  },
  _clear: function () {
    this._setActive(false);
    this._dispatcher.cleanup();
    this._dispatcher = null;
    this._logHandlers = null;
  },
  _emit: function (type, x) {
    switch (type) {
      case VALUE:
        return this._emitValue(x);
      case ERROR:
        return this._emitError(x);
      case END:
        return this._emitEnd();
    }
  },
  _emitValue: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: VALUE, value: value });
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: ERROR, value: value });
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      this._dispatcher.dispatch({ type: END });
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    } else {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  _off: function (type, fn) {
    if (this._alive) {
      var count = this._dispatcher.remove(type, fn);
      if (count === 0) {
        this._setActive(false);
      }
    }
    return this;
  },
  onValue: function (fn) {
    return this._on(VALUE, fn);
  },
  onError: function (fn) {
    return this._on(ERROR, fn);
  },
  onEnd: function (fn) {
    return this._on(END, fn);
  },
  onAny: function (fn) {
    return this._on(ANY, fn);
  },
  offValue: function (fn) {
    return this._off(VALUE, fn);
  },
  offError: function (fn) {
    return this._off(ERROR, fn);
  },
  offEnd: function (fn) {
    return this._off(END, fn);
  },
  offAny: function (fn) {
    return this._off(ANY, fn);
  },
  observe: function (observerOrOnValue, onError, onEnd) {
    var _this = this;
    var closed = false;

    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;

    var handler = function (event) {
      if (event.type === END) {
        closed = true;
      }
      if (event.type === VALUE && observer.value) {
        observer.value(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.end) {
        observer.end(event.value);
      }
    };

    this.onAny(handler);

    return {
      unsubscribe: function () {
        if (!closed) {
          _this.offAny(handler);
          closed = true;
        }
      },

      get closed() {
        return closed;
      }
    };
  },


  // A and B must be subclasses of Stream and Property (order doesn't matter)
  _ofSameType: function (A, B) {
    return A.prototype.getType() === this.getType() ? A : B;
  },
  setName: function (sourceObs /* optional */, selfName) {
    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
    return this;
  },
  log: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var isCurrent = void 0;
    var handler = function (event) {
      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };

    if (this._alive) {
      if (!this._logHandlers) {
        this._logHandlers = [];
      }
      this._logHandlers.push({ name: name, handler: handler });
    }

    isCurrent = true;
    this.onAny(handler);
    isCurrent = false;

    return this;
  },
  offLog: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._logHandlers) {
      var handlerIndex = findByPred(this._logHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this.offAny(this._logHandlers[handlerIndex].handler);
        this._logHandlers.splice(handlerIndex, 1);
      }
    }

    return this;
  },
  spy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var handler = function (event) {
      var type = '<' + event.type + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };
    if (this._alive) {
      if (!this._spyHandlers) {
        this._spyHandlers = [];
      }
      this._spyHandlers.push({ name: name, handler: handler });
      this._dispatcher.addSpy(handler);
    }
    return this;
  },
  offSpy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._spyHandlers) {
      var handlerIndex = findByPred(this._spyHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
        this._spyHandlers.splice(handlerIndex, 1);
      }
    }
    return this;
  }
});

// extend() can't handle `toString` in IE8
Observable.prototype.toString = function () {
  return '[' + this._name + ']';
};

function Stream() {
  Observable.call(this);
}

inherit(Stream, Observable, {
  _name: 'stream',

  getType: function () {
    return 'stream';
  }
});

function Property() {
  Observable.call(this);
  this._currentEvent = null;
}

inherit(Property, Observable, {
  _name: 'property',

  _emitValue: function (value) {
    if (this._alive) {
      this._currentEvent = { type: VALUE, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: VALUE, value: value });
      }
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._currentEvent = { type: ERROR, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: ERROR, value: value });
      }
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      if (!this._activating) {
        this._dispatcher.dispatch({ type: END });
      }
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    }
    if (this._currentEvent !== null) {
      callSubscriber(type, fn, this._currentEvent);
    }
    if (!this._alive) {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  getType: function () {
    return 'property';
  }
});

var neverS = new Stream();
neverS._emitEnd();
neverS._name = 'never';

function never() {
  return neverS;
}

function timeBased(mixin) {
  function AnonymousStream(wait, options) {
    var _this = this;

    Stream.call(this);
    this._wait = wait;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._onTick();
    };
    this._init(options);
  }

  inherit(AnonymousStream, Stream, {
    _init: function () {},
    _free: function () {},
    _onTick: function () {},
    _onActivation: function () {
      this._intervalId = setInterval(this._$onTick, this._wait);
    },
    _onDeactivation: function () {
      if (this._intervalId !== null) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    },
    _clear: function () {
      Stream.prototype._clear.call(this);
      this._$onTick = null;
      this._free();
    }
  }, mixin);

  return AnonymousStream;
}

var S = timeBased({
  _name: 'later',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
    this._emitEnd();
  }
});

function later(wait, x) {
  return new S(wait, { x: x });
}

var S$1 = timeBased({
  _name: 'interval',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
  }
});

function interval(wait, x) {
  return new S$1(wait, { x: x });
}

var S$2 = timeBased({
  _name: 'sequentially',

  _init: function (_ref) {
    var xs = _ref.xs;

    this._xs = cloneArray(xs);
  },
  _free: function () {
    this._xs = null;
  },
  _onTick: function () {
    if (this._xs.length === 1) {
      this._emitValue(this._xs[0]);
      this._emitEnd();
    } else {
      this._emitValue(this._xs.shift());
    }
  }
});

function sequentially(wait, xs) {
  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
}

var S$3 = timeBased({
  _name: 'fromPoll',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _onTick: function () {
    var fn = this._fn;
    this._emitValue(fn());
  }
});

function fromPoll(wait, fn) {
  return new S$3(wait, { fn: fn });
}

function emitter(obs) {
  function value(x) {
    obs._emitValue(x);
    return obs._active;
  }

  function error(x) {
    obs._emitError(x);
    return obs._active;
  }

  function end() {
    obs._emitEnd();
    return obs._active;
  }

  function event(e) {
    obs._emit(e.type, e.value);
    return obs._active;
  }

  return {
    value: value,
    error: error,
    end: end,
    event: event,

    // legacy
    emit: value,
    emitEvent: event
  };
}

var S$4 = timeBased({
  _name: 'withInterval',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._fn = null;
    this._emitter = null;
  },
  _onTick: function () {
    var fn = this._fn;
    fn(this._emitter);
  }
});

function withInterval(wait, fn) {
  return new S$4(wait, { fn: fn });
}

function S$5(fn) {
  Stream.call(this);
  this._fn = fn;
  this._unsubscribe = null;
}

inherit(S$5, Stream, {
  _name: 'stream',

  _onActivation: function () {
    var fn = this._fn;
    var unsubscribe = fn(emitter(this));
    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;

    // fix https://github.com/rpominov/kefir/issues/35
    if (!this._active) {
      this._callUnsubscribe();
    }
  },
  _callUnsubscribe: function () {
    if (this._unsubscribe !== null) {
      this._unsubscribe();
      this._unsubscribe = null;
    }
  },
  _onDeactivation: function () {
    this._callUnsubscribe();
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._fn = null;
  }
});

function stream(fn) {
  return new S$5(fn);
}

function fromCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (x) {
        emitter.emit(x);
        emitter.end();
      });
      called = true;
    }
  }).setName('fromCallback');
}

function fromNodeCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (error, x) {
        if (error) {
          emitter.error(error);
        } else {
          emitter.emit(x);
        }
        emitter.end();
      });
      called = true;
    }
  }).setName('fromNodeCallback');
}

function spread(fn, length) {
  switch (length) {
    case 0:
      return function () {
        return fn();
      };
    case 1:
      return function (a) {
        return fn(a[0]);
      };
    case 2:
      return function (a) {
        return fn(a[0], a[1]);
      };
    case 3:
      return function (a) {
        return fn(a[0], a[1], a[2]);
      };
    case 4:
      return function (a) {
        return fn(a[0], a[1], a[2], a[3]);
      };
    default:
      return function (a) {
        return fn.apply(null, a);
      };
  }
}

function apply(fn, c, a) {
  var aLength = a ? a.length : 0;
  if (c == null) {
    switch (aLength) {
      case 0:
        return fn();
      case 1:
        return fn(a[0]);
      case 2:
        return fn(a[0], a[1]);
      case 3:
        return fn(a[0], a[1], a[2]);
      case 4:
        return fn(a[0], a[1], a[2], a[3]);
      default:
        return fn.apply(null, a);
    }
  } else {
    switch (aLength) {
      case 0:
        return fn.call(c);
      default:
        return fn.apply(c, a);
    }
  }
}

function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {
  return stream(function (emitter) {
    var handler = transformer ? function () {
      emitter.emit(apply(transformer, this, arguments));
    } : function (x) {
      emitter.emit(x);
    };

    sub(handler);
    return function () {
      return unsub(handler);
    };
  }).setName('fromSubUnsub');
}

var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];

function fromEvents(target, eventName, transformer) {
  var sub = void 0,
      unsub = void 0;

  for (var i = 0; i < pairs.length; i++) {
    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
      sub = pairs[i][0];
      unsub = pairs[i][1];
      break;
    }
  }

  if (sub === undefined) {
    throw new Error("target don't support any of " + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
  }

  return fromSubUnsub(function (handler) {
    return target[sub](eventName, handler);
  }, function (handler) {
    return target[unsub](eventName, handler);
  }, transformer).setName('fromEvents');
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P(value) {
  this._currentEvent = { type: 'value', value: value, current: true };
}

inherit(P, Property, {
  _name: 'constant',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constant(x) {
  return new P(x);
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P$1(value) {
  this._currentEvent = { type: 'error', value: value, current: true };
}

inherit(P$1, Property, {
  _name: 'constantError',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constantError(x) {
  return new P$1(x);
}

function createConstructor(BaseClass, name) {
  return function AnonymousObservable(source, options) {
    var _this = this;

    BaseClass.call(this);
    this._source = source;
    this._name = source._name + '.' + name;
    this._init(options);
    this._$handleAny = function (event) {
      return _this._handleAny(event);
    };
  };
}

function createClassMethods(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handleValue: function (x) {
      this._emitValue(x);
    },
    _handleError: function (x) {
      this._emitError(x);
    },
    _handleEnd: function () {
      this._emitEnd();
    },
    _handleAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleValue(event.value);
        case ERROR:
          return this._handleError(event.value);
        case END:
          return this._handleEnd();
      }
    },
    _onActivation: function () {
      this._source.onAny(this._$handleAny);
    },
    _onDeactivation: function () {
      this._source.offAny(this._$handleAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._source = null;
      this._$handleAny = null;
      this._free();
    }
  };
}

function createStream(name, mixin) {
  var S = createConstructor(Stream, name);
  inherit(S, Stream, createClassMethods(Stream), mixin);
  return S;
}

function createProperty(name, mixin) {
  var P = createConstructor(Property, name);
  inherit(P, Property, createClassMethods(Property), mixin);
  return P;
}

var P$2 = createProperty('toProperty', {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._getInitialCurrent = fn;
  },
  _onActivation: function () {
    if (this._getInitialCurrent !== null) {
      var getInitial = this._getInitialCurrent;
      this._emitValue(getInitial());
    }
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  }
});

function toProperty(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (fn !== null && typeof fn !== 'function') {
    throw new Error('You should call toProperty() with a function or no arguments.');
  }
  return new P$2(obs, { fn: fn });
}

var S$6 = createStream('changes', {
  _handleValue: function (x) {
    if (!this._activating) {
      this._emitValue(x);
    }
  },
  _handleError: function (x) {
    if (!this._activating) {
      this._emitError(x);
    }
  }
});

function changes(obs) {
  return new S$6(obs);
}

function fromPromise(promise) {
  var called = false;

  var result = stream(function (emitter) {
    if (!called) {
      var onValue = function (x) {
        emitter.emit(x);
        emitter.end();
      };
      var onError = function (x) {
        emitter.error(x);
        emitter.end();
      };
      var _promise = promise.then(onValue, onError);

      // prevent libraries like 'Q' or 'when' from swallowing exceptions
      if (_promise && typeof _promise.done === 'function') {
        _promise.done();
      }

      called = true;
    }
  });

  return toProperty(result, null).setName('fromPromise');
}

function getGlodalPromise() {
  if (typeof Promise === 'function') {
    return Promise;
  } else {
    throw new Error("There isn't default Promise, use shim or parameter");
  }
}

var toPromise = function (obs) {
  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();

  var last = null;
  return new Promise(function (resolve, reject) {
    obs.onAny(function (event) {
      if (event.type === END && last !== null) {
        (last.type === VALUE ? resolve : reject)(last.value);
        last = null;
      } else {
        last = event;
      }
    });
  });
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var ponyfill = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}
});

var index$1 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});



var _ponyfill2 = _interopRequireDefault(ponyfill);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var root; /* global window */

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof commonjsGlobal !== 'undefined') {
  root = commonjsGlobal;
} else {
  root = module;
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
});

var index = index$1;

// this file contains some hot JS modules systems stuff

var $$observable = index.default ? index.default : index;

function fromESObservable(_observable) {
  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
  return stream(function (emitter) {
    var unsub = observable.subscribe({
      error: function (error) {
        emitter.error(error);
        emitter.end();
      },
      next: function (value) {
        emitter.emit(value);
      },
      complete: function () {
        emitter.end();
      }
    });

    if (unsub.unsubscribe) {
      return function () {
        unsub.unsubscribe();
      };
    } else {
      return unsub;
    }
  }).setName('fromESObservable');
}

function ESObservable(observable) {
  this._observable = observable.takeErrors(1);
}

extend(ESObservable.prototype, {
  subscribe: function (observerOrOnNext, onError, onComplete) {
    var _this = this;

    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;

    var fn = function (event) {
      if (event.type === END) {
        closed = true;
      }

      if (event.type === VALUE && observer.next) {
        observer.next(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.complete) {
        observer.complete(event.value);
      }
    };

    this._observable.onAny(fn);
    var closed = false;

    var subscription = {
      unsubscribe: function () {
        closed = true;
        _this._observable.offAny(fn);
      },
      get closed() {
        return closed;
      }
    };
    return subscription;
  }
});

// Need to assign directly b/c Symbols aren't enumerable.
ESObservable.prototype[$$observable] = function () {
  return this;
};

function toESObservable() {
  return new ESObservable(this);
}

function collect(source, keys, values) {
  for (var prop in source) {
    if (source.hasOwnProperty(prop)) {
      keys.push(prop);
      values.push(source[prop]);
    }
  }
}

function defaultErrorsCombinator(errors) {
  var latestError = void 0;
  for (var i = 0; i < errors.length; i++) {
    if (errors[i] !== undefined) {
      if (latestError === undefined || latestError.index < errors[i].index) {
        latestError = errors[i];
      }
    }
  }
  return latestError.error;
}

function Combine(active, passive, combinator) {
  var _this = this;

  Stream.call(this);
  this._activeCount = active.length;
  this._sources = concat(active, passive);
  this._combinator = combinator;
  this._aliveCount = 0;
  this._latestValues = new Array(this._sources.length);
  this._latestErrors = new Array(this._sources.length);
  fillArray(this._latestValues, NOTHING);
  this._emitAfterActivation = false;
  this._endAfterActivation = false;
  this._latestErrorIndex = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Combine, Stream, {
  _name: 'combine',

  _onActivation: function () {
    this._aliveCount = this._activeCount;

    // we need to suscribe to _passive_ sources before _active_
    // (see https://github.com/rpominov/kefir/issues/98)
    for (var i = this._activeCount; i < this._sources.length; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
    for (var _i = 0; _i < this._activeCount; _i++) {
      this._sources[_i].onAny(this._$handlers[_i]);
    }

    if (this._emitAfterActivation) {
      this._emitAfterActivation = false;
      this._emitIfFull();
    }
    if (this._endAfterActivation) {
      this._emitEnd();
    }
  },
  _onDeactivation: function () {
    var length = this._sources.length,
        i = void 0;
    for (i = 0; i < length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emitIfFull: function () {
    var hasAllValues = true;
    var hasErrors = false;
    var length = this._latestValues.length;
    var valuesCopy = new Array(length);
    var errorsCopy = new Array(length);

    for (var i = 0; i < length; i++) {
      valuesCopy[i] = this._latestValues[i];
      errorsCopy[i] = this._latestErrors[i];

      if (valuesCopy[i] === NOTHING) {
        hasAllValues = false;
      }

      if (errorsCopy[i] !== undefined) {
        hasErrors = true;
      }
    }

    if (hasAllValues) {
      var combinator = this._combinator;
      this._emitValue(combinator(valuesCopy));
    }
    if (hasErrors) {
      this._emitError(defaultErrorsCombinator(errorsCopy));
    }
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE || event.type === ERROR) {
      if (event.type === VALUE) {
        this._latestValues[i] = event.value;
        this._latestErrors[i] = undefined;
      }
      if (event.type === ERROR) {
        this._latestValues[i] = NOTHING;
        this._latestErrors[i] = {
          index: this._latestErrorIndex++,
          error: event.value
        };
      }

      if (i < this._activeCount) {
        if (this._activating) {
          this._emitAfterActivation = true;
        } else {
          this._emitIfFull();
        }
      }
    } else {
      // END

      if (i < this._activeCount) {
        this._aliveCount--;
        if (this._aliveCount === 0) {
          if (this._activating) {
            this._endAfterActivation = true;
          } else {
            this._emitEnd();
          }
        }
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._latestValues = null;
    this._latestErrors = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function combineAsArray(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var combinator = arguments[2];

  if (!Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
    return x;
  };
  return active.length === 0 ? never() : new Combine(active, passive, combinator);
}

function combineAsObject(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var combinator = arguments[2];

  if (typeof passive !== 'object' || Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  var keys = [],
      activeObservables = [],
      passiveObservables = [];

  collect(active, keys, activeObservables);
  collect(passive, keys, passiveObservables);

  var objectify = function (values) {
    var event = {};
    for (var i = values.length - 1; 0 <= i; i--) {
      event[keys[i]] = values[i];
    }
    return combinator ? combinator(event) : event;
  };

  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
}

function combine(active, passive, combinator) {
  if (typeof passive === 'function') {
    combinator = passive;
    passive = undefined;
  }

  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
}

var Observable$2 = {
  empty: function () {
    return never();
  },


  // Monoid based on merge() seems more useful than one based on concat().
  concat: function (a, b) {
    return a.merge(b);
  },
  of: function (x) {
    return constant(x);
  },
  map: function (fn, obs) {
    return obs.map(fn);
  },
  bimap: function (fnErr, fnVal, obs) {
    return obs.mapErrors(fnErr).map(fnVal);
  },


  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get
  // different (not very useful) behavior. But spec requires that if method can be derived
  // it must have the same behavior as hand-written method. We intentionally violate the spec
  // in hope that it won't cause many troubles in practice. And in return we have more useful type.
  ap: function (obsFn, obsVal) {
    return combine([obsFn, obsVal], function (fn, val) {
      return fn(val);
    });
  },
  chain: function (fn, obs) {
    return obs.flatMap(fn);
  }
};



var staticLand = Object.freeze({
	Observable: Observable$2
});

var mixin = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    this._emitValue(fn(x));
  }
};

var S$7 = createStream('map', mixin);
var P$3 = createProperty('map', mixin);

var id = function (x) {
  return x;
};

function map$1(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;

  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
}

var mixin$1 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    }
  }
};

var S$8 = createStream('filter', mixin$1);
var P$4 = createProperty('filter', mixin$1);

var id$1 = function (x) {
  return x;
};

function filter(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;

  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
}

var mixin$2 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitValue(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$9 = createStream('take', mixin$2);
var P$5 = createProperty('take', mixin$2);

function take(obs, n) {
  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
}

var mixin$3 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleError: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitError(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$10 = createStream('takeErrors', mixin$3);
var P$6 = createProperty('takeErrors', mixin$3);

function takeErrors(obs, n) {
  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
}

var mixin$4 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    } else {
      this._emitEnd();
    }
  }
};

var S$11 = createStream('takeWhile', mixin$4);
var P$7 = createProperty('takeWhile', mixin$4);

var id$2 = function (x) {
  return x;
};

function takeWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;

  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
}

var mixin$5 = {
  _init: function () {
    this._lastValue = NOTHING;
  },
  _free: function () {
    this._lastValue = null;
  },
  _handleValue: function (x) {
    this._lastValue = x;
  },
  _handleEnd: function () {
    if (this._lastValue !== NOTHING) {
      this._emitValue(this._lastValue);
    }
    this._emitEnd();
  }
};

var S$12 = createStream('last', mixin$5);
var P$8 = createProperty('last', mixin$5);

function last(obs) {
  return new (obs._ofSameType(S$12, P$8))(obs);
}

var mixin$6 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = Math.max(0, n);
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      this._emitValue(x);
    } else {
      this._n--;
    }
  }
};

var S$13 = createStream('skip', mixin$6);
var P$9 = createProperty('skip', mixin$6);

function skip(obs, n) {
  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
}

var mixin$7 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._fn !== null && !fn(x)) {
      this._fn = null;
    }
    if (this._fn === null) {
      this._emitValue(x);
    }
  }
};

var S$14 = createStream('skipWhile', mixin$7);
var P$10 = createProperty('skipWhile', mixin$7);

var id$3 = function (x) {
  return x;
};

function skipWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;

  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
}

var mixin$8 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._prev = NOTHING;
  },
  _free: function () {
    this._fn = null;
    this._prev = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._prev === NOTHING || !fn(this._prev, x)) {
      this._prev = x;
      this._emitValue(x);
    }
  }
};

var S$15 = createStream('skipDuplicates', mixin$8);
var P$11 = createProperty('skipDuplicates', mixin$8);

var eq = function (a, b) {
  return a === b;
};

function skipDuplicates(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;

  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
}

var mixin$9 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._prev = seed;
  },
  _free: function () {
    this._prev = null;
    this._fn = null;
  },
  _handleValue: function (x) {
    if (this._prev !== NOTHING) {
      var fn = this._fn;
      this._emitValue(fn(this._prev, x));
    }
    this._prev = x;
  }
};

var S$16 = createStream('diff', mixin$9);
var P$12 = createProperty('diff', mixin$9);

function defaultFn(a, b) {
  return [a, b];
}

function diff(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });
}

var P$13 = createProperty('scan', {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._seed = seed;
    if (seed !== NOTHING) {
      this._emitValue(seed);
    }
  },
  _free: function () {
    this._fn = null;
    this._seed = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._currentEvent === null || this._currentEvent.type === ERROR) {
      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
    } else {
      this._emitValue(fn(this._currentEvent.value, x));
    }
  }
});

function scan(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new P$13(obs, { fn: fn, seed: seed });
}

var mixin$10 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var xs = fn(x);
    for (var i = 0; i < xs.length; i++) {
      this._emitValue(xs[i]);
    }
  }
};

var S$17 = createStream('flatten', mixin$10);

var id$4 = function (x) {
  return x;
};

function flatten(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;

  return new S$17(obs, { fn: fn });
}

var END_MARKER = {};

var mixin$11 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait;

    this._wait = Math.max(0, wait);
    this._buff = [];
    this._$shiftBuff = function () {
      var value = _this._buff.shift();
      if (value === END_MARKER) {
        _this._emitEnd();
      } else {
        _this._emitValue(value);
      }
    };
  },
  _free: function () {
    this._buff = null;
    this._$shiftBuff = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._buff.push(x);
      setTimeout(this._$shiftBuff, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      this._buff.push(END_MARKER);
      setTimeout(this._$shiftBuff, this._wait);
    }
  }
};

var S$18 = createStream('delay', mixin$11);
var P$14 = createProperty('delay', mixin$11);

function delay(obs, wait) {
  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
}

var now = Date.now ? function () {
  return Date.now();
} : function () {
  return new Date().getTime();
};

var mixin$12 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        leading = _ref.leading,
        trailing = _ref.trailing;

    this._wait = Math.max(0, wait);
    this._leading = leading;
    this._trailing = trailing;
    this._trailingValue = null;
    this._timeoutId = null;
    this._endLater = false;
    this._lastCallTime = 0;
    this._$trailingCall = function () {
      return _this._trailingCall();
    };
  },
  _free: function () {
    this._trailingValue = null;
    this._$trailingCall = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      var curTime = now();
      if (this._lastCallTime === 0 && !this._leading) {
        this._lastCallTime = curTime;
      }
      var remaining = this._wait - (curTime - this._lastCallTime);
      if (remaining <= 0) {
        this._cancelTrailing();
        this._lastCallTime = curTime;
        this._emitValue(x);
      } else if (this._trailing) {
        this._cancelTrailing();
        this._trailingValue = x;
        this._timeoutId = setTimeout(this._$trailingCall, remaining);
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _cancelTrailing: function () {
    if (this._timeoutId !== null) {
      clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  },
  _trailingCall: function () {
    this._emitValue(this._trailingValue);
    this._timeoutId = null;
    this._trailingValue = null;
    this._lastCallTime = !this._leading ? 0 : now();
    if (this._endLater) {
      this._emitEnd();
    }
  }
};

var S$19 = createStream('throttle', mixin$12);
var P$15 = createProperty('throttle', mixin$12);

function throttle(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$leading = _ref2.leading,
      leading = _ref2$leading === undefined ? true : _ref2$leading,
      _ref2$trailing = _ref2.trailing,
      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;

  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });
}

var mixin$13 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        immediate = _ref.immediate;

    this._wait = Math.max(0, wait);
    this._immediate = immediate;
    this._lastAttempt = 0;
    this._timeoutId = null;
    this._laterValue = null;
    this._endLater = false;
    this._$later = function () {
      return _this._later();
    };
  },
  _free: function () {
    this._laterValue = null;
    this._$later = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._lastAttempt = now();
      if (this._immediate && !this._timeoutId) {
        this._emitValue(x);
      }
      if (!this._timeoutId) {
        this._timeoutId = setTimeout(this._$later, this._wait);
      }
      if (!this._immediate) {
        this._laterValue = x;
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId && !this._immediate) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _later: function () {
    var last = now() - this._lastAttempt;
    if (last < this._wait && last >= 0) {
      this._timeoutId = setTimeout(this._$later, this._wait - last);
    } else {
      this._timeoutId = null;
      if (!this._immediate) {
        this._emitValue(this._laterValue);
        this._laterValue = null;
      }
      if (this._endLater) {
        this._emitEnd();
      }
    }
  }
};

var S$20 = createStream('debounce', mixin$13);
var P$16 = createProperty('debounce', mixin$13);

function debounce(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$immediate = _ref2.immediate,
      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;

  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });
}

var mixin$14 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    this._emitError(fn(x));
  }
};

var S$21 = createStream('mapErrors', mixin$14);
var P$17 = createProperty('mapErrors', mixin$14);

var id$5 = function (x) {
  return x;
};

function mapErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;

  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
}

var mixin$15 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitError(x);
    }
  }
};

var S$22 = createStream('filterErrors', mixin$15);
var P$18 = createProperty('filterErrors', mixin$15);

var id$6 = function (x) {
  return x;
};

function filterErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;

  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
}

var mixin$16 = {
  _handleValue: function () {}
};

var S$23 = createStream('ignoreValues', mixin$16);
var P$19 = createProperty('ignoreValues', mixin$16);

function ignoreValues(obs) {
  return new (obs._ofSameType(S$23, P$19))(obs);
}

var mixin$17 = {
  _handleError: function () {}
};

var S$24 = createStream('ignoreErrors', mixin$17);
var P$20 = createProperty('ignoreErrors', mixin$17);

function ignoreErrors(obs) {
  return new (obs._ofSameType(S$24, P$20))(obs);
}

var mixin$18 = {
  _handleEnd: function () {}
};

var S$25 = createStream('ignoreEnd', mixin$18);
var P$21 = createProperty('ignoreEnd', mixin$18);

function ignoreEnd(obs) {
  return new (obs._ofSameType(S$25, P$21))(obs);
}

var mixin$19 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleEnd: function () {
    var fn = this._fn;
    this._emitValue(fn());
    this._emitEnd();
  }
};

var S$26 = createStream('beforeEnd', mixin$19);
var P$22 = createProperty('beforeEnd', mixin$19);

function beforeEnd(obs, fn) {
  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
}

var mixin$20 = {
  _init: function (_ref) {
    var min = _ref.min,
        max = _ref.max;

    this._max = max;
    this._min = min;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _handleValue: function (x) {
    this._buff = slide(this._buff, x, this._max);
    if (this._buff.length >= this._min) {
      this._emitValue(this._buff);
    }
  }
};

var S$27 = createStream('slidingWindow', mixin$20);
var P$23 = createProperty('slidingWindow', mixin$20);

function slidingWindow(obs, max) {
  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });
}

var mixin$21 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        flushOnEnd = _ref.flushOnEnd;

    this._fn = fn;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    var fn = this._fn;
    if (!fn(x)) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$28 = createStream('bufferWhile', mixin$21);
var P$24 = createProperty('bufferWhile', mixin$21);

var id$7 = function (x) {
  return x;
};

function bufferWhile(obs, fn) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });
}

var mixin$22 = {
  _init: function (_ref) {
    var count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$29 = createStream('bufferWithCount', mixin$22);
var P$25 = createProperty('bufferWithCount', mixin$22);

function bufferWhile$1(obs, count) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });
}

var mixin$23 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._wait = wait;
    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._flush();
    };
    this._buff = [];
  },
  _free: function () {
    this._$onTick = null;
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      clearInterval(this._intervalId);
      this._flush();
      this._intervalId = setInterval(this._$onTick, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd && this._buff.length !== 0) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._intervalId = setInterval(this._$onTick, this._wait);
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  },
  _onDeactivation: function () {
    if (this._intervalId !== null) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
    this._source.offAny(this._$handleAny); // copied from patterns/one-source
  }
};

var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);

function bufferWithTimeOrCount(obs, wait, count) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });
}

function xformForObs(obs) {
  return {
    '@@transducer/step': function (res, input) {
      obs._emitValue(input);
      return null;
    },
    '@@transducer/result': function () {
      obs._emitEnd();
      return null;
    }
  };
}

var mixin$24 = {
  _init: function (_ref) {
    var transducer = _ref.transducer;

    this._xform = transducer(xformForObs(this));
  },
  _free: function () {
    this._xform = null;
  },
  _handleValue: function (x) {
    if (this._xform['@@transducer/step'](null, x) !== null) {
      this._xform['@@transducer/result'](null);
    }
  },
  _handleEnd: function () {
    this._xform['@@transducer/result'](null);
  }
};

var S$31 = createStream('transduce', mixin$24);
var P$27 = createProperty('transduce', mixin$24);

function transduce(obs, transducer) {
  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
}

var mixin$25 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._handler = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._handler = null;
    this._emitter = null;
  },
  _handleAny: function (event) {
    this._handler(this._emitter, event);
  }
};

var S$32 = createStream('withHandler', mixin$25);
var P$28 = createProperty('withHandler', mixin$25);

function withHandler(obs, fn) {
  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
}

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function Zip(sources, combinator) {
  var _this = this;

  Stream.call(this);

  this._buffers = map(sources, function (source) {
    return isArray(source) ? cloneArray(source) : [];
  });
  this._sources = map(sources, function (source) {
    return isArray(source) ? never() : source;
  });

  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
    return x;
  };
  this._aliveCount = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Zip, Stream, {
  _name: 'zip',

  _onActivation: function () {
    // if all sources are arrays
    while (this._isFull()) {
      this._emit();
    }

    var length = this._sources.length;
    this._aliveCount = length;
    for (var i = 0; i < length && this._active; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0; i < this._sources.length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emit: function () {
    var values = new Array(this._buffers.length);
    for (var i = 0; i < this._buffers.length; i++) {
      values[i] = this._buffers[i].shift();
    }
    var combinator = this._combinator;
    this._emitValue(combinator(values));
  },
  _isFull: function () {
    for (var i = 0; i < this._buffers.length; i++) {
      if (this._buffers[i].length === 0) {
        return false;
      }
    }
    return true;
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE) {
      this._buffers[i].push(event.value);
      if (this._isFull()) {
        this._emit();
      }
    }
    if (event.type === ERROR) {
      this._emitError(event.value);
    }
    if (event.type === END) {
      this._aliveCount--;
      if (this._aliveCount === 0) {
        this._emitEnd();
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._buffers = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function zip(observables, combinator /* Function | falsey */) {
  return observables.length === 0 ? never() : new Zip(observables, combinator);
}

var id$8 = function (x) {
  return x;
};

function AbstractPool() {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$queueLim = _ref.queueLim,
      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,
      _ref$concurLim = _ref.concurLim,
      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,
      _ref$drop = _ref.drop,
      drop = _ref$drop === undefined ? 'new' : _ref$drop;

  Stream.call(this);

  this._queueLim = queueLim < 0 ? -1 : queueLim;
  this._concurLim = concurLim < 0 ? -1 : concurLim;
  this._drop = drop;
  this._queue = [];
  this._curSources = [];
  this._$handleSubAny = function (event) {
    return _this._handleSubAny(event);
  };
  this._$endHandlers = [];
  this._currentlyAdding = null;

  if (this._concurLim === 0) {
    this._emitEnd();
  }
}

inherit(AbstractPool, Stream, {
  _name: 'abstractPool',

  _add: function (obj, toObs /* Function | falsey */) {
    toObs = toObs || id$8;
    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
      this._addToCur(toObs(obj));
    } else {
      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
        this._addToQueue(toObs(obj));
      } else if (this._drop === 'old') {
        this._removeOldest();
        this._add(obj, toObs);
      }
    }
  },
  _addAll: function (obss) {
    var _this2 = this;

    forEach(obss, function (obs) {
      return _this2._add(obs);
    });
  },
  _remove: function (obs) {
    if (this._removeCur(obs) === -1) {
      this._removeQueue(obs);
    }
  },
  _addToQueue: function (obs) {
    this._queue = concat(this._queue, [obs]);
  },
  _addToCur: function (obs) {
    if (this._active) {
      // HACK:
      //
      // We have two optimizations for cases when `obs` is ended. We don't want
      // to add such observable to the list, but only want to emit events
      // from it (if it has some).
      //
      // Instead of this hacks, we could just did following,
      // but it would be 5-8 times slower:
      //
      //     this._curSources = concat(this._curSources, [obs]);
      //     this._subscribe(obs);
      //

      // #1
      // This one for cases when `obs` already ended
      // e.g., Kefir.constant() or Kefir.never()
      if (!obs._alive) {
        if (obs._currentEvent) {
          this._emit(obs._currentEvent.type, obs._currentEvent.value);
        }
        return;
      }

      // #2
      // This one is for cases when `obs` going to end synchronously on
      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})
      this._currentlyAdding = obs;
      obs.onAny(this._$handleSubAny);
      this._currentlyAdding = null;
      if (obs._alive) {
        this._curSources = concat(this._curSources, [obs]);
        if (this._active) {
          this._subToEnd(obs);
        }
      }
    } else {
      this._curSources = concat(this._curSources, [obs]);
    }
  },
  _subToEnd: function (obs) {
    var _this3 = this;

    var onEnd = function () {
      return _this3._removeCur(obs);
    };
    this._$endHandlers.push({ obs: obs, handler: onEnd });
    obs.onEnd(onEnd);
  },
  _subscribe: function (obs) {
    obs.onAny(this._$handleSubAny);

    // it can become inactive in responce of subscribing to `obs.onAny` above
    if (this._active) {
      this._subToEnd(obs);
    }
  },
  _unsubscribe: function (obs) {
    obs.offAny(this._$handleSubAny);

    var onEndI = findByPred(this._$endHandlers, function (obj) {
      return obj.obs === obs;
    });
    if (onEndI !== -1) {
      obs.offEnd(this._$endHandlers[onEndI].handler);
      this._$endHandlers.splice(onEndI, 1);
    }
  },
  _handleSubAny: function (event) {
    if (event.type === VALUE) {
      this._emitValue(event.value);
    } else if (event.type === ERROR) {
      this._emitError(event.value);
    }
  },
  _removeQueue: function (obs) {
    var index = find(this._queue, obs);
    this._queue = remove(this._queue, index);
    return index;
  },
  _removeCur: function (obs) {
    if (this._active) {
      this._unsubscribe(obs);
    }
    var index = find(this._curSources, obs);
    this._curSources = remove(this._curSources, index);
    if (index !== -1) {
      if (this._queue.length !== 0) {
        this._pullQueue();
      } else if (this._curSources.length === 0) {
        this._onEmpty();
      }
    }
    return index;
  },
  _removeOldest: function () {
    this._removeCur(this._curSources[0]);
  },
  _pullQueue: function () {
    if (this._queue.length !== 0) {
      this._queue = cloneArray(this._queue);
      this._addToCur(this._queue.shift());
    }
  },
  _onActivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
      this._subscribe(sources[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length; i++) {
      this._unsubscribe(sources[i]);
    }
    if (this._currentlyAdding !== null) {
      this._unsubscribe(this._currentlyAdding);
    }
  },
  _isEmpty: function () {
    return this._curSources.length === 0;
  },
  _onEmpty: function () {},
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._queue = null;
    this._curSources = null;
    this._$handleSubAny = null;
    this._$endHandlers = null;
  }
});

function Merge(sources) {
  AbstractPool.call(this);
  this._addAll(sources);
  this._initialised = true;
}

inherit(Merge, AbstractPool, {
  _name: 'merge',

  _onEmpty: function () {
    if (this._initialised) {
      this._emitEnd();
    }
  }
});

function merge(observables) {
  return observables.length === 0 ? never() : new Merge(observables);
}

function S$33(generator) {
  var _this = this;

  Stream.call(this);
  this._generator = generator;
  this._source = null;
  this._inLoop = false;
  this._iteration = 0;
  this._$handleAny = function (event) {
    return _this._handleAny(event);
  };
}

inherit(S$33, Stream, {
  _name: 'repeat',

  _handleAny: function (event) {
    if (event.type === END) {
      this._source = null;
      this._getSource();
    } else {
      this._emit(event.type, event.value);
    }
  },
  _getSource: function () {
    if (!this._inLoop) {
      this._inLoop = true;
      var generator = this._generator;
      while (this._source === null && this._alive && this._active) {
        this._source = generator(this._iteration++);
        if (this._source) {
          this._source.onAny(this._$handleAny);
        } else {
          this._emitEnd();
        }
      }
      this._inLoop = false;
    }
  },
  _onActivation: function () {
    if (this._source) {
      this._source.onAny(this._$handleAny);
    } else {
      this._getSource();
    }
  },
  _onDeactivation: function () {
    if (this._source) {
      this._source.offAny(this._$handleAny);
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._generator = null;
    this._source = null;
    this._$handleAny = null;
  }
});

var repeat = function (generator) {
  return new S$33(generator);
};

function concat$1(observables) {
  return repeat(function (index) {
    return observables.length > index ? observables[index] : false;
  }).setName('concat');
}

function Pool() {
  AbstractPool.call(this);
}

inherit(Pool, AbstractPool, {
  _name: 'pool',

  plug: function (obs) {
    this._add(obs);
    return this;
  },
  unplug: function (obs) {
    this._remove(obs);
    return this;
  }
});

function FlatMap(source, fn, options) {
  var _this = this;

  AbstractPool.call(this, options);
  this._source = source;
  this._fn = fn;
  this._mainEnded = false;
  this._lastCurrent = null;
  this._$handleMain = function (event) {
    return _this._handleMain(event);
  };
}

inherit(FlatMap, AbstractPool, {
  _onActivation: function () {
    AbstractPool.prototype._onActivation.call(this);
    if (this._active) {
      this._source.onAny(this._$handleMain);
    }
  },
  _onDeactivation: function () {
    AbstractPool.prototype._onDeactivation.call(this);
    this._source.offAny(this._$handleMain);
    this._hadNoEvSinceDeact = true;
  },
  _handleMain: function (event) {
    if (event.type === VALUE) {
      // Is latest value before deactivation survived, and now is 'current' on this activation?
      // We don't want to handle such values, to prevent to constantly add
      // same observale on each activation/deactivation when our main source
      // is a `Kefir.conatant()` for example.
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === ERROR) {
      this._emitError(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  },
  _onEmpty: function () {
    if (this._mainEnded) {
      this._emitEnd();
    }
  },
  _clear: function () {
    AbstractPool.prototype._clear.call(this);
    this._source = null;
    this._lastCurrent = null;
    this._$handleMain = null;
  }
});

function FlatMapErrors(source, fn) {
  FlatMap.call(this, source, fn);
}

inherit(FlatMapErrors, FlatMap, {
  // Same as in FlatMap, only VALUE/ERROR flipped
  _handleMain: function (event) {
    if (event.type === ERROR) {
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === VALUE) {
      this._emitValue(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  }
});

function createConstructor$1(BaseClass, name) {
  return function AnonymousObservable(primary, secondary, options) {
    var _this = this;

    BaseClass.call(this);
    this._primary = primary;
    this._secondary = secondary;
    this._name = primary._name + '.' + name;
    this._lastSecondary = NOTHING;
    this._$handleSecondaryAny = function (event) {
      return _this._handleSecondaryAny(event);
    };
    this._$handlePrimaryAny = function (event) {
      return _this._handlePrimaryAny(event);
    };
    this._init(options);
  };
}

function createClassMethods$1(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handlePrimaryValue: function (x) {
      this._emitValue(x);
    },
    _handlePrimaryError: function (x) {
      this._emitError(x);
    },
    _handlePrimaryEnd: function () {
      this._emitEnd();
    },
    _handleSecondaryValue: function (x) {
      this._lastSecondary = x;
    },
    _handleSecondaryError: function (x) {
      this._emitError(x);
    },
    _handleSecondaryEnd: function () {},
    _handlePrimaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handlePrimaryValue(event.value);
        case ERROR:
          return this._handlePrimaryError(event.value);
        case END:
          return this._handlePrimaryEnd(event.value);
      }
    },
    _handleSecondaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleSecondaryValue(event.value);
        case ERROR:
          return this._handleSecondaryError(event.value);
        case END:
          this._handleSecondaryEnd(event.value);
          this._removeSecondary();
      }
    },
    _removeSecondary: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
        this._$handleSecondaryAny = null;
        this._secondary = null;
      }
    },
    _onActivation: function () {
      if (this._secondary !== null) {
        this._secondary.onAny(this._$handleSecondaryAny);
      }
      if (this._active) {
        this._primary.onAny(this._$handlePrimaryAny);
      }
    },
    _onDeactivation: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
      }
      this._primary.offAny(this._$handlePrimaryAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._primary = null;
      this._secondary = null;
      this._lastSecondary = null;
      this._$handleSecondaryAny = null;
      this._$handlePrimaryAny = null;
      this._free();
    }
  };
}

function createStream$1(name, mixin) {
  var S = createConstructor$1(Stream, name);
  inherit(S, Stream, createClassMethods$1(Stream), mixin);
  return S;
}

function createProperty$1(name, mixin) {
  var P = createConstructor$1(Property, name);
  inherit(P, Property, createClassMethods$1(Property), mixin);
  return P;
}

var mixin$26 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
      this._emitEnd();
    }
  }
};

var S$34 = createStream$1('filterBy', mixin$26);
var P$29 = createProperty$1('filterBy', mixin$26);

function filterBy(primary, secondary) {
  return new (primary._ofSameType(S$34, P$29))(primary, secondary);
}

var id2 = function (_, x) {
  return x;
};

function sampledBy(passive, active, combinator) {
  var _combinator = combinator ? function (a, b) {
    return combinator(b, a);
  } : id2;
  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
}

var mixin$27 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING) {
      this._emitEnd();
    }
  }
};

var S$35 = createStream$1('skipUntilBy', mixin$27);
var P$30 = createProperty$1('skipUntilBy', mixin$27);

function skipUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$35, P$30))(primary, secondary);
}

var mixin$28 = {
  _handleSecondaryValue: function () {
    this._emitEnd();
  }
};

var S$36 = createStream$1('takeUntilBy', mixin$28);
var P$31 = createProperty$1('takeUntilBy', mixin$28);

function takeUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$36, P$31))(primary, secondary);
}

var mixin$29 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._primary.onAny(this._$handlePrimaryAny);
    if (this._alive && this._secondary !== null) {
      this._secondary.onAny(this._$handleSecondaryAny);
    }
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
  },
  _handleSecondaryValue: function () {
    this._flush();
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd) {
      this._emitEnd();
    }
  }
};

var S$37 = createStream$1('bufferBy', mixin$29);
var P$32 = createProperty$1('bufferBy', mixin$29);

function bufferBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
}

var mixin$30 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,
        _ref$flushOnChange = _ref.flushOnChange,
        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
    this._flushOnChange = flushOnChange;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
      this._flush();
    }
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
      this._emitEnd();
    }
  },
  _handleSecondaryValue: function (x) {
    if (this._flushOnChange && !x) {
      this._flush();
    }

    // from default _handleSecondaryValue
    this._lastSecondary = x;
  }
};

var S$38 = createStream$1('bufferWhileBy', mixin$30);
var P$33 = createProperty$1('bufferWhileBy', mixin$30);

function bufferWhileBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
}

var f = function () {
  return false;
};
var t = function () {
  return true;
};

function awaiting(a, b) {
  var result = merge([map$1(a, t), map$1(b, f)]);
  result = skipDuplicates(result);
  result = toProperty(result, f);
  return result.setName(a, 'awaiting');
}

var mixin$31 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitError(result.error);
    } else {
      this._emitValue(x);
    }
  }
};

var S$39 = createStream('valuesToErrors', mixin$31);
var P$34 = createProperty('valuesToErrors', mixin$31);

var defFn = function (x) {
  return { convert: true, error: x };
};

function valuesToErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;

  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
}

var mixin$32 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitValue(result.value);
    } else {
      this._emitError(x);
    }
  }
};

var S$40 = createStream('errorsToValues', mixin$32);
var P$35 = createProperty('errorsToValues', mixin$32);

var defFn$1 = function (x) {
  return { convert: true, value: x };
};

function errorsToValues(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;

  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
}

var mixin$33 = {
  _handleError: function (x) {
    this._emitError(x);
    this._emitEnd();
  }
};

var S$41 = createStream('endOnError', mixin$33);
var P$36 = createProperty('endOnError', mixin$33);

function endOnError(obs) {
  return new (obs._ofSameType(S$41, P$36))(obs);
}

// Create a stream
// -----------------------------------------------------------------------------

// () -> Stream
// (number, any) -> Stream
// (number, any) -> Stream
// (number, Array<any>) -> Stream
// (number, Function) -> Stream
// (number, Function) -> Stream
// (Function) -> Stream
// (Function) -> Stream
// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}
// (Target, string, Function|undefined) -> Stream
// (Function) -> Stream
// Create a property
// -----------------------------------------------------------------------------

// (any) -> Property
// (any) -> Property
// Convert observables
// -----------------------------------------------------------------------------

// (Stream|Property, Function|undefined) -> Property
Observable.prototype.toProperty = function (fn) {
  return toProperty(this, fn);
};

// (Stream|Property) -> Stream
Observable.prototype.changes = function () {
  return changes(this);
};

// Interoperation with other implimentations
// -----------------------------------------------------------------------------

// (Promise) -> Property
// (Stream|Property, Function|undefined) -> Promise
Observable.prototype.toPromise = function (Promise) {
  return toPromise(this, Promise);
};

// (ESObservable) -> Stream
// (Stream|Property) -> ES7 Observable
Observable.prototype.toESObservable = toESObservable;
Observable.prototype[$$observable] = toESObservable;

// Modify an observable
// -----------------------------------------------------------------------------

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.map = function (fn) {
  return map$1(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filter = function (fn) {
  return filter(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.take = function (n) {
  return take(this, n);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.takeErrors = function (n) {
  return takeErrors(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.takeWhile = function (fn) {
  return takeWhile(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.last = function () {
  return last(this);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.skip = function (n) {
  return skip(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipWhile = function (fn) {
  return skipWhile(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipDuplicates = function (fn) {
  return skipDuplicates(this, fn);
};

// (Stream, Function|falsey, any|undefined) -> Stream
// (Property, Function|falsey, any|undefined) -> Property
Observable.prototype.diff = function (fn, seed) {
  return diff(this, fn, seed);
};

// (Stream|Property, Function, any|undefined) -> Property
Observable.prototype.scan = function (fn, seed) {
  return scan(this, fn, seed);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.flatten = function (fn) {
  return flatten(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.delay = function (wait) {
  return delay(this, wait);
};

// Options = {leading: boolean|undefined, trailing: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.throttle = function (wait, options) {
  return throttle(this, wait, options);
};

// Options = {immediate: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.debounce = function (wait, options) {
  return debounce(this, wait, options);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.mapErrors = function (fn) {
  return mapErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filterErrors = function (fn) {
  return filterErrors(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreValues = function () {
  return ignoreValues(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreErrors = function () {
  return ignoreErrors(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreEnd = function () {
  return ignoreEnd(this);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.beforeEnd = function (fn) {
  return beforeEnd(this, fn);
};

// (Stream, number, number|undefined) -> Stream
// (Property, number, number|undefined) -> Property
Observable.prototype.slidingWindow = function (max, min) {
  return slidingWindow(this, max, min);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Function|falsey, Options|undefined) -> Stream
// (Property, Function|falsey, Options|undefined) -> Property
Observable.prototype.bufferWhile = function (fn, options) {
  return bufferWhile(this, fn, options);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.bufferWithCount = function (count, options) {
  return bufferWhile$1(this, count, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, number, number, Options|undefined) -> Stream
// (Property, number, number, Options|undefined) -> Property
Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
  return bufferWithTimeOrCount(this, wait, count, options);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.transduce = function (transducer) {
  return transduce(this, transducer);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.withHandler = function (fn) {
  return withHandler(this, fn);
};

// Combine observables
// -----------------------------------------------------------------------------

// (Array<Stream|Property>, Function|undefiend) -> Stream
// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.combine = function (other, combinator) {
  return combine([this, other], combinator);
};

// (Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.zip = function (other, combinator) {
  return zip([this, other], combinator);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.merge = function (other) {
  return merge([this, other]);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.concat = function (other) {
  return concat$1([this, other]);
};

// () -> Pool
var pool = function () {
  return new Pool();
};

// (Function) -> Stream
// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}
// (Stream|Property, Function|falsey, Options|undefined) -> Stream
Observable.prototype.flatMap = function (fn) {
  return new FlatMap(this, fn).setName(this, 'flatMap');
};
Observable.prototype.flatMapLatest = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');
};
Observable.prototype.flatMapFirst = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
};
Observable.prototype.flatMapConcat = function (fn) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');
};
Observable.prototype.flatMapConcurLimit = function (fn, limit) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');
};

// (Stream|Property, Function|falsey) -> Stream
Observable.prototype.flatMapErrors = function (fn) {
  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
};

// Combine two observables
// -----------------------------------------------------------------------------

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.filterBy = function (other) {
  return filterBy(this, other);
};

// (Stream, Stream|Property, Function|undefiend) -> Stream
// (Property, Stream|Property, Function|undefiend) -> Property
Observable.prototype.sampledBy = function (other, combinator) {
  return sampledBy(this, other, combinator);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.skipUntilBy = function (other) {
  return skipUntilBy(this, other);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.takeUntilBy = function (other) {
  return takeUntilBy(this, other);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferBy = function (other, options) {
  return bufferBy(this, other, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferWhileBy = function (other, options) {
  return bufferWhileBy(this, other, options);
};

// Deprecated
// -----------------------------------------------------------------------------

var DEPRECATION_WARNINGS = true;
function dissableDeprecationWarnings() {
  DEPRECATION_WARNINGS = false;
}

function warn(msg) {
  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
    var msg2 = '\nHere is an Error object for you containing the call stack:';
    console.warn(msg, msg2, new Error());
  }
}

// (Stream|Property, Stream|Property) -> Property
Observable.prototype.awaiting = function (other) {
  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');
  return awaiting(this, other);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.valuesToErrors = function (fn) {
  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');
  return valuesToErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.errorsToValues = function (fn) {
  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');
  return errorsToValues(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.endOnError = function () {
  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');
  return endOnError(this);
};

// Exports
// --------------------------------------------------------------------------

var Kefir = {
  Observable: Observable,
  Stream: Stream,
  Property: Property,
  never: never,
  later: later,
  interval: interval,
  sequentially: sequentially,
  fromPoll: fromPoll,
  withInterval: withInterval,
  fromCallback: fromCallback,
  fromNodeCallback: fromNodeCallback,
  fromEvents: fromEvents,
  stream: stream,
  constant: constant,
  constantError: constantError,
  fromPromise: fromPromise,
  fromESObservable: fromESObservable,
  combine: combine,
  zip: zip,
  merge: merge,
  concat: concat$1,
  Pool: Pool,
  pool: pool,
  repeat: repeat,
  staticLand: staticLand
};

Kefir.Kefir = Kefir;

exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
exports.Kefir = Kefir;
exports.Observable = Observable;
exports.Stream = Stream;
exports.Property = Property;
exports.never = never;
exports.later = later;
exports.interval = interval;
exports.sequentially = sequentially;
exports.fromPoll = fromPoll;
exports.withInterval = withInterval;
exports.fromCallback = fromCallback;
exports.fromNodeCallback = fromNodeCallback;
exports.fromEvents = fromEvents;
exports.stream = stream;
exports.constant = constant;
exports.constantError = constantError;
exports.fromPromise = fromPromise;
exports.fromESObservable = fromESObservable;
exports.combine = combine;
exports.zip = zip;
exports.merge = merge;
exports.concat = concat$1;
exports.Pool = Pool;
exports.pool = pool;
exports.repeat = repeat;
exports.staticLand = staticLand;
exports['default'] = Kefir;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(127)))

/***/ }),
/* 424 */
/***/ (function(module, exports) {

SNI.Application.addService('ads', function (application) {
  'use strict';

  /*
    SniAds usage follows this pattern throughout.  We should re-use this service wherever the pattern occurs
  */

  var debug = application.getService('logger').create('service.ads');
  var check = application.getService('check').new(debug);
  var adLib = check.exists('SniAds') ? application.getGlobal('SniAds') : false;

  function subscribe() {
    var args = Array.prototype.slice.call(arguments);
    if (adLib) {
      adLib.Event.subscribe.apply(this, args);
    }
  }

  //collapse unused ad slots so that we're not left with an empty slot with min-height applied
  function collapseSlots() {
    var slotsToHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['dfp_leaderboard', 'dfp_bigbox', 'dfp_smartphone_banner'];

    var parentSelectors = {
      'dfp_bigbox': '#bigbox-rr-ad',
      'dfp_smartphone_banner': '.o-Leaderboard'
    };
    function hideSlot(id) {
      debug.log('hiding slot', id);
      var $ele = $('#' + id);
      var $target = $ele.closest('[data-dynamic-ad-collapse-target]');
      $ele = parentSelectors[id] ? $ele.closest(parentSelectors[id]) : $target.length ? $target : $ele;
      $ele.addClass('is-AdCollapsed');
    }
    if (window.location.search.match(/(\?|\&)sniadsoff/g)) {
      slotsToHide.forEach(function (slot) {
        hideSlot(slot);
      });
      return;
    }
    if (adLib) {
      adLib.ready(function () {
        var enabledSlots = Object.keys(adLib.getDefinedSlots());
        var disabledSlots = slotsToHide.filter(function (el) {
          return enabledSlots.indexOf(el) === -1;
        });
        debug.log('disabledSlots', disabledSlots);
        //hide disabled slots in the page asap.
        disabledSlots.forEach(function (slot) {
          hideSlot(slot);
        });
        //then hide slots that return no ad result.
        subscribe('slotRenderComplete', function (slot) {
          var id = slot.slot.getSlotElementId();
          debug.log('slotRenderComplete', id);
          if (slot.isEmpty) {
            debug.log('slot.isEmpty is true for id:', id);
            hideSlot(id);
          }
        });
      });
    }
  }

  function getDynamicSlots($container) {
    var slots = [];
    if (adLib) {
      $container.find('[data-has-ad]').each(function () {
        var id = $(this).attr('id'); // dfp_bigbox_<count> || dfp_leaderboard_<count>
        var adType = $(this).data('has-ad'); // dfp_bigbox || dfp_leaderboard

        debug.log('getDynamicSlots', id, adType);

        if (id && adType) {
          slots.push({
            id: id,
            type: adType
          });
        } else {
          debug.error('getDynamicSlots(): one of these values is not defined:', 'id: ' + id, 'adType: ' + adType);
        }
      });
      return slots;
    }
  }

  return {
    adLib: adLib,
    collapseSlots: collapseSlots,
    getDynamicSlots: getDynamicSlots,
    event: {
      subscribe: subscribe
    }
  };
});

/***/ }),
/* 425 */
/***/ (function(module, exports) {

SNI.Application.addService('common-handlers', function (application) {

  return {
    eventHandler: function eventHandler(events) {
      var preventDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return function (event, element, elementType) {
        if (preventDefault) {
          event.preventDefault();
        }
        if (elementType in events) {
          events[elementType](event, element, elementType);
        }
      };
    }

  };
});

/***/ }),
/* 426 */
/***/ (function(module, exports) {

/*
 * cookie service: to allow creation of cookies that store key/value pairs and data can be appended or updated
 * code adpated from http://www.quirksmode.org/js/cookies.html
 */
SNI.Application.addService('cookie', function (application) {

  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------

  // creates an object from key/value pairs
  var getPersistValues = function getPersistValues(cookie) {
    var values = {};
    var temp = '';

    $.each(cookie.split('&'), function (k, v) {
      temp = v.split('=');

      if (temp[0]) {
        values[temp[0]] = unescape(temp[1]);
      }
    });

    return values;
  };

  // creates a string like a 'query string'
  var buildPersistString = function buildPersistString(values) {
    var result = [];

    $.each(values, function (k, v) {
      // skip/delete the value if it's null
      if (v !== null) {
        result.push(k + '=' + escape(v));
      }
    });

    return result.join('&');
  };

  //-----------------------------------------------------------
  // Public
  //-----------------------------------------------------------

  var get = function get(name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0) {
        return c.substring(nameEQ.length, c.length);
      }
    }
    return null;
  };

  // leave 'days' blank to expire at end of session
  var set = function set(name, value, days, path, domain) {

    var expires = '';
    var sharedDomain = window.location.hostname.match(/[^\.]*\.*[a-z]*$/g)[0];
    if (sharedDomain && sharedDomain !== 'localhost') sharedDomain = '.' + sharedDomain;
    domain = domain && sharedDomain ? '; domain=' + sharedDomain : '';

    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      expires = '; expires=' + date.toGMTString();
    }

    if (!path) {
      path = '/';
    }

    document.cookie = name + '=' + value + expires + '; path=' + path + domain;
  };

  var remove = function remove(name) {
    set(name, '', -1);
  };

  /**
   * reads/writes a single persistent cookie that can be used to store basic key/value information
   * if the value doesn't exist it will be created
   * persist(cookieName, key) - retrieve a value or null if not found
   * persist(cookieName, key, value, [days]) - store a value
   * If the 'value' parameter is null the key/value pair is deleted from the cookie
   */
  var persist = function persist(cookieName, key, value, days) {
    var cookie = get(cookieName);
    var values = void 0;
    days = days || 30;

    // just need to read the value
    if (typeof value === 'undefined') {

      // cookie has not been created so no info exists
      if (cookie === null) {
        return null;

        // try to find the key/value pair
      } else {
        values = getPersistValues(cookie);
        return values[key];
      }

      // writing the value
    } else {

      // create new cookie
      if (cookie === null) {
        values = {};
        values[key] = value;

        // append to the current cookie
      } else {
        values = getPersistValues(cookie);
        values[key] = value;
      }

      set(cookieName, buildPersistString(values), days);
    }
  };

  return {
    SEARCH: 'S',
    UI: 'U',
    get: get,
    set: set,
    remove: remove,
    persist: persist
  };
});

/***/ }),
/* 427 */
/***/ (function(module, exports) {

/* eslint-disable no-console */

SNI.Application.addService('debug', function (application) {

  var util = application.getService('utility'),
      module = {
    _getMode: function _getMode() {
      if (util.getUrlParam(window.location.href, 'debug') === 'true' || localStorage.getItem('debug') === 'true') {
        return true;
      } else {
        return false;
      }
    }
  };

  function addConsoleMethods(module, methods) {
    var method = methods.pop();
    if (typeof method === 'undefined') {
      return true;
    } else {
      module[method] = function () {
        var self = this,
            args = Array.prototype.slice.call(arguments);

        if (self.mode === false) {
          return;
        }

        if (window.console && window.console[method]) if (console[method].apply) console[method].apply(console, args);else
          // Some browsers don't support .apply() for console[method], so just pass an array
          console[method](args);
      };
      addConsoleMethods(module, methods);
    }
  }

  addConsoleMethods(module, ['log', 'warn', 'error']);

  module.mode = module._getMode();

  return module;
});

/***/ }),
/* 428 */
/***/ (function(module, exports) {

SNI.Application.addService('dependency-loader', function (application) {

  var debug = application.getService('logger').create('service.dependency-loader');
  var loadedScripts = [];

  function load(script) {
    var promise = new Promise(function (resolve, reject) {
      if (script in loadedScripts) {
        resolve(true);
      } else {
        $.getScript(script).done(function (script, textStatus) {
          debug.log('ajaxLoadScript()loaded successfully! It was a: ', textStatus);
          loadedScripts.push(script);
          resolve(true);
        }).fail(function (jqxhr, settings, exception) {
          debug.log('ajaxLoadScript() source error! Exception: ', exception);
          reject(exception);
        });
      }
    });

    return promise;
  }

  return {
    load: load
  };
});

/***/ }),
/* 429 */
/***/ (function(module, exports) {

SNI.Application.addService('gigya/comments', function (Application) {

  var debug = Application.getService('logger').create('service.gigya.comments');
  var check = Application.getService('check').new(debug);
  var gigya = check.exists('gigya.comments') ? Application.getGlobal('gigya') : false;
  var mdManager = Application.getGlobal('mdManager');
  var streamCollection = {};
  var ratingSets = { atoms: null }; // a predifined type of set

  /*  PRIVATE */

  /** Broadcast stream info from gigya to comments module or ratings module
    * @param {object} - stream info object from Gigya
    */
  function broadcastStreamInfo(streamInfo) {
    Application.broadcast('gigya_stream_info', streamInfo);
  }

  function broadcastCommentInfo(commentInfo) {
    Application.broadcast('gigya_comment_info', commentInfo);
  }

  /*  Broadcast a message for each element  */
  function broadcastStreamCollection(eventObj) {
    var streamInfo = eventObj.streamInfo;

    if ($.isArray(streamInfo)) {
      streamInfo.forEach(function (element) {
        broadcastStreamInfo({ streamInfo: element });
      });
    } else {
      broadcastStreamInfo(eventObj);
    }
  }

  /* PUBLIC */
  /* Implement Gigya API calls as a service */

  function addStreamItem(params) {
    if (!gigya) {
      return;
    }

    var setName = params.setName,
        streamID = params.streamID,
        setCount = params.setCount;


    if (!(setName in streamCollection)) {
      streamCollection[setName] = [];
    }

    // only add a Stream ID to the set once
    if (streamCollection[setName].indexOf(streamID) === -1) streamCollection[setName].push(streamID);

    if (streamCollection[setName].length === setCount) {
      // call get stream Info on the last item
      params.callback = broadcastStreamCollection;
      params.streamIDs = streamCollection[setName].slice();
      gigya.comments.getStreamInfo(params);
    }
  }

  function showCommentsUI(params) {
    if (!gigya) {
      return;
    }
    gigya.comments.showCommentsUI(params);
  }

  function getCommentInfo(params) {
    if (!gigya) {
      return;
    }
    params.callback = broadcastCommentInfo;
    gigya.comments.getComments(params);
  }

  function getStreamInfo(params) {
    if (!gigya) {
      return;
    }
    params.callback = broadcastStreamInfo;
    gigya.comments.getStreamInfo(params);
  }

  function getPageID() {
    return mdManager.getDetailId();
  }

  return {
    showCommentsUI: showCommentsUI,
    getStreamInfo: getStreamInfo,
    getCommentInfo: getCommentInfo,
    getPageID: getPageID,
    addStreamItem: addStreamItem,
    ratingSets: ratingSets
  };
});

/***/ }),
/* 430 */
/***/ (function(module, exports) {

/**
 *  There are a variation of brand names used through out the various gigya services
 *  The basic brand == mdManager.getSite()
 *  There are variations of the basic brand for socialUpload, analytics and moderation
 */
SNI.Application.addService('gigya/getBrand', function (application) {

  var mdManager = application.getGlobal('mdManager');

  var BRANDS = {
    tracking: { //  does not map to the brands on social Uploader
      'food': 'fn',
      'hgtv': 'hgtv',
      'travel': 'tc',
      'diy': 'diy',
      'cook': 'cctv'
    },
    short: {
      'food': 'fn',
      'hgtv': 'hgtv',
      'travel': 'tc',
      'diy': 'hgtv', // configured in cloudinary to fall under HGTV
      'cook': 'cctv',
      'cctv': 'cctv'
    },
    long: {
      'food': 'foodnetwork',
      'hgtv': 'hgtv',
      'travel': 'travel',
      'diy': 'hgtv', // configured in cloudinary to fall under HGTV
      'cctv': 'cctv',
      'cook': 'cctv'
    }
  };

  var basicBrand = function () {
    var code = (mdManager ? mdManager.getSite() : '').toLowerCase();
    code = code.replace(/golden-/, '');
    return code;
  }();

  function basic() {
    return basicBrand;
  }

  function specific(type) {
    if (type in BRANDS) {
      var set = BRANDS[type];
      if (basicBrand in set) {
        return set[basicBrand];
      }
    }
    return basicBrand;
  }

  return {
    basic: basic,
    specific: specific
  };
});

/***/ }),
/* 431 */
/***/ (function(module, exports) {


/**
 * Get the current session's data.  Return a promise that resolves with the data or rejects with error data
 */
SNI.Application.addService('gigya/getSession', function (application) {

  var debug = application.getService('logger').create('service.gigya.getSession');
  var check = application.getService('check').new(debug);
  var gigya = check.exists('gigya.accounts') ? application.getGlobal('gigya') : false;

  function getNewSessionData() {
    var prom = void 0;
    var $def = $.Deferred();

    function returnStatus(response) {
      if (response.errorCode === 0) {
        $def.resolve(response);
      } else {
        $def.reject(response.errorMessage);
      }
    }

    if (gigya) {
      gigya.accounts.getAccountInfo({ callback: returnStatus });
    }

    prom = $def.promise();

    return prom;
  }

  return {
    getNewSessionData: getNewSessionData
  };
});

/***/ }),
/* 432 */
/***/ (function(module, exports) {

/** 
* Adds gigya/account as a service for other modules
* This is so we can import let gigya = application.getGlobal('gigya');
* and calls gigya.account(anythingInFolder)
*/
SNI.Application.addService('gigya', function (application) {

  var CONFIG = {};

  /** Manage config values that should be available to other parts of the application.
   *  Specially for dynamic modules that do not have an x-config possible
   */
  function configGS(item, value, type) {
    var cleanVal = type ? cleanUp(type, value) : value;
    if (!value) {
      if (item in CONFIG) return CONFIG[item];
    } else {
      CONFIG[item] = cleanVal;
    }
    return null;
  }

  function cleanUp(type, value) {
    var clean = value;
    switch (type) {
      case 'hash_encode':
        clean = value.replace(/#o#/g, '&#').replace(/#c#/g, ';');
        break;
    }
    return clean;
  }

  function getSiteURL() {
    var url = window.location.hostname,
        site = url.replace('www.', '');
    return site;
  }

  return {
    account: application.getService('gigya/account'),
    socialUpload: application.getService('gigya/socialUpload'),
    configGS: configGS,
    getSiteURL: getSiteURL
  };
});

/***/ }),
/* 433 */
/***/ (function(module, exports) {

SNI.Application.addService('gigya/moderation', function (app) {

  var debug = app.getService('logger').create('comments.moderation'),
      gigyaSession = app.getService('gigya/getSession'),
      getBrand = app.getService('gigya/getBrand'),
      getNewSessionData = gigyaSession.getNewSessionData;

  /** setModURL
    * export so we can grab the moderation url from x-config on page
    * @param {string} url - moderation url
    * @param {string} type - comments or profile
  */
  var setModURL = function setModURL(url, type) {
    if (type === 'profile') {
      modURL.profile = url;
    }
    if (type === 'comments') {
      modURL.comments = url;
    }
  };

  /** 
   * Set the current site code with a method that cleans up the code in preparation for moderation.
   * Acceptable codes are: food,hgtv,diy,gac,travel,cook
  */
  var siteCODE = getBrand.basic();

  /**
   * @testModData {object} used as data signatures for moderation to compare and use what values shoud be sent
   * @testDataToTrim {object} used to compare data being submitted after getAccountInfo is called
   * @modURL {object} used to store url for comments moderation and profile moderation TODO: need prod value and enviroment switcher
  */
  var testModData = {
    profile: { 'UID': '0', 'UIDSignature': '0', 'signatureTimestamp': '0', 'profile': { 'city': null, 'country': null, 'email': '', 'firstName': '', 'lastName': 'Stark ', 'nickname': ' ' }, 'metadata': { 'sitecode': siteCODE, 'registration': false } },
    profile_photo: { 'UID': '0', 'UIDSignature': '0', 'signatureTimestamp': '0', 'profile': { 'city': null, 'country': null, 'photoURL': '', 'thumbnailURL': '', 'email': '', 'firstName': '', 'lastName': 'Stark ', 'nickname': ' ' }, 'metadata': { 'sitecode': siteCODE, 'registration': false } },
    ratings: { 'UID': '0', 'UIDSignature': '0=', 'signatureTimestamp': '0', 'profile': { 'nickname': '', 'photoURL': '', 'thumbnailURL': '', 'email': '', 'firstName': '', 'lastName': 'Stark', 'time': '2016-04-29T18:17:28.848Z' }, 'comment': { 'ID': '0', 'parentID': null, 'replies': [], 'streamId': '0', 'commentText': '', 'categoryId': 'recipe' }, 'metadata': { 'sitecode': 'fn' } },
    comment: { 'UID': '0', 'UIDSignature': '0=', 'signatureTimestamp': '1461942198', 'profile': { 'nickname': '', 'photoURL': '', 'thumbnailURL': '', 'email': '', 'firstName': '', 'lastName': '', 'time': '2016-05-02T20:27:29.791Z' }, 'comment': { 'ID': '0-01', 'parentID': null, 'replies': [], 'streamId': '0-01', 'commentText': '', 'categoryId': 'winter' }, 'metadata': { 'sitecode': siteCODE } },
    registration: { 'UID': '000000', 'UIDSignature': '000000=', 'signatureTimestamp': '1461942198', 'profile': { 'email': '' }, 'metadata': { 'sitecode': 'SITE', 'registration': true } } },
      testDataToTrim = { 'UID': '0', 'UIDSignature': '0=', 'signatureTimestamp': '0', 'loginProvider': 'site', 'isRegistered': true, 'isActive': true, 'isLockedOut': false, 'isVerified': true, 'socialProviders': 'site', 'profile': { 'firstName': '', 'lastName': 'Stark', 'birthYear': 1983, 'country': 'United States', 'state': '', 'city': '', 'zip': '10000', 'gender': 'M', 'age': 55, 'email': '' }, 'data': { 'AIM_ID': '9255932', 'gigyaImportJob': '0', 'personas': { 'Home': { 'displayName': '', 'aboutMe': '', 'myPhoto': '' }, 'Food': { 'displayName': '', 'aboutMe': '', 'myPhoto': '' } }, 'sitelinks': { 'DIY': { 'siteID': '4' }, 'Food': { 'siteID': '12' }, 'HGTV': { 'siteID': '2' }, 'FoodNetwork': { 'siteID': '1' }, 'CookingChannel': { 'siteID': '13' } }, 'socialProfiles': [], 'subscribe': false, 'terms': true, 'user': { 'creationTimestamp': '2008-07-15T04:07:53.000Z', 'lastLoginTimestamp': '2014-07-15T20:51:39.000Z', 'lastUpdateTimestamp': '2014-07-15T20:51:39.000Z', 'location': 'Winterfel Westeros', 'cableProviderName': 'DragonCast', 'timeZone': '1' } }, 'created': '2014-10-26T04:10:08.294Z', 'createdTimestamp': 1414296608294, 'lastLogin': '2016-05-11T17:33:57.555Z', 'lastLoginTimestamp': 1462988037555, 'lastUpdated': '2016-05-11T18:08:31.737Z', 'lastUpdatedTimestamp': 1462990111737, 'oldestDataUpdated': '2016-05-11T18:08:31.737Z', 'oldestDataUpdatedTimestamp': 1462990111737, 'registered': '2016-04-13T14:51:16.844Z', 'registeredTimestamp': 1460559076844, 'verified': '2014-10-26T04:10:08.294Z', 'verifiedTimestamp': 1414296608294, 'errorCode': 0, 'callId': '0', 'time': '2016-05-11T18:08:38.306Z', 'status': 'OK', 'errorMessage': '', 'statusMessage': '', 'requestParams': { 'connectWithoutLoginBehavior': 'alwaysLogin', 'defaultRegScreenSet': 'Login-web', 'defaultMobileRegScreenSet': 'Login-web', 'sessionExpiration': 0, 'apiDomain': 'us1.gigya.com', 'originalApiDomain': 'us1.gigya.com', 'APIKey': '0', 'lang': 'en' }, 'operation': '/accounts.getAccountInfo' },
      modURL = { comments: null, profile: null },
      metaData = { 'sitecode': siteCODE, 'registration': false };

  /** @sendModReq
   * Sends Comment Moderation Request
   * @param jsonData {object}
   * @param URL {string} url moderation is going to
   * sets cookie 'GIGMODE=.on' (why?)
  */
  function sendModReq(jsonData, URL) {
    document.cookie = 'GIGMODE=.on';
    postDataToURL(jsonData, URL);
  }

  /**
    * Posts data to a URL
    * @param postData {object} - Data sent to moderation must JSON.stringify() before passing in
    * @param postURL {string} - URL endpoint for moderation
  */
  function postDataToURL(postData, postURL) {
    postData = postData || testModData.profile;
    postURL = postURL || modURL.profile;

    debug.log('sending moderation to', postURL);

    $.ajax({
      url: postURL,
      xhrFields: { withCredentials: true },
      type: 'POST',
      data: postData,
      contentType: 'application/json; charset=UTF-8',
      dataType: 'json'
    }).done(function (response) {
      debug.log('response', response);
    }).fail(function (xhr, err) {
      debug.error('error', err);
    });
  }

  /** @cleanUpData
    * remove any extra data in object before we submit it to moderation
    * @param obj {object} - main object you want to use
    * @param sigList {object} - data signature to trim object to only use that the signature has
  **/
  function cleanUpData(obj, sigList) {
    debug.log('dirty obj', obj);
    sigList = sigList || testModData.profile;
    obj = obj || testDataToTrim;

    var objK = Object.keys(obj),
        verifyKey = null;

    sigList = Object.keys(sigList);

    objK.forEach(function (item) {
      verifyKey = sigList.indexOf(item);
      if (verifyKey <= -1) {
        delete obj[item];
      }
    });

    debug.log('new clean object', obj);

    return obj;
  }

  /** 
   * Determine if the photo and thumbnailURLs should be sent to moderation
   * If images have been cleared then don't moderate that field
  */
  function addImages(profileData, formData, modData) {
    var addedImages = false;

    if (profileData.photoURL !== formData['data.temp.profile.photoURL']) {
      modData.photoURL = formData['data.temp.profile.photoURL'];
      modData.thumbnailURL = formData['data.temp.profile.thumbnailURL'];
      addedImages = true;
    }
    return addedImages;
  }

  /**** Public functions
    * @param {object} data - response after posting a comment
    * inside we grab a new data object from gigya and combine it with the data {object}
    * we then clean up extra keys and submit this to the moderation call as the second .then in our setSettionData promise
  */
  function processComment(data) {
    var clean_data = null,
        URL = modURL.comments;

    debug.log('original data from comment', data);

    var sessionData = getNewSessionData();

    $.when(sessionData).then(function (res) {
      $.extend(res, data);
      res.metadata = metaData;

      debug.log('user from comment', data.user);
      data.user = cleanUpData(data.user, testModData.comment.profile);
      debug.log('clean user', data.user);

      res.profile = data.user;
      clean_data = cleanUpData(res, testModData.comment);
      if (clean_data.comment && clean_data.comment.commentText) {
        // remove extra spaces before sending to CMB
        clean_data.comment.commentText = clean_data.comment.commentText.replace(/\s{2,}/g, ' ');
      }
    }).done(function (res) {
      debug.log('Moderation URL', URL);
      debug.log('Data being sent to moderation', JSON.stringify(clean_data));

      sendModReq(JSON.stringify(clean_data), URL);
    }).fail(function (xhr, res) {
      debug.error(res);
      //throw(res);
    });
  }

  var processRegistration = function processRegistration(response) {
    var URL = modURL.profile,
        data = { profile: {}, metadata: { 'sitecode': siteCODE, 'registration': true } },
        UID = response.UID,
        UIDSignature = response.UIDSignature,
        signatureTimestamp = response.signatureTimestamp,
        profile = response.profile;


    if (response) {
      data.profile.email = profile.email;
      data.UID = UID;
      data.UIDSignature = UIDSignature;
      data.signatureTimestamp = signatureTimestamp;
    } else {
      debug.log('Could not moderate registration');
    }

    sendModReq(JSON.stringify(data), URL);
  };

  /** @processProfile
    * @param response {object} - from form submit callback
    * sends profile data to moderation
    * uses @setSessionData {promise} to get new data object from gigya
    * combines form data into new gigya object
    * we then run data through @cleanUpData {function}
    * we then pass data into @sendModReq {function} which passes data to moderation URL as an ajax POST
  */
  var processProfile = function processProfile(response) {

    var URL = modURL.profile,
        clean_data = void 0,
        nickname = void 0,
        lastName = void 0,
        firstName = void 0,
        email = void 0,
        isRegistration = response.screen === 'gigya-register-screen',
        formResponse = response.formData;

    var metaData = { 'sitecode': siteCODE, 'registration': isRegistration };

    var fullObj = response ? { profile: {}, metadata: metaData } : {};

    //  Get email
    email = formResponse['email'] || formResponse['profile.email'] || formResponse['data.temp.profile.email'] || '';
    nickname = formResponse['data.temp.profile.nickname'];
    lastName = formResponse['data.temp.profile.lastName'];
    firstName = formResponse['data.temp.profile.firstName'];
    $.extend(fullObj.profile, { email: email, nickname: nickname, lastName: lastName, firstName: firstName });

    var modImages = addImages(response.profile, formResponse, fullObj.profile);

    var sessionData = getNewSessionData();

    $.when(sessionData).then(function (res) {
      var cleanupScheme = isRegistration ? testModData.registration : modImages ? testModData.profile_photo : testModData.profile;
      $.extend(res, fullObj); // add session data
      cleanUpData(res.profile, cleanupScheme.profile); // cleanup profile data
      clean_data = cleanUpData(res, cleanupScheme); // cleanup outer data
    }).done(function (res) {
      debug.log('Moderation URL', URL);
      debug.log('Data being sent to moderation', JSON.stringify(clean_data));
      sendModReq(JSON.stringify(clean_data), URL);
    }).fail(function (xhr, res) {
      debug.error(res);
    });
  };

  return {
    processComment: processComment,
    processProfile: processProfile,
    processRegistration: processRegistration,
    setModURL: setModURL
  };
});

/***/ }),
/* 434 */
/***/ (function(module, exports) {

/**
 *Social upload third party mixes service
 */
SNI.Application.addService('gigya/socialUpload', function (application) {

  var loader = application.getService('dependency-loader'),
      debug = application.getService('logger').create('module.gigya.profile'),
      window = application.getGlobal('window'),
      gigyaSession = application.getService('gigya/getSession'),
      getNewSessionData = gigyaSession.getNewSessionData,
      getBrand = application.getService('gigya/getBrand'),
      widgetLoader = void 0,
      attachHandler = void 0,
      extUploadDate = void 0,
      su_settings = { //  BE provided settings
    api_key: '', //  Cloudinary API Key
    store_path: '', //  the path after *.sndimg.com/
    store_domain: '', //  the full sndimg domain
    static_src: '' //  the SU widget location
  },
      activeBrand = void 0,
      shortBrand = void 0,
      longBrand = void 0;

  var THUMBNAIL_WIDTH = 37,
      THUMBNAIL_HEIGHT = 37,
      PROFILE_WIDTH = 100,
      PROFILE_HEIGHT = 100;

  function configBrandVars(brandType) {
    // populate brands specific configs
    activeBrand = getBrand.basic();
    shortBrand = getBrand.specific('short');
    longBrand = getBrand.specific('long');

    return activeBrand;
  }

  /*  Make sure that our x-config is providing values for every SU setting.  Otherwise we fail the verification */
  function verifyConfig(settings) {
    $.extend(su_settings, settings);

    var fields = Object.keys(su_settings);
    var isEmpty = fields.some(function (key) {
      return typeof su_settings[key] === 'undefined' || su_settings[key] === '';
    });
    return !isEmpty;
  }

  /** resizePhoto()
   * Takes a photo and resizes it . For social avatars that don't contain our URL pattern, this should just return the original URL. CSS resizing will be needed in that case.
   * eg: resizePhoto("http://img.sndimg.com/foodnetwork/image/upload/v1/fn_avatar/20150123/RwNRyP1RL2hBa76itJBP_Screen%20Shot%202015-01-14%20at%204.30.28%20PM.png", 20, 20);
   * @return - URL of resized photo
  */
  var resizePhoto = function resizePhoto(photoURL, desiredWidth, desiredHeight) {
    var resizedPhotoURL = photoURL,
        width = parseInt(desiredWidth),
        height = parseInt(desiredHeight);
    // only allow integers in resized URL, otherwise return original
    if (width && height) {
      return resizedPhotoURL.replace('http://', '//').replace(/\/upload\/v1\//, '/upload/w_' + width + ',h_' + height + ',c_fill,g_face/v1/');
    } else {
      return resizedPhotoURL.replace('http://', '//');
    }
  };

  /*  
    Return date 
  */
  var getDate = function getDate() {
    var extDate = new Date(),
        year = extDate.getFullYear('YYYY'),
        month = extDate.getMonth() + 1,
        day = extDate.getDate(),
        folderDate = '' + year + ((month > 10 ? '' : '0') + month) + ((day > 10 ? '' : '0') + day); //  yyyymmdd

    return folderDate;
  };

  /**
   * createConfigValues:
   * Creates the values the social upload tool is looking for.
   * Globals that socialupload_widget.min.js looks for:
   * SU, SNI_COMMUNITY_SOCIAL_UPLOAD, SNI_COMMUNITY_SERVICES, SNI_COMMUNITY_FILE_UPLOAD
  */

  var createConfigValues = function createConfigValues(res) {

    if (typeof window.SU === 'undefined' || !window.SU) {
      window.SU = {};
    }
    if (typeof window.SNI_COMMUNITY_SOCIAL_UPLOAD === 'undefined' || !window.SNI_COMMUNITY_SOCIAL_UPLOAD) {
      window.SNI_COMMUNITY_SOCIAL_UPLOAD = {};
    }
    if (typeof window.SNI_COMMUNITY_SERVICES === 'undefined' || !window.SNI_COMMUNITY_SERVICES) {
      window.SNI_COMMUNITY_SERVICES = {};
    }
    if (typeof window.SNI_COMMUNITY_FILE_UPLOAD === 'undefined') {
      window.SNI_COMMUNITY_FILE_UPLOAD = {};
    }

    var asset_id = res.UID + '';

    extUploadDate = getDate();

    // Get brand codes to populate other variables
    configBrandVars();

    var socialUploadStoreOptions = {
      'location': 's3',
      'access': 'public',
      'path': '/' + shortBrand + '_avatar/' + extUploadDate + '/'
    };

    window.SNI_COMMUNITY_FILE_UPLOAD.STORE_OPTIONS_2 = socialUploadStoreOptions;
    window.SNI_COMMUNITY_FILE_UPLOAD.DEBUG_MODE_CONFIG = false;

    // attach debugger
    window.SU.debug = debug;

    window.SU.config = {
      // Path that precedes the S3 store path (see: store_options.path). Start with "/", but don't end with it.
      s3PathPrefix: '',
      // Simple Upload site code value. This will eventually replace SNI_COMMUNITY_SERVICES.SITE_CODE (set below).
      siteCode: longBrand + '_avatar',
      imageDomain: su_settings.store_domain + '/' + su_settings.store_path,

      // Defaults to "filepicker" if nothing is specified.
      imageService: 'cloudinary',
      static_domain: su_settings.static_src
    };

    // API setting
    window.SNI_COMMUNITY_SOCIAL_UPLOAD.APP_KEY = su_settings.api_key;

    // Asset config
    $.extend(true, window.SNI_COMMUNITY_SERVICES, {
      ASSET_ID: asset_id,
      ASSET_NAME: 'profile',
      ASSET_TYPE: shortBrand + '-community-profile',
      SITE_NAME: shortBrand + '-communit-avatar',
      SITE_CODE: shortBrand + '_avatar' // ignored if SU.config.siteCode present
    });
  };

  widgetLoader = function widgetLoader(customPath) {
    // load after we create namespace values
    var basePath = customPath || su_settings.static_src;
    var path = basePath + '/wrapper/js/core_social_upload_w.min.js';
    return loader.load(path);
  };

  attachHandler = function attachHandler() {
    // Below are the data sets that get passed into CP_SERVICE_FILE_UPLOAD.uploadFile() and CP_SERVICE_FILE_UPLOAD.submitForm().

    // Don't put quotes around the key/value pairs in 'upload_pick_options'!
    // For some bizarre reason, File Picker is picky (pun intended) about that.
    var upload_pick_options = {
      multiple: false,
      debug: false
    };

    // No longer used in submitForm! (?)
    var assetMetaData = {
      'asset_id': window.SNI_COMMUNITY_SERVICES.ASSET_ID,
      'asset_type': shortBrand + '-community-profile'
    };

    //  point to S3 bucket
    var store_options = {
      'location': 's3',
      'access': 'public',
      'path': '/' + shortBrand + '_avatar/' + extUploadDate + '/'
    };

    // These success & error functions demonstrate sample logic. Site owners
    // can customize it to their needs.
    var success = function success(data) {
      // get image - resize it
      var newImageURL = data[0]['url'],
          profileImgURL = resizePhoto(newImageURL, PROFILE_WIDTH, PROFILE_HEIGHT),
          thumbnailImgURL = resizePhoto(newImageURL, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT),
          currentURL = void 0,
          hiddenCurrentURL = void 0,
          thumbnailCurrentURL = void 0,
          $avatar = $('#fnCommunityAvatarImg'),
          $hidden = $('#fnCommunityAvatarHiddenField'),
          $thumbnail = $('#fnCommunityThumbnailHiddenField');

      // Save current values
      currentURL = $avatar.attr('src');
      hiddenCurrentURL = $hidden.val();
      thumbnailCurrentURL = $thumbnail.val();

      // Set to each field - note: avatar src does not necessarily === hidden field data
      $avatar.data('old-img', currentURL);
      $hidden.data('old-img', hiddenCurrentURL);
      $thumbnail.data('old-img', thumbnailCurrentURL);

      // Update the Avatar image so the user sees the new avatar on the form
      $avatar.attr('src', profileImgURL);
      // Update the hidden Avatar field so it submits when the user clicks "Save"
      $('#fnCommunityAvatarHiddenField').attr('value', profileImgURL);
      $('#fnCommunityThumbnailHiddenField').attr('value', thumbnailImgURL);
      $('#btn-profile-remove').show();
      debug.log(profileImgURL + '\n << profile image URL added');
    };

    var error = function error(_error) {
      alert('Error occured while uploading file ' + _error);
    };

    $('.btn-upload-filepicker').click(function (e) {
      if (window.CP_SERVICE_FILE_UPLOAD && window.CP_SERVICE_FILE_UPLOAD.uploadFile) {
        window.CP_SERVICE_FILE_UPLOAD.uploadFile(success, error, assetMetaData, upload_pick_options, store_options);
      } else {
        debug.log('File picker not available');
      }
    }).show();
  };

  return {
    init: function init(config) {
      // get session data
      var SESSION_DATA = getNewSessionData(),
          initSU = false;

      /*  config values provided here should override any other defaults */
      if (config && config.su_settings) {
        initSU = verifyConfig(config.su_settings);
      }

      if (!initSU) {
        debug.warn('Incomplete config, cannot initialize Social uploader');
        return;
      }

      $.when(SESSION_DATA).done(function (res) {
        // set config data using new session values
        createConfigValues(res);

        // load SU widget
        var SUwidget = widgetLoader();

        // add click event handler
        SUwidget.then(function () {
          debug.log('socialupload_widget.min.js', 'loaded');
          attachHandler();
        }).catch(function () {
          debug.log('unable to load loader');
        });
      }).fail(function (xhr, fail) {
        debug.log('SU could not get session data');
      });
    },

    widgetLoader: widgetLoader,
    getDate: getDate,
    customInit: function customInit(configFunction, options) {
      if (typeof configFunction === 'function') {
        configFunction();
        // return jQuery deferred of the social upload widget when the deferred is done then the SU widget should be avaiable and handler can be attached
        return widgetLoader(options.path);
      }
    },

    resizePhoto: resizePhoto
  };
});

/***/ }),
/* 435 */
/***/ (function(module, exports) {

SNI.Application.addService('gigya/templates', function (application) {

  var device = application.getService('device-type');

  /**
    Returns the relevant templates
    @param {object} options - contains the layout (site ID) and comment type (comment or review)
  */
  function getTemplates(options, type) {
    // Templates
    var commentType = options.commentType;

    var postButton = commentType === 'comment' ? '<span class="comments-is-comment">Comment</span>' : '<span class="comments-is-review">Review</span>';

    var TEMPLATES = {
      RATINGONLY: '<span class="gig-rating-stars"></span><span class="gig-rating-readReviewsLink"></span>',
      RATING: '<span class="gig-rating-stars"></span><span class="gig-rating-readReviewsLink gig-rating-writeYourReview"></span>',
      ALL: {
        header: '\n              <div class="gig-comments-header-left"></div>\n              <div class="gig-comments-header-right gig-comments-linksContainer">\n                <div class="gig-comments-sort fig btn">Sort by</div>\n              </div>'.replace(/\s{2,}/g, ''),
        comment: '\n              <div class="gig-comment-photo"></div>\n              <div>\n                <div>\n                  <div class="gig-comment-content">\n                    <div class="gig-comment-header">\n                      <div class="gig-comment-header-left">\n                        <span class="gig-comment-username"></span>\n                        <span class="gig-comment-time"></span>\n                      </div>\n                    </div>\n                    <div class="gig-comment-title m-Rating"></div>\n                    <div class="gig-comment-status"></div>\n                    <div class="gig-comment-body"></div>\n                    <div class="gig-comment-footer">\n                      <div class="gig-comment-footer-left">\n                        <ul class="gig-comments-linksContainer">\n                          <li>\n                            <div class="gig-comment-vote-pos"></div>\n                            <div class="gig-comment-vote-total"></div>\n                          </li>\n                          <li class="gig-comment-replyLink" data-type="comment-reply-toggle">Comment</li>\n                          <li class="gig-comment-deleteLink"></li>\n                        </ul>\n                      </div>\n                      <div class="gig-comment-footer-right">\n                        <div class="gig-comment-flag"></div>\n                      </div>\n                    </div>\n                  </div>\n                  <div class="gig-comment-replybox gig-comments-composebox" data-replybox></div>\n                  <div class="gig-comment-replies"></div>\n                </div>\n              </div>'.replace(/\s{2,}/g, ''),
        myReview: '\n              <div class="gig-composebox-photo"></div>\n              <div class="gig-composebox-data">\n                <div class="gig-selfreview-header">\n                  <div class="gig-selfreview-header-left">\n                    <div class="gig-selfreview-nameAndLogout">\n                      <div class="gig-selfreview-yourReview">Your Review</div>\n                    </div>\n                  </div>\n                </div>\n                <div class="gig-selfreview-body-container">\n                  <span class="gig-selfreview-field-title">Review:</span>\n                  <span class="gig-selfreview-body"></span>\n                </div>\n                <div class="gig-selfreview-ratings"></div>\n              </div>'.replace(/\s{2,}/g, ''),
        composebox: ('\n              <div class="comments-compose-container">\n                <div class="gig-composebox-close" data-type="comments-cancel-btn" style="dispay:none;"></div>\n                <div class="gig-comments-composebox gig-composebox-open">\n                  <div class="gig-composebox-error"></div>\n                  <div class="gig-composebox-photo"></div>\n                  <div class="gig-composebox-data">\n                    <div class="gig-composebox-editor gig-composebox-editor-with-sidebar">\n                      <ul class="gig-composebox-sidebar">\n                        <li class="gig-composebox-sidebar-button gig-composebox-sidebar-font"></li>\n                      </ul>\n                      <div class="gig-composebox-textarea"></div>\n                    </div>\n                    <div class="gig-composebox-ratings m-Rating"></div>\n                    <div class="gig-composebox-mediaItem"></div>\n                    <div class="gig-composebox-footer">\n                      <div class="gig-composebox-footer-right">\n                        <div class="gig-composebox-post gig-comments-button">Post ' + postButton + '<span class="comments-is-reply" style="display:none;">Comment</span></div>\n                        <span data-type="comments-cancel-btn" class="gig-composebox-cancel gig-comments-button">Cancel</span>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>').replace(/\s{2,}/g, '')
      }
    },
        MOBILE = {
      ALL: {
        composebox: ('\n              <div class="comments-compose-container">\n                <div class="gig-composebox-error"></div>\n                <div class="gig-composebox-photo"></div>\n                <div class="gig-composebox-data">\n                  <div class="gig-composebox-editor gig-composebox-editor-with-sidebar">\n                    <ul class="gig-composebox-sidebar">\n                      <li class="gig-composebox-sidebar-button gig-composebox-sidebar-font"></li>\n                    </ul>\n                    <div class="gig-composebox-textarea"></div>\n                  </div>\n                  <div class="gig-composebox-ratings m-Rating"></div>\n                  <div class="gig-composebox-mediaItem"></div>\n                  <div class="gig-composebox-footer">\n                    <div class="gig-composebox-footer-right">\n                      <div class="gig-composebox-post gig-comments-button">Post ' + postButton + '<span class="comments-is-reply" style="display:none;">Comment</span></div>\n                      <span data-type="comments-cancel-btn" class="gig-composebox-cancel gig-comments-button">Cancel</span>\n                    </div>\n                  </div>\n                </div>\n              </div>').replace(/\s{2,}/g, ''),
        comment: '\n              <div class="gig-comment-content">\n                <div class="gig-comment-photo"></div>\n                <div class="gig-comment-header">\n                  <div class="gig-comment-header-left">\n                    <span class="gig-comment-username"></span>\n                    <span class="gig-comment-time"></span>\n                  </div>\n                  <div class="gig-comment-title m-Rating"></div>\n                </div>\n                <div class="gig-comment-status"></div>\n                <div class="gig-comment-body"></div>\n                <div class="gig-comment-footer comment-footer-options">\n                  <div class="gig-comment-footer-left">\n                    <ul class="gig-comments-linksContainer">\n                      <li>\n                        <div class="gig-comment-vote-pos"></div>\n                        <div class="gig-comment-vote-total"></div>\n                      </li>\n                      <li class="gig-comment-replyLink" data-type="comment-reply-toggle">Comment</li>\n                      <li class="gig-comment-deleteLink"></li>\n                    </ul>\n                  </div>\n                  <div class="gig-comment-footer-right">\n                    <div class="gig-comment-flag"></div>\n                  </div>\n                </div>\n              </div>\n              <div class="gig-comment-replybox gig-comments-composebox" data-replybox></div>\n              <div class="gig-comment-replies"></div>'.replace(/\s{2,}/g, '')
      }
    };

    if (device.isMobile) {
      TEMPLATES.ALL.composebox = MOBILE.ALL.composebox;
      TEMPLATES.ALL.comment = MOBILE.ALL.comment;
    }

    return TEMPLATES;
  }

  return {
    getTemplates: getTemplates
  };
});

/***/ }),
/* 436 */
/***/ (function(module, exports) {

SNI.Application.addService('gigya/tracking', function (application) {

  var debug = application.getService('logger').create('service.gigya.tracking'),
      check = application.getService('check').new(debug),
      gigya = check.exists('gigya.accounts') ? application.getGlobal('gigya') : false,
      getBrand = application.getService('gigya/getBrand');

  var trackingBrand = getBrand.specific('tracking');

  function getTimeStamp() {
    var utc = new Date();
    return utc.toISOString();
  }

  function isFirstVisit(res) {
    var data = res.data;
    if (data && check.exists('user.visited.' + trackingBrand, data)) {
      return data.user.visited[trackingBrand] === '';
    } else {
      return true;
    }
  }

  function logGigyaUpdate(res) {
    if (res.errorCode === 400006) {
      debug.log('Could not update first visit timestamp for ' + trackingBrand);
    }
  }

  function updateGigyaData() {
    var info = { user: { visited: {} } };
    var today = getTimeStamp();
    info.user.visited[trackingBrand] = today;

    if (gigya) {
      debug.log('Setting first time visit for ' + trackingBrand + ' @' + today);
      gigya.accounts.setAccountInfo({ data: info, callback: logGigyaUpdate });
    }
  }

  function setFirstVisitedTimeStamp(isRegistration, response) {
    if (isRegistration) {
      trackRegistration();
    }
    if (isFirstVisit(response)) {
      updateGigyaData();
    }
  }

  /*
    Saves user's nickname and login status for Analytics tracking
    @param loginInfo = {state, nickname, response} state is a boolean that we map to isLoggedIn, response is the response data from Gigya
  */
  function setLoginState(loginInfo) {
    var isLoggedIn = loginInfo.state,
        nickname = loginInfo.nickname,
        response = loginInfo.response;

    var UID = isLoggedIn ? response.UID : '';

    debug.log('isLoggedIn:', isLoggedIn, '| nickname: ' + nickname);

    try {
      localStorage.setItem('_gigya_login_status', isLoggedIn);
      localStorage.setItem('_gigya_login_user_name', nickname);
      localStorage.setItem('_gigya_login_user_id', UID);
    } catch (e) {
      document.cookie = '_gigya_login_status=' + isLoggedIn;
      document.cookie = '_gigya_login_user_name=' + nickname;
      document.cookie = '_gigya_login_user_id=' + UID;
    }
  }

  function trackRegistration() {
    if (check.exists('SNI.Analytics.trackGigyaRegistration')) {
      SNI.Analytics.trackGigyaRegistration(true);
      debug.log('New user registration');
    }
  }

  return {
    setFirstVisitedTimeStamp: setFirstVisitedTimeStamp,
    setLoginState: setLoginState
  };
});

/***/ }),
/* 437 */
/***/ (function(module, exports) {

SNI.Application.addService('hotspot', function (application) {
  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var service = void 0,
      cache = void 0,
      debug = application.getService('logger').create('service.hotspot'),
      check = application.getService('check').new(debug),
      template = application.getService('template'),
      defaults = void 0;

  defaults = {
    timeout: 60000,
    hotspotSelector: '.hotspot',
    rendererTypes: {
      product: 'product'
    }
  };

  cache = {};

  function outOfRange(n) {
    return n <= 0 || n >= 1;
  }

  function adjustHotspot(rendition, hotspot) {
    hotspot.x = (hotspot.x - rendition.x) / rendition.w;
    hotspot.y = (hotspot.y - rendition.y) / rendition.h;
    return hotspot;
  }

  function toPercentage(n) {
    return Math.round(n * 100);
  }

  function adjustUrl(url) {
    var base = application.getGlobal('cqBasePage'),
        baseAdjusted = void 0,
        currentUrl = void 0;

    currentUrl = url || '';

    if (currentUrl.indexOf(defaults.hotspotSelector) !== -1) {
      return currentUrl;
    }

    if (base) {
      base = base.replace(/^https?:\/\/[^\/]*/, '');
      baseAdjusted = base;

      if (baseAdjusted.indexOf('.html') === -1) {
        baseAdjusted += defaults.hotspotSelector;
      } else {
        baseAdjusted = baseAdjusted.replace('.html', '.hotspot.html');
      }

      currentUrl = currentUrl.replace(base, baseAdjusted);
    } else {
      currentUrl = currentUrl.replace('.html', '.hotspot.html');
    }

    return currentUrl;
  }

  function getHref(hotspot) {
    return hotspot.url || '#';
  }

  function getTitle(hotspot) {
    return hotspot.title || '';
  }

  function getProductDom(hotspot) {
    var self = this,
        currentTemplate = $(template.hotspotProduct()),
        sponsorContent = void 0,
        productImage = void 0;

    productImage = currentTemplate.find('.hotspotProductImage');

    if (hotspot.image) {
      productImage.find('img').attr({
        src: hotspot.image,
        alt: hotspot.title,
        title: hotspot.title
      });
    } else {
      productImage.remove();
    }

    currentTemplate.find('h2').html(hotspot.title);

    currentTemplate.find('.hotspotProductDescription').html(hotspot.caption);

    if (hotspot.sponsorLogo) {

      if (hotspot.sponsorUrl) {
        sponsorContent = $('<a>').attr({ href: hotspot.sponsorUrl, target: '_blank' });
      } else {
        sponsorContent = $('<div>');
      }

      $('<img/>').attr({ src: hotspot.sponsorLogo, alt: '' }).appendTo(sponsorContent);

      currentTemplate.find('.hotspotProductSponsor').append(sponsorContent);
    }

    currentTemplate.off('click.moreProduct');
    currentTemplate.on('click.moreProduct', '.hotspotProductMore button, .hotspotProductImage img, .hotspotProductTitle, .hotspotProductDescription', function (e) {
      e.preventDefault();
      self.moreInfo(hotspot);
    });

    if (self.settings.hotspotShowAll) {
      currentTemplate.off('click.productAll');
      currentTemplate.on('click.productAll', '.hotspotProductAll a', function (e) {
        e.preventDefault();
        self.displayAll(self.hotspots);
      });
    } else {
      currentTemplate.find('.hotspotProductAll').remove();
    }

    currentTemplate.off('click.productOverlayClose');
    currentTemplate.on('click.productOverlayClose', '.hotspotProductOverlayClose', function (e) {
      e.preventDefault();
      self.removeProduct();
      return false;
    });

    return currentTemplate;
  }

  function getAllDom() {
    var self = this,
        data = self.hotspotsAll,
        currentTemplate = $(template.hotspotProductsAll()),
        templateBlockList = void 0,
        templateBlock = void 0;

    templateBlockList = currentTemplate.find('.block-list-inline ul');
    templateBlock = currentTemplate.find('.block').detach();

    $.each(data, function (index, imageHotspots) {

      $.each(imageHotspots, function (index, hotspot) {

        var product, caption, hotspotImage;

        if (hotspot.dataType !== 'product') {
          return;
        }

        caption = hotspot.caption;
        product = templateBlock.clone().appendTo(templateBlockList);

        hotspotImage = product.find('.hotspotProductImage img');
        if (hotspot.image) {
          hotspotImage.attr({
            src: hotspot.image,
            alt: hotspot.title,
            title: hotspot.title
          });
        } else {
          if (self.settings.isMobile) {
            hotspotImage.parent().remove();
          } else {
            hotspotImage.remove();
          }
        }

        product.find('.hotspotProductTitle a').html(hotspot.title).attr('href', hotspot.url);
        product.find('.hotspotProductDescription').html(caption);

        product.off('click.moreInfo');
        product.on('click.moreInfo', '.hotspotProductImage img, .hotspotProductTitle a, .hotspotProductDescription', function (e) {
          e.preventDefault();
          self.moreInfo(hotspot);
        });
      });
    });

    currentTemplate.off('click.allBack');
    currentTemplate.on('click.allBack', '.hotspotProductsAllBack button, .hotspotProductOverlayClose', function (e) {
      e.preventDefault();
      self.removeAll();
    });

    return currentTemplate;
  }

  function removeProduct() {
    var self = this;
    if (self.modalProduct) {
      self.modalProduct.removeClass('active hotspotFixed');
      setTimeout(function () {
        self.modalProduct.remove();
      }, 510);
    }
  }

  function removeAll() {
    var self = this,
        isPhotoLibrary = self.settings.pageTypes.photoLibrary,
        isInline = self.settings.pageTypes.inline,
        isVertical = self.settings.pageTypes.vertical,
        isMobile = self.settings.isMobile;

    if (self.modalAll) {

      if (!isPhotoLibrary && !isVertical) {
        window.scrollTo(0, 0);
      }

      if (!isMobile && (isInline || isVertical)) {
        $('body').removeClass('pv-no-scroll');
      }

      self.modalAll.removeClass('active hotspotFixed');

      setTimeout(function () {
        if (isVertical) {
          $(window).scrollTop(self.settings.scrollOffset);
        }
        self.modalAll.remove();
      }, 300);
    }
  }

  function moreInfo(hotspot) {
    var eID = void 0,
        eName = void 0,
        room = void 0,
        hText = void 0,
        mdManager = application.getGlobal('mdManager'),
        legacy_s = application.getGlobal('s'),
        url = void 0;

    if (check.exists(['s', 'mdManager'])) {
      eID = mdManager.getParameterString('EditorialTracking').replace(/[^a-z0-9\s]/gi, '') + ' Photo Gallery Hotspots';
      eName = mdManager.getParameterString('Title').replace(/[^a-z0-9\s]/gi, '');
      room = mdManager.getParameterString('CurrentRoom').replace(/[^a-z0-9\s]/gi, '') + ' Pictures';
      hText = hotspot.title.replace(/[^a-z0-9\s]/gi, '');

      legacy_s.linkTrackVars = 'prop1,prop2,eVar46,eVar47,eVar48,events';
      legacy_s.linkTrackEvents = 'event48';
      legacy_s.events = 'event48';
      legacy_s.eVar46 = eID;
      legacy_s.eVar47 = eID + ':' + hText;
      legacy_s.eVar48 = eID + ':Photos:' + eName + ':' + room + ':' + hText;
      legacy_s.tl(this, 'o', eID + ':Sponsor Site Click');
      legacy_s.eVar46 = '';
      legacy_s.eVar47 = '';
      legacy_s.eVar48 = '';
    }

    url = hotspot.url;

    if (url) {
      if (!window.open(url)) {
        window.location = url;
      }
    }
  }

  function displayAll() {
    var self = this,
        isPhotoLibrary = void 0,
        isInline = void 0,
        isVertical = void 0,
        isMobile = void 0;

    isPhotoLibrary = self.settings.pageTypes.photoLibrary;
    isInline = self.settings.pageTypes.inline;
    isVertical = self.settings.pageTypes.vertical;
    isMobile = self.settings.isMobile;

    if (!isPhotoLibrary && !isVertical || isPhotoLibrary && isMobile) {
      self.settings.scrollOffset = $(window).scrollTop();
      window.scrollTo(0, 0);
    }

    if (isPhotoLibrary && !isMobile) {
      self.modalAll = self.getAllDom().appendTo('.pv-stage');
    } else {
      self.modalAll = self.getAllDom().appendTo('body');
      if ((isInline || isVertical) && !isMobile) {
        self.modalAll.css('width', '100%');
        $('body').addClass('pv-no-scroll');
      }
    }

    if (isMobile) {
      self.modalAll.css('min-height', $(document).height());
    }

    if (self.settings.hotspotClass) {
      self.modalAll.addClass(self.settings.hotspotClass);
    }

    setTimeout(function () {
      self.modalAll.addClass('active');
      if (isVertical) {
        $('.hotspotProductsAll, .hotspotProductsBackdropAll').addClass('vertical-hotspot');
      }
    }, 1);

    setTimeout(function () {
      self.modalAll.addClass('hotspotFixed');
    }, 300);

    setTimeout(function () {
      self.removeProduct();
    }, 300);
  }

  function display(hotspot, hotspotsAll, settings) {
    var self = this,
        isPhotoLibrary = void 0,
        isInline = void 0,
        isVertical = void 0,
        isMobile = void 0;

    self.settings = settings || {};
    isPhotoLibrary = self.settings.pageTypes.photoLibrary;
    isInline = self.settings.pageTypes.inline;
    isVertical = self.settings.pageTypes.vertical;
    isMobile = self.settings.isMobile;

    if (!isPhotoLibrary && !isInline || isPhotoLibrary && isMobile) {
      self.settings.scrollOffset = $(window).scrollTop();
      window.scrollTo(0, 0);
    }

    if (isPhotoLibrary && !isMobile) {
      self.modalProduct = self.getProductDom(hotspot).appendTo('.pv-stage');
    } else if (isInline && !isMobile) {
      self.modalProduct = self.getProductDom(hotspot).appendTo('.rsOverflow ');
    } else {
      self.modalProduct = self.getProductDom(hotspot).appendTo('body');
    }

    if (isMobile) {
      self.modalProduct.css('min-height', $(document).height());
    }

    if (self.settings.hotspotClass) {
      self.modalProduct.addClass(self.settings.hotspotClass);
    }

    setTimeout(function () {
      self.modalProduct.addClass('active');
      if (isVertical) {
        $('.hotspotProduct, .hotspotProductBackdrop').addClass('vertical-hotspot');
      }
    }, 10);

    setTimeout(function () {
      self.modalProduct.addClass('hotspotFixed');
    }, 1000);

    self.hotspotsAll = hotspotsAll;

    self.modalProduct.off('click.productOverlayClose');
    self.modalProduct.on('click.productOverlayClose', '.hotspotProductOverlayClose a', function (e) {
      e.preventDefault();
      self.removeProduct();

      if (isPhotoLibrary || isVertical) {
        $(window).scrollTop(self.settings.scrollOffset);
      }
    });

    $('.hotspotProduct').off('click.hotspotProduct');
    $('.hotspotProduct').on('click.hotspotProduct', function (e) {
      if (e.target !== this) {
        return;
      }
      self.removeProduct();
      if (isPhotoLibrary || isVertical) {
        $(window).scrollTop(self.settings.scrollOffset);
      }
    });
  }

  function selectRenderer(type) {
    var api = void 0;
    switch (type) {
      case defaults.rendererTypes.product:
        api = {
          getHref: getHref,
          getTitle: getTitle,
          display: display,
          displayAll: displayAll,
          getProductDom: getProductDom,
          getAllDom: getAllDom,
          removeProduct: removeProduct,
          removeAll: removeAll,
          moreInfo: moreInfo
        };
        break;
    }

    return api;
  }

  function adjustData(data) {

    var newData = void 0,
        imageUrl = void 0;

    newData = {};

    $.each(data, function () {

      var image = this;

      image.hotspots = $.map(image.hotspots, function (hotspot, index) {

        hotspot.dataType = hotspot.dataType || 'product';
        hotspot = adjustHotspot(image.rendition, hotspot);

        if (outOfRange(hotspot.x) || outOfRange(hotspot.y)) {
          return null;
        }

        hotspot.x = toPercentage(hotspot.x);
        hotspot.y = toPercentage(hotspot.y);

        hotspot.renderer = selectRenderer(hotspot.dataType);

        return hotspot;
      });

      imageUrl = image.image.replace(/.rend.*/, '');
      newData[imageUrl] = image.hotspots;
    });

    return newData;
  }

  function get(settings) {
    var deferred = void 0,
        config = void 0;

    config = settings || {};
    config.url = config.url || window.location.pathname;
    config.url = adjustUrl(config.url);
    deferred = $.Deferred();

    if (cache[config.url]) {
      deferred.resolve(cache[config.url]);
      return deferred.promise();
    }

    $.ajax({
      url: config.url,
      timeout: config.timeout || defaults.timeout,
      dataType: 'json'
    }).done(function (data, textStatus, jqXHR) {

      if (data.error) {
        deferred.reject(jqXHR, 'error', '');
        return;
      }

      data = adjustData(data);
      cache[config.url] = data;
      deferred.resolve(data);
    }).fail(function (jqXHR, textStatus, errorThrown) {
      deferred.reject(jqXHR, textStatus, errorThrown);
    });
    return deferred.promise();
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  service = {
    get: get,
    adjustUrl: adjustUrl,
    adjustData: adjustData,
    adjustHotspot: adjustHotspot,
    getHref: getHref,
    getTitle: getTitle,
    display: display,
    displayAll: displayAll,
    getProductDom: getProductDom,
    getAllDom: getAllDom,
    removeProduct: removeProduct,
    removeAll: removeAll,
    moreInfo: moreInfo,
    selectRenderer: selectRenderer,
    toPercentage: toPercentage
  };

  return service;
});

/***/ }),
/* 438 */
/***/ (function(module, exports) {

SNI.Application.addService('media-stream', function (application) {
  'use strict';

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var service = void 0,
      ssHistory = void 0,
      ssIndex = void 0,
      instance = void 0,
      defaults = void 0;

  var debug = application.getService('logger').create('service.media-stream');
  var check = application.getService('check').new(debug);
  var metadata = application.getService('metadata');
  var deviceType = application.getService('device-type');
  var router = application.getService('router');

  defaults = {};

  function setInstance(newInstance) {
    instance = newInstance;
  }

  function getInstance() {
    if (typeof instance !== 'undefined') {
      return instance;
    } else {
      return false;
    }
  }

  function recordCurrentAndPreviousSS(slideshow) {
    if (check.supports('sessionStorage')) {
      var viewedSlideshows = sessionStorage.getItem('viewedSlideshows') || '[]',
          found = false;

      viewedSlideshows = JSON.parse(viewedSlideshows);

      $.each(viewedSlideshows, function () {
        if (slideshow.url === this.url) {
          found = true;
          return;
        }
      });

      if (!found) {
        viewedSlideshows.push({ 'url': slideshow.url });
      }

      if (!ssHistory) {
        ssHistory = [];
      }

      if (!ssIndex) {
        ssIndex = 0;
      }

      ssHistory.push({
        'url': slideshow.url,
        'title': slideshow.title
      });

      sessionStorage.setItem('viewedSlideshows', JSON.stringify(viewedSlideshows));
    }
  }

  function setupNextSS(mediaStreamObject) {
    if (check.supports('sessionStorage')) {
      var viewedSlideshows = sessionStorage.getItem('viewedSlideshows') || '[]',
          viewed = false,
          foundNonViewedSS = false;

      viewedSlideshows = JSON.parse(viewedSlideshows);

      $.each(mediaStreamObject, function (index) {

        var currentStreamItem = this,
            currentUrlMatch = '',
            currentUrl = void 0;

        $.each(viewedSlideshows, function (index) {
          if (this.url.lastIndexOf(currentStreamItem.url) > -1) {
            viewed = true;
            return;
          }
        });

        if (viewed) {
          viewed = false;
        } else {
          foundNonViewedSS = true;
          /*
            REX-414 adding some checks to see if there is a protocol at all... if there isn't then we don't want to run match on the URL
          */
          currentUrl = currentStreamItem.url.match(/^https?:\/\/[^\/]*/);
          if (currentUrl) {
            currentUrlMatch = currentUrl[0];
          }
          if (document.location.origin === currentUrlMatch || currentStreamItem.url.indexOf('http') === -1) {
            defaults.nextSS = currentStreamItem;
            return false;
          }
        }
      });

      if (!foundNonViewedSS) {
        defaults.nextSS = mediaStreamObject[0];
      }
    }
  }

  function getNextSS() {
    if (defaults.nextSS) {
      return defaults.nextSS;
    } else {
      return false;
    }
  }

  function getPreviousSS() {
    if (ssHistory && ssIndex > 0) {
      return ssHistory[ssIndex - 1];
    } else {
      return false;
    }
  }

  function gotoSS(direction) {
    var fullURL = defaults.nextSS && defaults.nextSS.url ? defaults.nextSS.url : false,
        previousUrl = void 0;

    if (!fullURL) {
      return false;
    }

    defaults.direction = direction;
    // eslint-disable-next-line no-restricted-properties
    window.cqBasePage = fullURL;

    if (direction === 'next') {
      ssIndex = ssIndex + 1;
    } else {
      fullURL = ssHistory[ssIndex - 1].url;
      ssIndex = ssIndex - 1;
      ssHistory.pop();
      ssHistory.pop();
    }

    defaults.consecutiveGallery = metadata.getGalleryData();

    if (typeof defaults.consecutiveGallery !== 'undefined') {
      defaults.consecutiveGallery++;

      application.broadcast('mediaStream.consecutiveGalleryUpdated', {
        consecutiveGallery: defaults.consecutiveGallery
      });
    }

    if ($('.container-site').length && $('.container-site').hasClass('inline-horizontal') && !deviceType.isMobile) {
      defaults.$curtain = $('.area').clone().addClass('cloneArea').removeClass('area');
      defaults.$curtain.find('.rsArrowLeft').remove();
      defaults.ajaxScrollOffset = $(window).scrollTop();
    }

    application.broadcast('stateChanged', {
      target: 'content',
      href: fullURL
    });

    defaults.streaming = true;

    previousUrl = fullURL;
    application.broadcast('previousUrlChanged', {
      previousURL: previousUrl
    });
  }

  function initializeNewContent(data) {
    if (defaults.direction === 'previous') {
      application.broadcast('mediaStream.headingToPreviousSS');
    } else {
      application.broadcast('mediaStream.headingToNextSS');
    }

    if (data.context.hasClass('area')) {
      var timestamp = new Date().getTime(),
          previousURLMediaStream = router.getPreviousURL();

      application.broadcast('stateChanged', {
        gallery: timestamp,
        launcher: true,
        href: previousURLMediaStream
      });

      // if (deviceType.isMobile && !$('.container-site').hasClass('vertical') || ($('.container-site').length && !$('.container-site').hasClass('inline-horizontal'))) {
      //   $('.photo-gallery-collection').photoLauncher('launchGallery');
      // }
    }
  }

  function lowerCurtain() {
    if ($('.container-site').length && $('.container-site').hasClass('inline-horizontal') && !deviceType.isMobile) {
      defaults.$curtain.insertAfter('.area');
      $('.area').hide();
      $(window).scrollTop(defaults.ajaxScrollOffset);
    }
  }

  function raiseCurtain() {
    if ($('.container-site').length && $('.container-site').hasClass('inline-horizontal') && !deviceType.isMobile) {
      defaults.$curtain.remove();
      $('.area').show();
      if (check.exists('SniAds.Gallery')) {
        application.getGlobal('SniAds').Gallery.reset();
      }
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  service = {
    recordCurrentAndPreviousSS: recordCurrentAndPreviousSS,
    setupNextSS: setupNextSS,
    getNextSS: getNextSS,
    getPreviousSS: getPreviousSS,
    gotoSS: gotoSS,
    initializeNewContent: initializeNewContent,
    lowerCurtain: lowerCurtain,
    raiseCurtain: raiseCurtain,
    setInstance: setInstance,
    getInstance: getInstance
  };

  return service;
});

/***/ }),
/* 439 */
/***/ (function(module, exports) {

/**
 * Modal
 * @author Matt Heisig
 * This module provides a class to handle the creation and control of modals. The basic class creates an empty wrapper,
 * turns it into a modal using the Bootstrap modal, loads content into the modal if provided, and sets up some
 * basic event handlers: show, hide, dismiss, toggle. Returns the Modal class as well an open() function that serves
 * as a wrapper around the Modal class with some presets. The examples below are equivalent, they just provide
 * different levels of control over the modal during creation.
 *
 * @example If you want fine-grained control of the modal instance:
 * var modal = context.getService('modal');
 *
 * var myModal = new modal.create({
 *   modalId: 'emailModal'
 * });
 *
 * myModal.loadContent({
 *   override:  $(modalContent)
 * });
 *
 * myModal.show();
 *
 *
 * @example If you want to pass an ID and some content and not worry about the rest:
 * modal.open('emailModal', modalContent);
 */

SNI.Application.addService('modal', function (application) {

  var modUtil = application.getService('utility');
  var debug = application.getService('logger').create('service.modal');
  var check = application.getService('check').new(debug);
  var emulationPlugin = check.jqueryPlugin('emulateTransitionEnd');
  var template = application.getService('template');
  var modals = [];
  var openClass = 'modal-open';
  var openClassForce = 'modal-force-open';

  /**
   * Modal class definition.
   * @param {object} options    Options to override the defaults
   */
  var Modal = function Modal(options) {

    /** Bail out if no ID is provided */
    if (!options.modalId) {
      return;
    }

    var self = this,
        defaults = {
      content: '',
      closeButtonParent: '',
      hasTransition: false,
      useDefaultTemplate: true,
      plugin: {
        isVideoOverlay: false,
        backdrop: true,
        show: false,
        keyboard: true
      }
    };

    self.settings = $.extend(true, {}, defaults, options);

    /** Register the Bootstrap plugin that does most of the heavy lifting
     *  Now allows the use of two override variables:
     *  backdropAlternate - allows for custom css on a background element
     *  noScroll - allows mobile modal do not allow scrolling when modal is up*/
    if (self.settings.overrides) {
      _registerPlugin(self.settings.overrides);
    } else {
      _registerPlugin();
    }

    /** Add a shell container to the bottom of the DOM that will receive the modal content */
    _addModalContainer(self.settings.modalId);

    self.$container = $('#' + self.settings.modalId);

    /** If we've got content at instantiation, go ahead and add it to the container */
    if (self.settings.content) {
      if (self.settings.content instanceof jQuery) {
        self.settings.content = {
          override: self.settings.content
        };
      }
      self.loadContent(self.settings.content);
    }

    // Turn the DOM node into a modal using Bootstrap's plugin
    self.$container.modal(self.settings.plugin);

    // We're done, so broadcast loaded
    application.broadcast('modal.loaded', {
      modal: self
    });

    debug.log(this.settings.modalId + ' instantiated');
    modals.push(this);
  };

  Modal.prototype.show = function () {
    var self = this,
        hasTransition = this.settings.hasTransition;

    self.$container.modal('show');

    if (hasTransition) {
      self.$container.addClass('has-Transition');
    }
    // unbind and cleanup anything that might have leaked out
    self.$container.off('click', '[data-dismiss="modal"]');
    $('body').off('keyup.modaldismiss');

    /** Attach this to the body so that we can escape close it no matter where the user's insertion point is */
    $('body').on('keyup.modaldismiss', $.proxy(function (e) {
      e.which === 27 && this.hide();
      debug.log('escape key pressed on ' + this.settings.modalId);
    }, self));

    /** Setup handler on the close button */
    self.$container.on('click', '[data-dismiss="modal"]:first', function (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      self.hide();
    });

    application.broadcast('modal.shown', {
      modal: self
    });

    application.startAll(self.$container);

    debug.log(this.settings.modalId + ' modal shown');
  };

  Modal.prototype.hide = function () {
    debug.log('proto hide() from line 124');
    var self = this,
        deferStop = self.settings.overrides && self.settings.overrides.deferStop;

    self.$container.modal('hide');

    self.$container.off('click', '[data-dismiss="modal"]');
    $('body').off('keyup.modaldismiss');

    application.broadcast('modal.hidden', {
      modal: self
    });

    if (!deferStop) {
      // The modal creator has requested that modules be stopped after modal is hidden
      application.stopAll(self.$container);
    }

    debug.log(this.settings.modalId + ' modal hidden');
  };

  Modal.prototype.toggle = function () {
    var self = this;

    self.$container.modal('toggle');
    application.broadcast('modal.toggled', {
      modal: self
    });

    debug.log(this.settings.modalId + ' modal toggled');
  };

  /**
  *
  * @param {object} modalOptions - DOM share element the user clicked on
  */
  Modal.prototype.loadContent = function (modalContent) {
    var self = this,
        $closeTarget;

    if (!modalContent) {
      return;
    }

    if (typeof modalContent === 'string') {
      modalContent = {
        override: modalContent
      };
    }

    if (modalContent.override) {
      self.$container.html(modalContent.override);
      if (this.settings.closeButtonParent) {
        $closeTarget = self.$container.find(this.settings.closeButtonParent);
      } else {
        $closeTarget = self.$container;
      }
      $closeTarget.prepend(template.modalClose());
      debug.log(this.settings.modalId + ' modal content loaded: ', modalContent.override);
    } else {
      var modalTemplate = template.modal({
        id: modalContent.modalId,
        heading: modalContent.header.title,
        subHeading: modalContent.header.subtitle,
        body: modalContent.body.html,
        actionText: typeof modalContent.footer !== 'undefined' && typeof modalContent.footer.actionText !== 'undefined' ? modalContent.footer.actionText : '',
        cancelText: typeof modalContent.footer !== 'undefined' && typeof modalContent.footer.cancelText !== 'undefined' ? modalContent.footer.cancelText : ''
      });

      self.$container.html(modalTemplate);

      debug.log(this.settings.modalId + ' modal content loaded: ', modalTemplate);
    }
  };

  /**
   * Utility function to add a modal container to the dom
   * @private
   *
   * @param {string} modalId  ID of the modal container, e.g. '#myModal'
   */
  function _addModalContainer(modalId) {
    if (!$('#' + modalId).length) {
      $('body').append(template.modalWrap(modalId));
    }
  }

  /**
   * Modal plugin definition. Pulled directly from Bootstrap source with a few notable changes:
   * 1) We've removed the .bs.modal events in favor of using application.broadcast
   * 2) The data- API options have been removed; we're handling those via our module and getSettings utilities,
   * 3) The jQuery plugin registration is performed through the module-utilities
   *
   * @author Bootstrap
   */
  function _registerPlugin() {
    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


    var Modal = function Modal(element, options) {
      this.overrides = overrides;
      this.options = options;
      this.$body = $(document.body);
      this.$element = $(element);
      this.$backdrop = this.isShown = null;
      this.scrollbarWidth = 0;
    };

    Modal.DEFAULTS = {
      backdrop: true,
      keyboard: true,
      show: true
    };

    Modal.prototype.toggle = function (_relatedTarget) {
      return this.isShown ? this.hide() : this.show(_relatedTarget);
    };

    Modal.prototype.show = function (_relatedTarget) {
      var that = this;
      var e = $.Event('modal.show', { relatedTarget: _relatedTarget });

      if (this.isShown || e.isDefaultPrevented()) return;

      this.isShown = true;

      this.checkScrollbar();

      if (overrides.noScroll) {
        overrides.currPosition = $(document).scrollTop();
        this.$body.addClass(openClassForce);
        if (overrides.currPosition) {
          this.$body.css('top', '-' + overrides.currPosition + 'px');
        }
      } else {
        this.$body.addClass(openClass);
      }

      this.setScrollbar();

      this.backdrop(function () {
        var hasTransition = that.$element.hasClass('fade') || that.$element.hasClass('has-Transition');
        var transition = $.support.transition && emulationPlugin && hasTransition;

        if (!that.$element.parent().length) {
          that.$element.appendTo(that.$body); /** don't move modals dom position  */
        }

        that.$element.fadeIn(250, function () {
          // fadeIn is normally fine, but video overlays shouldn't display:none
          //  and need visibility:visible as well as the fadeIn
          if (that.options.isVideoOverlay) {
            that.$element.css('visibility', 'visible');
          }
        });

        if (!that.options.preventScrollHijack) {
          window.scrollTo(0, 0);
        } else {
          that.$element.css('margin-top', $(document).scrollTop());
        }

        if (transition) {
          that.$element[0].offsetWidth; /** force reflow  */
        }

        that.$element.addClass('in').attr('aria-hidden', false);

        that.enforceFocus();

        transition ? that.$element.find('[data-modal-dialog]') /** wait for modal to slide in  */
        .one($.support.transition.end, function () {
          that.$element.trigger('focus');
        }).emulateTransitionEnd(300) : that.$element.trigger('focus');
      });
    };

    Modal.prototype.hide = function (e) {
      debug.log('proto hide() handle transition end');
      var hasTransition = this.$element.hasClass('fade') || this.$element.hasClass('has-Transition');
      if (e) e.preventDefault();

      e = $.Event('modal.hide');

      if (!this.isShown || e.isDefaultPrevented()) return;

      this.isShown = false;

      if (overrides.noScroll) {
        this.$body.removeClass(openClassForce);
        if (overrides.currPosition) {
          $(document).scrollTop(overrides.currPosition);
          this.$body.css('top', 'inherit');
        }
      } else {
        this.$body.removeClass(openClass);
      }

      this.resetScrollbar();

      $(document).off('focusin.bs.modal');

      this.$element.removeClass('in').attr('aria-hidden', true).off('click.dismiss.bs.modal');

      if ($.support.transition && emulationPlugin && hasTransition) {
        this.$element.one($.support.transition.end, $.proxy(this.hideModal, this)).emulateTransitionEnd(300);
      } else {
        this.hideModal();
      }
    };

    Modal.prototype.enforceFocus = function () {
      $(document).off('focusin.bs.modal') /** guard against infinite focus loop  */
      .on('focusin.bs.modal', $.proxy(function (e) {

        //the logic below causes an issue with gigya email share modal in overlays, so let's not use it there. it doesn't serve a purpose in that context anyhow.
        if ($('body').hasClass('full-overlay-modal-open')) {
          return true;
        }

        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus');
        }
      }, this));
    };

    Modal.prototype.hideModal = function () {
      debug.log('hideModal()');
      var that = this;

      // 1.4 Universal Player updates:
      // video player shouldn't be display: none'd
      // please read https://sni-digital.atlassian.net/wiki/display/VPC/Working+with+the+player+in+a+Modal
      if (this.options.isVideoOverlay) {
        this.$element.css('visibility', 'hidden');
      } else {
        this.$element.hide();
      }

      this.backdrop(function () {
        that.removeBackdrop();
      });

      if (this.overrides && this.overrides.deferStop) {
        debug.log('Deferred cleanup!');
        application.stopAll(this.$element);
      }

      if (this.overrides && this.overrides.clearContents) {
        this.$element.get(0).innerHTML = '';
      }
    };

    Modal.prototype.removeBackdrop = function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    };

    Modal.prototype.backdrop = function (callback) {
      var animate = this.$element.hasClass('fade') ? 'fade' : '';

      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && emulationPlugin && animate;

        debug.log('this.overrides : ', this.overrides);
        this.$backdrop = this.overrides.backdropAlternate ? $(template.modalBackdrop(animate, this.overrides.backdropAlternate)).appendTo(this.$body) : $(template.modalBackdrop(animate)).appendTo(this.$body);

        this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return;
          this.options.backdrop === 'static' ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this);
        }, this));

        if (doAnimate) this.$backdrop[0].offsetWidth; /** force reflow  */

        this.$backdrop.addClass('in');

        if (!callback) return;

        doAnimate ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');

        $.support.transition && emulationPlugin && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback();
      } else if (callback) {
        callback();
      }
    };

    Modal.prototype.checkScrollbar = function () {
      if (document.body.clientWidth >= window.innerWidth) return;
      this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar();
    };

    Modal.prototype.setScrollbar = function () {
      var bodyPad = parseInt(this.$body.css('padding-right') || 0);
      if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
    };

    Modal.prototype.resetScrollbar = function () {
      this.$body.css('padding-right', '');
    };

    Modal.prototype.measureScrollbar = function () {
      /** thx walsh */
      var scrollDiv = document.createElement('div');
      scrollDiv.className = 'modal-scrollbar-measure';
      this.$body.append(scrollDiv);
      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      this.$body[0].removeChild(scrollDiv);
      return scrollbarWidth;
    };

    modUtil.registerjQueryPlugin('modal', Modal);
  }

  /** Return the class and the 'open()' convenience wrapper */
  return {
    create: function create(options) {
      return new Modal(options);
    },
    open: function open(modalId, content, isVideo, pluginOverride) {
      var resetScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      debug.log('open()');
      debug.table([{ modalId: modalId, content: content, isVideo: isVideo }]);
      var modal = new Modal({
        modalId: modalId,
        content: content,
        // needed for video player overlay
        plugin: typeof pluginOverride !== 'undefined' ? pluginOverride : { isVideoOverlay: typeof isVideo !== 'undefined' ? isVideo : false, preventScrollHijack: resetScroll }
      });

      modal.show();

      return modal;
    },
    close: function close(modalId) {
      debug.log('close: modalId: ', modalId);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = modals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var modal = _step.value;

          debug.log('modalId: ', modal.settings.modalId, modalId);
          if (modal.settings.modalId === modalId) {
            debug.log('close: modal.hide');
            modal.hide();
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
});

/***/ }),
/* 440 */
/***/ (function(module, exports) {

SNI.Application.addService('model', function (application) {

  return {
    createModel: function createModel(modelConfig) {
      var data = Object.assign({}, modelConfig.data);
      var model = Object.assign({}, modelConfig.methods);

      Object.keys(data).forEach(function (key) {
        return Object.defineProperty(model, key, {
          get: function get() {
            return data[key];
          },
          set: function set(val) {
            data[key] = val;
            if (modelConfig.watch && modelConfig.watch[key]) {
              modelConfig.watch[key](val);
            }
            if (modelConfig.watchAll) {
              modelConfig.watchAll(key, val);
            }
          },

          enumberable: true,
          configurable: true
        });
      });
      return model;
    }
  };
});

/***/ }),
/* 441 */
/***/ (function(module, exports) {

SNI.Application.addService('module-loader', function (application) {

  var debug = application.getService('logger').create('service.module-loader');

  return {
    loadRemote: function loadRemote(url, el) {
      var $el = $(el);

      debug.log('loading ' + url);

      return new Promise(function (resolve, reject) {
        $.get(url, function (data) {
          $el.append($(data));
          application.startAll($el);
          resolve();
        });
      });
    },
    loadString: function loadString(html) {
      var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $('body');

      var $el = $(el);

      $el.append(html);
      application.startAll($el);
    }
  };
});

/***/ }),
/* 442 */
/***/ (function(module, exports) {

/**
 * Newsletter/Reminder Service
 * API for subscribing to newsletters/reminders or getting a list of available newsletters.
 * Author: pfitzgerald
 * Modified: agoodman
 */

SNI.Application.addService('newsletter-subscribe', function (application) {

  var check = application.getService('check');

  var serviceDomain = check.isProd() ? 'https://ds-prodapipreferencecenter.dataservices.snidigital.com' : 'http://ds-stagepreference_center.dataservices.snidigital.com',
      debug = application.getService('debug'),


  // Service call timeout (ms) before giving up
  timeout = 10000,
      getSubscribeUrl = function getSubscribeUrl(type) {
    return serviceDomain + (type === 'newsletter' ? '/webservice_json.php' : '/services/reminders_home_json.php');
  };

  var subscribeType = 'reminder';

  return {
    /**
     * Subscribe an email to one or more newsletter.
     *
     * @params Object settings A set of key/value pairs to configure the request.
     *
     * @params String settings.email The users email address.
     *
     * @params String|Array settings.nl The newsletter id to subscribe.
     * This can be a single newsletter string such as "hgtv_gardens", or an array of newsletter strings
     * such as ['hgtv_gardens', 'hgtv_inspiration']
     *
     * @params String [settings.source] An identifier that describes where this newsletter subscription
     * came from. For example: "2014_HGTV_Dynamic_Rail_Module"
     *
     * @params String [settings.timeout] Timeout in ms for the service call.
     * If not provided will use module.timeout.
     *
     * @returns Promise
     *
     * @example
     * // Subscribe to a single newsletter
     * service.subscribe({
     *   email:'test@mailinator.com',
     *   source: '2014_HGTV_Dynamic_Rail_Module',
     *   nl: 'hgtv_gardens'
     * }).done(() => {
     *   alert('You are subscribed!');
     * }).fail(() => {
     *   alert('There was a problem subscribing, try again later.');
     * });
     *
     * @example
     * // Subscribe to multiple newsletters
     * service.subscribe({
     *   email:'test@mailinator.com',
     *   source: '2014_HGTV_Dynamic_Rail_Module',
     *   nl: ['hgtv_gardens', 'hgtv_inspiration']
     * }).done(() => {
     *   alert('You are subscribed!');
     * }).fail(() => {
     *   alert('There was a problem subscribing, try again later.');
     * });
     */
    subscribe: function subscribe() {
      var _arguments = arguments;
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var deferred = void 0,
          nlData = void 0;

      subscribeType = settings.subscribeType || subscribeType;

      // Construct the data for the ajax call
      nlData = {
        emailaddress: settings.email,
        source: settings.source || '',
        nlbrand: settings.nlbrand,
        list: settings.listId
      };

      // the nl can be an array or a string
      // if it's not an array, make it one
      if (!Array.isArray(settings.nl)) {
        settings.nl = [settings.nl];
      }

      // add all of the setting in the nl array to
      // the ajax data
      for (var i = 0; i < settings.nl.length; i++) {
        nlData[settings.nl[i]] = 'Y';
      }

      // Create a deferred object that we will return
      deferred = $.Deferred();

      // Don't call the service if we're missing required parameters
      if (subscribeType === 'newsletter') {
        if (!(settings.email && settings.nl)) {
          deferred.reject(undefined, 'malformed', 'Missing required parameters');
          return deferred.promise();
        }
      } else {
        if (!(settings.email && settings.listId)) {
          deferred.reject(undefined, 'malformed', 'Missing required parameters');
          return deferred.promise();
        }
      }

      // Call the service
      $.ajax({
        url: getSubscribeUrl(subscribeType),
        timeout: settings.timeout || timeout,
        data: nlData,

        // Since this is jsonp, jquery will automatically add ?callback=? to the end of the url
        dataType: 'jsonp',

        // Change the name of the callback parameter
        // Normally uses ?callback=? but we need ?jsonpCallback=?
        jsonp: 'jsonpCallback'
      }).done(function (data, textStatus, jqXHR) {
        // The service responded to us; however, this does not mean the user
        // was successfully subscribed. We must check the response.
        if (data.success === 'true') {
          deferred.resolve(data, textStatus, jqXHR);
        } else {
          deferred.reject(jqXHR, 'error', '');
        }
      }).fail(function (jqXHR, textStatus, errorThrown) {
        debug.error(_arguments);

        // textStatus = "timeout", "error", "abort", "parsererror
        // Although since this is JSONP if there is a parseerror it will probably just fail silently
        deferred.reject(jqXHR, textStatus, errorThrown);
      });

      // Return a promise based on our deferred object
      return deferred.promise();
    }
  };
});

/***/ }),
/* 443 */
/***/ (function(module, exports) {

SNI.Application.addService('product-hotspots', function (context) {
  'use strict';

  var x = void 0,
      y = void 0,
      ads = void 0,
      config = void 0,
      mdManager = void 0,
      isFullScreen = false,
      debug = context.getService('logger').create('service.product-hotspots'),
      check = context.getService('check').new(debug),
      deviceType = context.getService('device-type'),
      analytics = context.getService('analytics'),
      template = context.getService('template');

  var showOverlay = function showOverlay(hotspotId) {
    var settings = checkConfig(config);
    if (!settings) {
      return;
    }

    var tourProducts = settings.tourProducts,
        tpName = settings.tpName.replace(/[^a-z0-9\s]/gi, ''),
        sName = settings.sName.replace(/[^a-z0-9\s]/gi, '');

    hideTooltip();
    var previous = hotspotId - 1;
    var next = hotspotId;
    next++;

    //if at end of list, loop back to first for next
    if (next > tourProducts.length - 1) {
      next = 0;
    }

    //if at beginning of list, loop back to last for previous
    if (previous < 0) {
      previous = tourProducts.length - 1;
    }

    var overlay = document.getElementById('product-overlay');

    if (overlay === null) {
      // create overlay and append to page
      overlay = document.createElement('div');
      overlay.setAttribute('id', 'product-overlay');
      overlay.setAttribute('class', 'product-overlay');
    }

    //IE11 cannot layer the modal on top of the fullscreen WebGL component, so exit fullscreen
    if (!!document.msExitFullscreen && document.msFullscreenElement !== null) {
      document.msExitFullscreen();
    }

    if (isFullScreen) {
      var windowWidth = $(window).width();

      setTimeout(function () {
        $('#product-overlay').css('cssText', 'z-index: 2000000000000 !important').css('width', windowWidth);
      }, 1);
    }

    overlay.innerHTML = template.productHotSpot({
      product: tourProducts[hotspotId],
      currentProduct: parseInt(hotspotId) + 1,
      totalProducts: tourProducts.length,
      componentUrl: settings.componentUrl,
      previous: previous,
      next: next
    });

    document.body.appendChild(overlay);

    //Wiring for hotspot click pageviews
    var levelSixNode, currentSide;
    if (mdManager) {
      var compName = tourProducts[hotspotId].company_name;
      var titleName = tourProducts[hotspotId].title;
      compName = compName.replace(/[^a-z0-9\s]/gi, '');
      titleName = titleName.replace(/[^a-z0-9\s]/gi, '');
      analytics.setValue('events', 'event1,event47');
      analytics.setEvar(46, tpName);
      analytics.setEvar(47, tpName + ':' + sName + ':' + titleName);
      analytics.setEvar(48, tpName + ':' + 'tour' + ':' + sName + ':' + compName + ':' + titleName);
      levelSixNode = mdManager.getParameterString('TourPosition');
      currentSide = mdManager.getParameterString('TourPosition');
      levelSixNode += '|' + titleName + '|' + compName;
      mdManager.setParameter('TourPosition', levelSixNode);
      levelSixNode = levelSixNode.trim();
      currentSide = currentSide.trim();
      analytics.setProp(68, levelSixNode);
      analytics.legacyPV();
      mdManager.setParameter('TourPosition', currentSide);
      analytics.setProp(68, currentSide);
    }

    //Wiring for more info clicks
    //Double check that this doesn't interfere with link opening in new tab
    $('.more-info, .product-left img, .product-right img').off('click').on('click', function () {
      if (mdManager) {
        var comp = tourProducts[hotspotId].company_name;
        var titleName2 = tourProducts[hotspotId].title;
        comp = comp.replace(/[^a-z0-9\s]/gi, '');
        titleName2 = titleName2.replace(/[^a-z0-9\s]/gi, '');
        analytics.setValue('linkTrackVars', 'prop1,prop2,eVar46,eVar47,eVar48,events');
        analytics.setValue('linkTrackEvents', 'event48');
        analytics.setValue('events', 'event48');
        analytics.setProp(2, tpName + ':Sponsor Site Click');
        analytics.setEvar(46, tpName);
        analytics.setEvar(47, tpName + ':' + sName + ':' + titleName2);
        analytics.setEvar(48, tpName + ':' + 'tour' + ':' + sName + ':' + comp + ':' + titleName2);
      }
    });

    if (deviceType.isMobile && ads) {
      ads.refreshSlot($('#dfp_overlay_bigbox :first-child').attr('id'));
    }
  };

  var overlayRestore = function overlayRestore() {
    document.body.removeChild(document.getElementById('product-overlay'));
  };

  var showTooltip = function showTooltip(hotspotId) {
    var settings = checkConfig(config);
    if (!settings) {
      return;
    }

    var krpano = document.getElementById('krpanoSWFObject'),
        xCoord,
        yCoord,
        athCo,
        atvCo;

    if (krpano && krpano.get) {
      krpano.call('spheretoscreen(hotspot[' + hotspotId + '].ath, hotspot[' + hotspotId + '].atv, screenH, screenV)');
      window.setTimeout(function () {
        athCo = krpano.get('hotspot[' + hotspotId + '].ath');
        atvCo = krpano.get('hotspot[' + hotspotId + '].atv');
        xCoord = krpano.get('screenH');
        yCoord = krpano.get('screenV');
        debug.log('showTooltip', hotspotId, athCo, atvCo, xCoord, yCoord);

        var tooltip = document.getElementById('tooltip');

        if (tooltip === null) {
          // create tooltip and append to page
          tooltip = document.createElement('div');
          tooltip.setAttribute('id', 'tooltip');
          tooltip.setAttribute('class', 'tooltip top in');
        }

        tooltip.innerHTML = '<div class="tooltip-inner">' + settings.tourProducts[hotspotId].title.replace(/&amp;quot;/ig, '\"') + '</div>';

        var $cont = $('#virtual-tour-embed-container'),
            positronix = $cont.position(),
            marLeft = $cont.css('margin-left'),
            marTop = $cont.css('margin-top');

        marLeft = marLeft.replace(/px/ig, '');
        marTop = marTop.replace(/px/ig, '');

        tooltip.style.position = 'absolute';
        tooltip.style.left = xCoord + positronix.left + Math.round(marLeft) + 20 + 'px';
        tooltip.style.top = yCoord + positronix.top + Math.round(marTop) + 'px';
        document.body.appendChild(tooltip);

        if (isFullScreen) {
          $('#tooltip').css('cssText', 'z-index: 2000000000000 !important').css('left', xCoord + 20 + 'px').css('top', yCoord + 'px');
        }
      }, 20);
    }
  };

  var hideTooltip = function hideTooltip() {
    if ($('#tooltip').length) {
      document.body.removeChild(document.getElementById('tooltip'));
    }
  };

  var placeHotspot = function placeHotspot(hspotName, atHorizontal, atVertical) {
    var updateCoordinate = function updateCoordinate(inputClass, newVal) {
      var coordinateElement = '';

      function findCoordinateElement(els) {
        var el = '';
        if (els.length > 0) {
          el = els.pop();
          if (hspotName === $(el).val()) {
            return el;
          } else {
            return findCoordinateElement(els);
          }
        } else {
          debug.error('placeHotspot: updateCoordinate: findCoordinateElement: Hotspot ' + hspotName + ' not found.');
          return false;
        }
      }

      coordinateElement = findCoordinateElement([].slice.call(document.getElementsByClassName('dialog-hotspot-name')));

      if (coordinateElement) {
        return $(coordinateElement).closest('.dialog-products-fieldset').find('input.' + inputClass).val(newVal).val();
      } else {
        return false;
      }
    },
        newX = updateCoordinate('dialog-hotspot-x-coordinate', Math.round(atHorizontal)),
        newY = updateCoordinate('dialog-hotspot-y-coordinate', Math.round(atVertical));

    // log and update the coordinates
    debug.log('Hotspot ' + hspotName + ' Coordinates are now (X: ' + newX + ', Y: ' + newY + ')');
  };

  function checkConfig(config) {
    if (!config || !config.tourProducts || !config.tpName || !config.sName) {
      debug.error('a proper config was not found. config passed was:', config);
      return false;
    } else {
      return config;
    }
  }

  return {

    init: function init(passedSettings) {
      config = checkConfig(passedSettings);
      ads = check.exists('SniAds') ? context.getGlobal('SniAds') : false;
      mdManager = check.exists('mdManager') ? context.getGlobal('mdManager') : false;

      x;y; //weird thing to make linter pass...

      document.addEventListener('mousemove', function (e) {
        x = e.clientX;
        y = e.clientY;
      }, false);

      $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function (e) {
        isFullScreen = !isFullScreen;
      });

      //export needed methods to the global scope
      SNI.ProductOverlay = {
        showOverlay: showOverlay,
        showTooltip: showTooltip,
        hideTooltip: hideTooltip,
        placeHotspot: placeHotspot,
        overlayRestore: overlayRestore
      };
    }

  };
});

/***/ }),
/* 444 */
/***/ (function(module, exports) {

SNI.Application.addService('product-manager', function (application) {

  var debug = application.getService('logger').create('service.product-manager');
  var products = {
    // '000-000-000000-0000': {
    //   received: true,
    //   data: {products:[0]},
    // }
  };
  var productShown = {
    //  '000-000-000000-0000' : true
  };
  //  Find a known vendor sizing string
  var vendorImgSizing = {
    'vendor1': {
      src: '/compr-r85/',
      target: '/resize-h150-p1-w150%5Ecompr-r85/'
    }
  };

  var managerConfig = {
    endpoint: '', // Should point to the vendor API
    vendor: '', // Vendor configuration.  Will likely be Dynamically set in the future
    productsInSet: 6
  };

  function addProduct(id, $deferred) {
    if (products[id]) {
      return products[id]; // do not add if it is already in the data
    }
    products[id] = {
      received: false,
      singleItem: true,
      data: null,
      $deferred: $deferred
    };
  }

  function addProductShown(id) {
    productShown[id] = true;
  }

  /* On mobile we want to avoid showing the products again for the same ID */
  function isProductShown(id) {
    return productShown[id];
  }

  /**
   * Pass in a products array and remove items without stock
   * @param {array} data 
   */
  function cleanUpData(data) {
    if (data.length && data.length > 0) {
      return data.filter(function (product) {
        return product['has_stock'];
      });
    }
    return data; // return if empty
  }

  function imgURLSizing(url) {
    var options = vendorImgSizing[managerConfig.vendor]; // Look up replacement strings
    var src = options.src,
        target = options.target;

    if (options && options.src && options.target) {
      return url.replace(src, target);
    } else {
      return url;
    }
  }

  function updateImageSizes(item) {
    var url = item.image_url;
    var updated_url = void 0;
    if (url) {
      updated_url = imgURLSizing(url);
      item['image_url'] = updated_url;
    }
    return item;
  }

  function updateProduct(options) {
    var id = options.id,
        data = options.data;

    var cleanData = cleanUpData(data).map(updateImageSizes);
    if (cleanData.length === 0) {
      debug.log('Cleared out products!', id); /// REMOVE
    }
    var update = { data: cleanData, received: true };
    return $.extend(products[id], update);
  }

  /**
   * Handle the AJAX responses and update the product data with the results
   * @param {object} data 
   */
  function responseHandler(data) {
    var result = void 0,
        output = data['vendor-output-from-request'],
        err = data['error'];
    if (err) {
      debug.log('Product API Error:', err);
    }
    if (data && output) {
      result = output.result;
      if (result && result.length) {
        debug.log('Got product results!');
        result.forEach(function (item) {
          updateProduct({
            id: item.id,
            data: item.products
          });
        });
      } else {
        debug.log('No product results.');
      }
    }
    return products; // return a reference to products
  }

  function requestProducts(prodids) {
    var prods = prodids.join(',');
    return $.get('' + managerConfig.endpoint + managerConfig.vendor + '/' + prods + '.html.json'); // REX-445 API URL Sample: .../vendor-api.json/wayfair/prod-id-1,prod-id-2.html.json (uses .html.json selector for AEM dispatcher)
  }

  /**
   * Accepts an array that will be used to create an AJAX call.  Then the product record will be updated with a reference so the response can be hanlded later
   * @param {array} prods 
   */
  function createDeferreds(prods) {
    var $setDeferred = requestProducts(prods),
        $deferred = void 0;
    prods.forEach(function (item) {
      addProduct(item, $setDeferred);
    });
    $deferred = $setDeferred.then(responseHandler).fail(function (result) {
      debug.log('Unable to retrieve products from Vendor API');
    });
    return { $deferred: $deferred };
  }
  /**
   * Break up an array into multiple arrays with 6 items or less then return an array of arrays with the smaller sets
   * @param {array} sets 
   */
  function breakUpSet(sets) {
    var splitArray = [],
        setMax = managerConfig.productsInSet > 0 ? managerConfig.productsInSet : 1;
    while (sets.length > setMax) {
      splitArray.push(sets.splice(0, setMax)); //  remove the first ten
    }
    if (sets.length > 0) {
      splitArray.push(sets); // Append the rest
    }
    return splitArray.slice(); // return new array
  }

  /**
   * Accepts a photo ID or photo IDs and calls the API for each
   * @param {string|array} productSet 
   */
  function addSet(productSet) {
    var prods = Array.isArray(productSet) ? productSet : [productSet],
        prodSets = breakUpSet(prods),
        $deferredArray = void 0; // Create an array of arrays so that we can make a call for each set
    $deferredArray = prodSets.map(createDeferreds);
    return $deferredArray[0]; // return the first set
  }

  function getAsyncProduct(id) {
    if (products[id]) {
      return products[id];
    } else {
      return addSet(id);
    }
  }
  function getProduct(id) {
    return products[id];
  }
  function updateConfig(config) {
    $.extend(managerConfig, config);
  }

  return {
    addProduct: addProduct,
    addProductShown: addProductShown,
    isProductShown: isProductShown,
    addSet: addSet,
    getAsyncProduct: getAsyncProduct,
    activeProduct: '',
    getProduct: getProduct,
    updateConfig: updateConfig,
    responseHandler: responseHandler
  };
});

/***/ }),
/* 445 */
/***/ (function(module, exports) {

var _this = this;

/**
 * A service designed to remove inline style blocks that conflict with theming.
 * This was designed specifically to work around styles injected by gigya for ratings and reviews
 **/
SNI.Application.addService('remove-inline-styles', function (application) {
  var _application$getServi = application.getService('utility'),
      memoize = _application$getServi.memoize;

  var debug = application.getService('logger').create('service.remove-inline-styles');

  /**
   * Removes an element that matches any given filter
   * @param {array} filters - A list of filters to match against
   * @param {string} selector - A css selector of the element to match against (defaults to 'style')
   **/
  var removeInlineStyles = function removeInlineStyles(filters) {
    var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'style';

    filters.map(function (filter) {
      var thisSelector = selector + ':contains(' + filter + ')';
      var $el = $(thisSelector);
      if ($el.length > 0) {
        debug.log('removeInlineStyles: removing ' + thisSelector);
        $el.remove();
      }
    });
  };

  // Uses memoize to only call once for a given set of arguments
  var removeDynamicInlineStyles = memoize(function (filters, _ref) {
    var _ref$selector = _ref.selector,
        selector = _ref$selector === undefined ? 'style' : _ref$selector,
        _ref$pollRate = _ref.pollRate,
        pollRate = _ref$pollRate === undefined ? 1000 : _ref$pollRate,
        _ref$numPolls = _ref.numPolls,
        numPolls = _ref$numPolls === undefined ? 15 : _ref$numPolls;


    var currentTime = 0;
    var totalTime = pollRate * numPolls;

    var pollInterval = setInterval(function () {
      if (currentTime <= totalTime) {
        removeInlineStyles.call(_this, filters, selector);
        currentTime += pollRate;
      } else {
        clearInterval(pollInterval);
      }
    }, pollRate);
  });

  return {
    removeInlineStyles: removeInlineStyles,
    removeDynamicInlineStyles: removeDynamicInlineStyles
  };
});

/***/ }),
/* 446 */
/***/ (function(module, exports) {

SNI.Application.addService('router', function (application) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var previousURL = void 0,
      service = void 0;

  var ajax = application.getService('ajax');

  function setPreviousUrl(url) {
    var cleanedUrl = cleanURL(url);
    if (cleanedUrl) {
      previousURL = cleanedUrl;
    }
  }

  function retrievePreviousUrl() {
    if (typeof previousURL !== 'undefined') {
      return previousURL;
    } else {
      var defaultURL = cleanURL(window.location.href);
      previousURL = defaultURL;
      return defaultURL;
    }
  }

  function isWCMDisabled() {
    if (typeof application.getGlobal('cqWCMDisabled') !== 'undefined') {
      return true;
    } else {
      return false;
    }
  }

  function isTargetValid(target) {
    return target !== '' && typeof application.getGlobal('cqBasePage') !== 'undefined';
  }

  function isLinkValid(target) {
    var wcmDisabled = isWCMDisabled(),
        targetValid = isTargetValid(target);

    return wcmDisabled && targetValid;
  }

  function isURLDifferent(url) {
    return window.location.href.indexOf(url) === -1;
  }

  function routeGallery(launcher) {
    if (launcher && isURLDifferent(previousURL)) {
      application.broadcast('stateChanged', {
        href: window.location.href
      });
    }
  }

  function isString(val) {
    if (typeof val === 'string') {
      return true;
    } else {
      return false;
    }
  }

  function cleanURL(url) {
    if (typeof url !== 'undefined' && isString(url)) {
      return url.replace(/\??\&_suid.*/, '');
    } else {
      return false;
    }
  }

  function routeTarget(target, url) {
    // application.broadcast('ajax.areacontentreadytoload', {
    //   target: target,
    //   href: url
    // });
    ajax.loadAreaContent({
      target: target,
      href: url
    });
  }

  function determineRoute(data) {
    var target = data.target,
        gallery = data.gallery,
        launcher = data.launcher,
        cleanUrl = cleanURL(data.href);

    if (gallery) {
      routeGallery(launcher);
    }

    if (target && cleanUrl) {
      if (typeof window.history !== 'undefined') {
        window.history.pushState({}, '', cleanUrl);
      }
      routeTarget(target, cleanUrl);
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  service = {

    setPreviousUrl: setPreviousUrl,

    getPreviousURL: function getPreviousURL() {
      return retrievePreviousUrl();
    },


    routeClickHandling: function routeClickHandling(event) {
      var target = $(event.target).data('target') || '',
          href = $(event.target).attr('href') || '',
          isRouteableLink = isLinkValid(target);

      if (isRouteableLink && href) {
        event.preventDefault();
        event.stopPropagation();
        routeTarget(target, href);
      }
    },

    handleStateChange: function handleStateChange(data) {

      determineRoute(data);
    }

  };

  return service;
});

/***/ }),
/* 447 */
/***/ (function(module, exports) {

SNI.Application.addService('schedule', function (application) {

  function compareDateTimeNowAndAirtime(dateTime, airTime, zone) {

    var offset = 0;
    // The schedule is in eastern time zone, so we need to apply an offset.
    switch (zone) {
      default:
      // Fall through to eastern;
      case 'eastern':
        offset = 0; // East coast schedule.
        break;
      case 'central':
        offset = 0; // East coast schedule. Ultimately 1 our behind of the EST offset to GMT.
        break;
      case 'mountain':
        offset = 3; // West coast schedule. Ultimately 1 our ahead of the EST offset GMT.
        break;
      case 'pacific':
        offset = 3; // West coast schedule. Ultimately the same as EST offset GMT.
        break;
    }

    // Manipulated this to follow biz rules.
    var compareTime = new Date(dateTime.getTime());

    // zero out the minutes and seconds for comparison purposes.
    compareTime.setSeconds(0);
    compareTime.setMilliseconds(0);

    if (offset !== 0) {
      // this seems to roll back the date too, if we pass a negative number, which is exactly what we want.
      compareTime.setHours(dateTime.getHours() - offset);
    }

    var diff = compareTime.getTime() - airTime.getTime(),
        millisPerMinute = 1000 * 60,
        tenMinutesBeforeInMillis = -10 * millisPerMinute,
        twentyMinutesAfterInMillis = 20 * millisPerMinute;

    var match = tenMinutesBeforeInMillis <= diff && diff < twentyMinutesAfterInMillis;
    return match ? 0 : diff;
  }

  return {
    compareDateTimeNowAndAirtime: compareDateTimeNowAndAirtime
  };
});

/***/ }),
/* 448 */
/***/ (function(module, exports) {

SNI.Application.addService('scroll-tracker', function (application) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var history = application.getGlobal('history'),
      debug = application.getService('logger').create('service.scroll-tracker'),
      manager = application.getService('stream-manager'),
      modUtil = application.getService('utility'),
      device = application.getService('device-type'),
      debugMode = modUtil.isDebug();

  var namespace = void 0,
      interval = void 0,
      threshold = void 0,
      container = void 0,
      processing = void 0,
      lastSelector = '',
      viewport = false,
      iteration = 1,
      totalIteration = 1,
      currentInterval = 0,
      currentDistance = void 0,
      totalDistance = 0;

  function setNamespace(val) {
    namespace = val;
  }

  function getNamespace() {
    if (typeof namespace !== 'undefined') {
      return namespace;
    } else {
      return false;
    }
  }

  function setTotalIteration(val) {
    if (typeof val !== 'undefined') {
      totalIteration = val;
    }
  }

  function getTotalIteration() {
    if (typeof totalIteration !== 'undefined') {
      return totalIteration;
    } else {
      return false;
    }
  }

  function setInterval(val) {
    interval = val;
  }

  function setProcessing(val) {
    processing = val;
  }

  function getProcessing() {
    if (typeof processing !== 'undefined') {
      return processing;
    } else {
      return false;
    }
  }

  function setThreshold(val) {
    threshold = val;
  }

  function getThreshold() {
    if (typeof threshold !== 'undefined') {
      return threshold;
    } else {
      return false;
    }
  }

  function setContainer(val) {
    container = val;
  }

  function getContainer() {
    if (typeof container !== 'undefined') {
      return container;
    } else {
      return false;
    }
  }

  function setIteration() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iteration;

    iteration = val;
  }

  function getIteration() {
    if (typeof iteration !== 'undefined') {
      return iteration;
    } else {
      return false;
    }
  }

  function setScrollHandler() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : trackScrollDistance;

    var name = getNamespace() ? getNamespace() : 'scroll';
    var handler = modUtil.throttle(val, 100);
    if (typeof val !== 'undefined') {
      $(window).on(name, handler);
    }
  }

  function trackScrollDistance() {
    currentDistance = $(document).scrollTop();
    trackViewport();
    if (currentDistance > totalDistance) {
      totalDistance = currentDistance;
      if (device.isMobile) {
        trackScrollInterval();
      }
    }
  }

  /*  
    CFF-262: Interval tracking is no longer in use for desktop.  Desktop now relies on ad events to trigger page views
    Mobile tracking still uses intervals
  */
  function trackScrollInterval() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : interval;

    var intervalObject = {};
    currentInterval = $(document).scrollTop() - val * (totalIteration - 1);
    if (typeof val !== 'undefined') {
      if (currentInterval >= val) {
        updateIteration();
        intervalObject = { currentInterval: currentInterval };
        application.broadcast('scroll-tracker.interval', intervalObject);
      }
    }
  }

  /*
    CFF-262:  this is no longer called by the scroll event handler.  It is called by trackViewport when needed
  */
  function trackScrollThreshold(index) {
    var contract = void 0;
    if (!getProcessing()) {
      setProcessing(true);
      contract = $.Deferred();
      contract.done(function () {
        setProcessing(false);
      }).fail(function () {
        debug.error('trackScrollThreshold: contract not resolved, unable to process new entry.');
        application.broadcast('article-stream.end');
      });
      application.broadcast('scroll-tracker.threshold', {
        contract: contract,
        index: index
      });
    }
  }

  function pushState(url) {
    if (!debugMode) {
      history.pushState({}, '', url);
    } else {
      debug.warn('skipping history.pushState as debug mode is active. url passed:', url);
    }
  }

  function trackViewport() {

    if (getViewport()) {
      var allElements = manager.getEntryElements();
      if (allElements) {
        //  Get the most visible item
        var currentItem = getItemsInVP(allElements),
            currentSelector = currentItem['el'] && currentItem['el'].selector.substring(1),
            currentEntry = false,
            visible = currentItem['visible'],
            _threshold = getThreshold(),
            trigger = triggerThreshold(visible, _threshold); // returns true when threshold is met

        if (typeof currentSelector !== 'undefined' && currentSelector !== lastSelector) {
          manager.setCurrentEntry(currentSelector);
          lastSelector = currentSelector;
          currentEntry = manager.getStoredEntryByValue('current', true);
          if (currentEntry && currentEntry.url) {
            pushState(currentEntry.url);
            var index = currentEntry.order + 1;
            var pg = currentEntry.viewed ? manager.views.getLastSeen(index) : 1;
            /*  
                If an new article is in view, increment the article count and set page to 1
                Also increment the total articles viewed
                Otherwise set the page to the last seen value
            */
            if (currentEntry.viewed) {
              manager.views.isNewEntry = false;
              manager.views.setIndex(index, pg); // changed article
            } else {
              if (index > 1) {
                manager.views.isNewEntry = true;
                manager.views.incrementArticle(1);
                manager.views.incrementTotal();
              }
              /*
                trigger a new page fetch if available
              */
              if (trigger && !currentEntry.tracked) {
                debug.log('Tracker triggered threshold');
                trackScrollThreshold(index);
                currentEntry.tracked = true; // current entry will only trigger threshold once
              }
            }
            application.broadcast('scroll-tracker.viewed', {
              item: currentEntry,
              stats: manager.views.behavioralInteraction(),
              current: manager.getStoredEntryByValue('current', true)
            });
          }
        }
      }
    }
  }

  function updateIteration() {
    if (getIteration()) {
      var currentIteration = getIteration();
      var updater = getTotalIteration();
      currentIteration++;
      updater++;
      setIteration(currentIteration);
      setTotalIteration(updater);
    }
  }

  function setViewport() {
    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : viewport;

    viewport = val;
  }

  function getViewport() {
    if (typeof viewport !== 'undefined') {
      return viewport;
    } else {
      return false;
    }
  }

  /*
    CFF-262:
    Take a set of $elements, find which ones are visible and return the most visible one
    The elements are provided by trackViewPort
    This function replaces getClosest for desktop
  */
  function getItemsInVP($set) {
    var arr = [],
        visibleItem = { el: null, visible: 0 },
        height = window.innerHeight;
    $set.each(function (i, val) {
      var $ar = $(val),
          // article $
      ar = void 0;

      /**
       * Check the entire container for the first article.  Check the article content container for all others (more accurate)
       * The first article can have large right rails and that's why the exception is needed
      */
      if (!$ar.hasClass('container-site')) {
        $ar = $(val).find('.article-content');
      }
      ar = $ar[0];
      if (!(ar && ar['getBoundingClientRect'])) {
        // exit if this is not a node
        return;
      }
      var pos = ar.getBoundingClientRect(),
          top = pos.top,
          bottom = pos.bottom,
          visible = 0;
      if (top > 0 || bottom > 0) {
        // Is not past view port
        if (top > 0 && top < height) {
          // Is fully or partially in viewport
          visible = height - top;
        }
        if (top < 0 && bottom > 0) {
          // Is scrolled but still in viewport
          visible = bottom > height ? bottom : bottom;
        }
        arr.push({ el: val, visible: visible });
      }
    });
    if (arr.length > 0) {
      arr.sort(function (a, b) {
        // Most visible will be at the end
        if (a && b) {
          return a.visible - b.visible;
        }
      });
      visibleItem = arr.pop();
    }
    visibleItem.visibleAmt = visibleItem.visible / height;
    return visibleItem;
  }

  //  Page is almost scrolled
  function triggerThreshold(visible, threshold) {
    if (!(visible && threshold)) {
      return false;
    }
    var height = window.innerHeight;
    var isInTH = visible - visible * threshold < height;
    return isInTH;
  }

  function getClosest($set, offset) {
    var el = null,
        elOffset = void 0,
        x = offset.left,
        y = offset.top,
        distance = void 0,
        dx = void 0,
        dy = void 0,
        minDistance = void 0;
    $set.each(function () {
      elOffset = $(this).offset();

      if (x >= elOffset.left && x <= elOffset.right && y >= elOffset.top && y <= elOffset.bottom) {
        el = $(this);
        return false;
      }

      var offsets = [[elOffset.left, elOffset.top], [elOffset.right, elOffset.top], [elOffset.left, elOffset.bottom], [elOffset.right, elOffset.bottom]];
      for (var off in offsets) {
        dx = offsets[off][0] - x;
        dy = offsets[off][1] - y;
        distance = Math.sqrt(dx * dx + dy * dy);
        if ((minDistance === undefined || distance < minDistance) && elOffset.top < $(window).scrollTop() + $(window).height()) {
          minDistance = distance;
          el = $(this);
        }
      }
    });
    return el;
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {

    setNamespace: setNamespace,
    setInterval: setInterval,
    setThreshold: setThreshold,
    setContainer: setContainer,
    getContainer: getContainer,
    getIteration: getIteration,
    setScrollHandler: setScrollHandler,
    setViewport: setViewport,
    trackViewport: trackViewport,
    getClosest: getClosest

  };
});

/***/ }),
/* 449 */
/***/ (function(module, exports) {

SNI.Application.addService('social/sharebar', function (application) {
  //-----------------------------------------------------------
  // Private
  //-----------------------------------------------------------
  var debug = application.getService('logger').create('service.sharebar');
  var check = application.getService('check').new(debug);
  var gigya = check.exists('gigya.socialize') ? application.getGlobal('gigya') : false;
  var deviceType = application.getService('device-type');
  var containerSel = '.o-SocialShare';
  var defaults = {
    shareButtons: [{ provider: 'Pinterest', sniTrackSlug: 'sharepin' }, { provider: 'Facebook', sniTrackSlug: 'sharefb' }, { provider: 'Twitter', sniTrackSlug: 'sharetw' },
    //{ provider: 'Googleplus', sniTrackSlug: 'shareg' },  //not used by core at launch
    { provider: 'Email', sniTrackSlug: 'sharemail' }]
  };

  /**
   * @function buildShareButtons - uses metadata to build out button array as
   * expected by gigya.
   *
   * @param {object} metaData - values to use for the sharebuttons
   *
   */
  function buildShareButtons(metaData) {
    var shareButtons = defaults.shareButtons;
    var blankImg = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    for (var i = 0; i < shareButtons.length; i++) {
      shareButtons[i].iconImgUp = blankImg;
      //for internal tracking purposes:
      shareButtons[i].url = metaData.url + (metaData.url.indexOf('?') === -1 ? '?' : '&') + 'soc=' + shareButtons[i].sniTrackSlug;
    }
    return shareButtons;
  }

  function createUserAction(config) {
    if (!gigya) {
      return;
    }
    var metaData = config.metaData;
    var userAction = new gigya.socialize.UserAction();

    userAction.setTitle(metaData.title);
    userAction.setDescription(metaData.description);
    userAction.setLinkBack(metaData.url);
    userAction.addMediaItem({
      type: 'image',
      src: metaData.image,
      href: metaData.url
    });

    // Add user action to gigya settings;
    return userAction;
  }

  function preventMultipleBars($container) {
    var $components = $(containerSel);
    function isMobileException($ele) {
      // contexts where a non-sticky version is allowed on mobile should return true
      return $ele.closest('#vote-modal').length;
    }
    if (deviceType.isMobile && $components.length > 1 && !isMobileException($container)) {
      var $component = $container.closest(containerSel);
      if ($components.index($component) !== 0) {
        debug.warn('extraneous sharebar not initialized and the element has been removed from the page.', $component);
        $component.remove();
        return true;
      }
    }
    return false;
  }

  function adjustAnchorScroll($sb, $themeSel) {
    $('[href^=\'#\']').filter(function () {
      //prevent conflict with tab behavior
      if ($(this).attr('data-type') === 'tab-ctrl') {
        return false;
      }
      var $anchored = $($(this).attr('href'));
      $(this).data('anchored', $anchored);
      return $anchored.length && $anchored.offset() && $anchored.offset().top && $anchored.offset().top > 0;
    }).on('click', function (e) {
      var top = $(this).data('anchored').offset().top - getHeight();
      if (top > 0) {
        debug.log('animating scroll to top');
        $('html, body').scrollTop(top);
        e.preventDefault();
        return false;
      }
    });
  }

  function getThemeSel() {
    return $('.sni-theme-selector-theme-sel').closest('div');
  }

  function getHeight($container, $themeSel) {
    $themeSel = $themeSel || getThemeSel();
    $container = $container || $(containerSel);
    return $container.outerHeight(true) + $themeSel.outerHeight();
  }

  function initShareBar(config, $container) {
    if (deviceType.isMobile) {
      if (preventMultipleBars($container)) return false;
      // Recipes on mobile have sticky Next / Prev buttons that conflict with the social share bar that is also supposed to stick on mobile.
      // config.fixed should be set according to the template type - true if on a Recipe Page, false otherwise.
      if (!config.fixed) {
        var $h = $('header:first');
        var $themeSel = getThemeSel();
        var shareTop = $themeSel.length ? $themeSel.outerHeight() - 2 : 0;
        $container.css({
          top: shareTop
        });
        if ($h.length) {
          $(window).on('scroll', function () {
            var scrollTop = $(window).scrollTop();
            var headerHeight = $h.is(':visible') ? $h.height() + $h.offset().top - shareTop : 0;
            $container.css('willChange', scrollTop < headerHeight + 200 ? 'height' : 'auto').toggleClass('is-Open', scrollTop > headerHeight);
          }).trigger('scroll');
        }
        adjustAnchorScroll($container, $themeSel);
      }
    }
    //this gives the automated tests a way to know that the hidden gigya social share bar is ready to click
    application.getGlobal('SNI').GigyaSocialToolbarIsReady = true;
  }

  // We must turn off click tracking (`.off('click.sni_analytics')`) on our static buttons because analytics calls are already made when
  // Gigya buttons themselves are clicked (or simulated to be clicked, as the case now is).

  function bindStaticButtons($container) {
    var $facetButtons = $container.closest(containerSel).find('[data-social-share-network]');
    $facetButtons.off('click.sni_analytics').on('click', function (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      var network = $(this).attr('data-social-share-network');
      var sel = '.gig-button-container-' + network + ' [onclick]:first';
      var $uglyGigyaButton = $container.find(sel);
      $uglyGigyaButton.trigger('click');
    });
  }

  return {
    show: function show($container, options) {
      if (preventMultipleBars($container)) return false;

      debug.log('sharebar.show(' + $container.attr('id') + ') started. options:', options);
      delete options.containerPrefix;
      var shareBarSettings = void 0;
      var config = Object.assign({}, defaults, options);
      // ensure gigya
      if (!gigya) {
        debug.log('sharebar.show() exited because gigya hasn\'t initialized');
        return false;
      }
      // create shareBarSettings
      shareBarSettings = {
        containerID: $container.attr('id'),
        deviceType: deviceType.isMobile ? 'mobile' : 'desktop',
        emailBody: config.emailBody,
        facebookDialogType: config.facebookDialogType,
        iconsOnly: config.mobileIcons,
        layout: deviceType.isMobile ? config.mobileLayout : config.layout,
        noButtonBorders: config.noButtonBorders,
        shareButtons: buildShareButtons(config.metaData),
        showCounts: config.showCounts,
        useEmailCaptcha: config.useEmailCaptcha,
        userAction: createUserAction(config),
        onLoad: function onLoad(e) {
          var $wrap = $container.closest(containerSel).find('[data-social-share-wrap]');
          bindStaticButtons($container);
          initShareBar(config, $wrap);
        }
      };
      gigya.socialize.showShareBarUI(shareBarSettings);
      debug.log('sharebar.show() finished.');
    },
    getHeight: getHeight
  };
});

/***/ }),
/* 450 */
/***/ (function(module, exports) {

SNI.Application.addService('stream-manager', function (application) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var sS = application.getGlobal('sessionStorage'),
      debug = application.getService('logger').create('service.stream-manager');

  var entries = {},
      tracked = [],
      order = 0,
      entry = void 0,
      futureEntry = void 0,
      response = void 0,
      loadedUrl = void 0,
      selector = void 0,
      htmlFragmentSelector = 'lazy-fetch-html-content',

  /*
    CFF-262/ REX-21:
    Handles the behavioral interaction counts:
    It tracks current: article in view - current page in article - total pages viewed, e.g. 1-1-1
  */
  views = {
    articles: 1, //  The index of the current article
    inArticlePage: 1, //  Will be set to last seen on a previously viewed article
    totalPages: 1, //  Always increasing
    lastPage: {}, //  track the article last seen by key
    isNewEntry: true,
    //  Used to recall the last page viewed in a specific article.
    setLastSeen: function setLastSeen() {
      var index = this.articles;
      this.lastPage[index] = this.inArticlePage;
    },

    //  Used when switching to a previously viewed article
    getLastSeen: function getLastSeen(index) {
      var i = index || this.articles;
      return this.lastPage[i];
    },

    //  Increment pages viewed
    incrementPage: function incrementPage() {
      this.inArticlePage++;
      this.totalPages++;
      this.setLastSeen();
    },

    // Article changed: increment article number and set last seen page in tracker
    incrementArticle: function incrementArticle(setPg) {
      this.articles++;
      if (setPg) {
        this.inArticlePage = setPg;
        this.setLastSeen();
      }
    },

    //  Total pages can only increase
    incrementTotal: function incrementTotal() {
      this.totalPages++;
    },

    //  Used when switching to a previously viewed article
    setIndex: function setIndex() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var pg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this.articles = i;
      this.inArticlePage = pg;
      this.lastPage[i] = pg;
    },

    //  Compose the behavioral interaction from tracked values
    behavioralInteraction: function behavioralInteraction() {
      return this.articles + '-' + this.inArticlePage + '-' + this.totalPages;
    }
  },

  /* REX-21
     Metadata values saved here to allow predictable access to the data.
     Previously the values would match the "current entry" which can change as the page scrolls
     The data is stored by entry index.
     We will need to revisit the overall entry management to remove deprecated functionality
  */
  mdm = {
    entries: {},
    addEntry: function addEntry(index, val) {
      this.entries[index] = val;
    },
    getEntry: function getEntry(index) {
      return this.entries[index];
    }
  };

  function fetchResponse(currentUrl) {
    var promise = new Promise(function (resolve, reject) {
      if (typeof currentUrl !== 'undefined') {
        $.getJSON(currentUrl, function (data) {
          setResponse(data);
        }).done(function () {
          resolve(getResponse());
        }).fail(function (jqxhr, settings, exception) {
          debug.error('setResponse: unable to fetch response: ', exception);
          reject(exception);
        });
      } else {
        debug.warn('setResponse: unable to fetch response: url undefined: ', currentUrl);
        reject('Url Undefined');
      }
    });
    return promise;
  }

  //   This is a hack to get the HTML block of the response separately (if loadHtml flag set in initial response),
  //   so it is processed by the link rewriter server-side.  It then replaces the HTML in the JSON object initially retrieved,
  //   so downstream code will insert the processed HTML and present friendly URLs in the streamed assets.
  function fixResponse(dta) {
    var promise = new Promise(function (resolve, reject) {
      if (!dta.loadHtml || dta.loadHtml !== 'true') {
        // don't get HTML content separately
        debug.log('fixResponse: NOT getting HTML separately.');
        resolve(getResponse());
      } else {
        // get HTML content separately to get links rewritten
        debug.log('fixResponse: YES getting HTML separately.');
        $.get(getLoadedUrl() + ('.' + htmlFragmentSelector + '.html'), function (html) {
          dta.data = html;
          setResponse(dta);
        })
        // even if this request fails, fall back to unprocessed HTML in original response:
        .always(function () {
          resolve(getResponse());
        });
      }
    });
    return promise;
  }

  function setResponse(val) {
    if (typeof val !== 'undefined') {
      response = val;
    }
  }

  function getResponse() {
    if (typeof response !== 'undefined') {
      return response;
    } else {
      return false;
    }
  }

  function setSelector(val) {
    if (typeof val !== 'undefined') {
      selector = val;
    }
  }

  function getSelector() {
    if (typeof selector !== 'undefined') {
      return selector;
    } else {
      return false;
    }
  }

  function setLoadedUrl(val) {
    if (typeof val !== 'undefined') {
      loadedUrl = val;
    }
  }

  function getLoadedUrl() {
    if (typeof loadedUrl !== 'undefined') {
      return loadedUrl;
    } else {
      return false;
    }
  }

  function getNextEntry(currentResponse) {
    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dynamicList';
    var seo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'seoMetaData';
    var sel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'nextUP';

    if (typeof currentResponse !== 'undefined') {
      if (currentResponse.hasOwnProperty(list)) {
        return findUnique(currentResponse[list]);
      } else if (currentResponse.hasOwnProperty(seo) && currentResponse[seo].hasOwnProperty(sel)) {
        return currentResponse[seo][sel];
      } else {
        debug.error('getNextEntry: unable to set next entry: no dynamic list or override asset');
        return false;
      }
    }
  }

  function getFutureEntry() {
    return futureEntry;
  }

  function findUnique(list) {
    if (typeof list !== 'undefined' && typeof tracked !== 'undefined') {
      debug.log('findUnique: list: ', list);
      // let cleanTracks = [];
      // tracked.forEach(function(element) {
      //   cleanTracks.push(element.replace(/(.*\/[a-z]{0,2}\/)(.+\/)(.*\/[0-9]{0,4}\/[a-z]\/)(.*)/,'/$2$4'));
      // });
      for (var item in list) {
        // let cleanItem = list[item].replace(/(.*\/[a-z]{0,2}\/)(.+\/)(.*\/[0-9]{0,4}\/[a-z]\/)(.*)/,'/$2$4');
        debug.log('findUnique: item: ', list[item], ', tracked: ', tracked, ', inArray: ', $.inArray(list[item], tracked));
        if ($.inArray(list[item], tracked) === -1) {
          debug.log('findUnique: returned item: ', list[item]);
          return list[item];
        }
      }
      return false;
    }
  }

  function createEntry(currentResponse, nextUrl) {
    var mdm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'mdManager';
    var og = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'seoMetaData';
    var content = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'data';

    return {
      url: currentResponse.hasOwnProperty(mdm) && currentResponse[mdm].hasOwnProperty('Url') ? currentResponse[mdm].Url : false,
      nextUp: typeof nextUrl !== 'undefined' ? nextUrl : false,
      class: currentResponse.hasOwnProperty(mdm) && currentResponse[mdm].hasOwnProperty('DetailID') ? currentResponse[mdm].DetailID : false,
      viewed: false,
      tracked: false,
      current: false,
      mdm: currentResponse.hasOwnProperty(mdm) ? currentResponse[mdm] : false,
      og: currentResponse.hasOwnProperty(og) ? currentResponse[og] : false,
      content: currentResponse.hasOwnProperty(content) ? currentResponse[content] : false,
      order: +order,
      lastPg: 1
    };
  }

  function storeEntry(currentEntry, identifier) {
    if (typeof currentEntry !== 'undefined' && currentEntry.hasOwnProperty(identifier)) {
      if (currentEntry[identifier] !== '') {
        entries[currentEntry[identifier]] = currentEntry;
        return true;
      } else {
        debug.warn('storeEntry: unable to store entry: empty identifier: ', identifier, currentEntry[identifier]);
        return false;
      }
    }
  }

  function getTracked() {
    if (sS.getItem('trackedStreamEntries')) {
      tracked = JSON.parse(sS.getItem('trackedStreamEntries'));
    } else {
      debug.log('getTracked: no tracked stream entries');
    }
    return tracked;
  }

  function trackEntry(entryUrl) {
    if (typeof entryUrl !== 'undefined') {
      if ($.inArray(entryUrl, tracked) === -1) {
        tracked.push(entryUrl);
      }
    }
  }

  function setTracked() {
    if (typeof tracked !== 'undefined' && tracked.length > 0) {
      sS.setItem('trackedStreamEntries', JSON.stringify(tracked));
    }
  }

  function getTrackedSet() {
    if (typeof tracked !== 'undefined') {
      return tracked;
    } else {
      return false;
    }
  }

  function setEntry(val) {
    if (typeof val !== 'undefined') {
      entry = val;
    }
  }

  function setFutureEntry(val) {
    futureEntry = val;
  }

  function getEntry() {
    if (typeof entry !== 'undefined') {
      return entry;
    } else {
      return false;
    }
  }

  function getStoredEntryByValue(prop, val) {
    if (typeof prop !== 'undefined' && typeof val !== 'undefined') {
      for (var item in entries) {
        if (entries[item].hasOwnProperty(prop) && entries[item][prop] === val) {
          return entries[item];
        }
      }
      return false;
    }
  }

  function updateStoredEntry(identifier, prop, val) {
    if (typeof identifier !== 'undefined' && typeof prop !== 'undefined' && typeof val !== 'undefined') if (entries.hasOwnProperty(identifier) && entries[identifier].hasOwnProperty(prop)) {
      entries[identifier][prop] = val;
    }
  }

  function getStoredEntriesByValue(prop, val) {
    if (typeof prop !== 'undefined' && typeof val !== 'undefined') {
      var tempEntries = {};
      for (var item in entries) {
        if (entries[item].hasOwnProperty(prop) && entries[item][prop] === val) {
          tempEntries[item] = entries[item];
        }
      }
      if ($.isEmptyObject(tempEntries)) {
        return false;
      } else {
        return tempEntries;
      }
    }
  }

  function getStoredEntries() {
    return entries;
  }

  function setCurrentEntry(id) {
    var sel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'class';
    var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'current';
    var val = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    if (typeof id !== 'undefined') {
      for (var item in entries) {
        if (entries[item][sel] === id) {
          entries[item][prop] = val;
        } else {
          entries[item][prop] = !val;
        }
      }
    }
  }

  function getEntryElements() {
    var elementSet = [];
    for (var item in entries) {
      if (entries[item].hasOwnProperty('class') && entries[item].class !== '') {
        elementSet.push($('.' + entries[item].class));
      }
    }
    if (elementSet.length > 0) {
      return $(elementSet);
    } else {
      return false;
    }
  }

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  return {
    addEntry: function addEntry(suppliedUrl) {
      var contract = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var insert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (typeof suppliedUrl !== 'undefined') {
        var processedUrl = void 0,
            currentSelector = void 0,
            tempEntry = void 0,
            clean = void 0,
            resolved = false;

        currentSelector = getSelector();
        if (currentSelector) {
          processedUrl = suppliedUrl + '.' + currentSelector + '.json';
          setLoadedUrl(suppliedUrl);
          trackEntry(suppliedUrl);
          fetchResponse(processedUrl).then(fixResponse) //   Get HTML fragment if needed
          .then(function (val) {
            tempEntry = createEntry(val, getNextEntry(val));
            mdm.addEntry(order + 1, val['mdManager']); // save mdManager values to a central location.
            order++;
            if (!insert) {
              setEntry(tempEntry); // set as current entry the first time
            } else {
              setFutureEntry(tempEntry); // Future entry holds the next UP values we'll need later
            }
            if (storeEntry(tempEntry, 'url')) {
              // add to entries array
              if (tempEntry.url.indexOf('.html') > 0) {
                clean = tempEntry.url.substring(0, tempEntry.url.lastIndexOf('.html'));
              } else {
                clean = tempEntry.url;
              }
              debug.log('Loading', clean);
              application.broadcast('stream-manager.entryLoaded', {
                item: tempEntry,
                append: insert
              });
              resolved = true;
            }
            if (contract && resolved) {
              contract.resolve();
            } else if (contract && !resolved) {
              contract.reject();
            }
          }).catch(function (reason) {
            debug.error('addEntry: unable to fetch response: ', reason);
            application.broadcast('article-stream.end');
          });
        }
      }
    },

    fetchResponse: fetchResponse,
    getResponse: getResponse,
    setResponse: setResponse,
    setSelector: setSelector,
    getSelector: getSelector,
    setLoadedUrl: setLoadedUrl,
    getLoadedUrl: getLoadedUrl,
    getNextEntry: getNextEntry,
    findUnique: findUnique,
    createEntry: createEntry,
    storeEntry: storeEntry,
    getTracked: getTracked,
    getTrackedSet: getTrackedSet,
    trackEntry: trackEntry,
    setTracked: setTracked,
    setEntry: setEntry,
    getEntry: getEntry,
    getFutureEntry: getFutureEntry,
    getStoredEntryByValue: getStoredEntryByValue,
    updateStoredEntry: updateStoredEntry,
    getStoredEntriesByValue: getStoredEntriesByValue,
    getStoredEntries: getStoredEntries,
    setCurrentEntry: setCurrentEntry,
    getEntryElements: getEntryElements,
    views: views, // page view tracking
    mdm: mdm //  metadata tracking
  };
});

/***/ }),
/* 451 */
/***/ (function(module, exports) {

SNI.Application.addService('track-shopping', function (context) {

  /**
   *  __   __              ___  ___
   * |__) |__) | \  /  /\   |  |__
   * |    |  \ |  \/  /--\  |  |___
   *
   */

  var shopTrack = context.getGlobal('shopTrack'),
      debug = context.getService('logger').create('service.track-shopping'),
      mdManager = context.getGlobal('mdManager');

  /**
   *  __        __          __
   * |__) |  | |__) |    | /  `
   * |    \__/ |__) |___ | \__,
   *
   */

  function trackShopping(data, eventType) {
    var componentName = data.componentname || mdManager.getParameter('componentName'),
        partner = data.partner || mdManager.getParameter('partner'),
        productData = data.title || data.products,
        imageCount = data.imagecount || mdManager.getParameter('imageCount'),
        productCount = data.productcount || mdManager.getParameter('productCount');

    var omniture = context.getGlobal('s');

    if (omniture && shopTrack && mdManager) {
      debug.log('trackShopping: metadata: ', { componentName: componentName, partner: partner, productData: productData, imageCount: imageCount, productCount: productCount, eventType: eventType });
      shopTrack(this, 'shopping', componentName, 'n/a', partner, productData, imageCount, productCount, 'n/a', 'n/a', 'n/a', eventType);
    }
  }

  function trackProductClick(metadata) {
    trackShopping(metadata, 'click');
  }

  function trackProductImpression(metadata) {
    trackShopping(metadata, 'impression');
  }

  return {
    trackShopping: trackShopping,
    trackProductClick: trackProductClick,
    trackProductImpression: trackProductImpression
  };
});

/***/ })
/******/ ]);
//# sourceMappingURL=core.js.map